<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一个python游戏迷你引擎(持续更新)</title>
      <link href="2022/03/26/pygame/"/>
      <url>2022/03/26/pygame/</url>
      
        <content type="html"><![CDATA[<p>生命不息，折腾不止v_v</p><center><span style="color:blue;font-size:15px">2022/3/26</span></center><p><code>pip list</code>查看现有插件</p><p><code>pip install pygame</code>安装pygame库（不能连接vpn，否则会报错）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#代码等项目完成后统一添加</span><span class="token comment">#ps:我的素材图找的还是如此离谱</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/pygame/1.gif" alt="Demo_v0.01"></p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pygame </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="2021/06/22/linear-algebra/"/>
      <url>2021/06/22/linear-algebra/</url>
      
        <content type="html"><![CDATA[<center><span style="color:blue;font-size:15px">2021/6/22</span></center><h2 id="第一章-行列式"><a href="#第一章-行列式" class="headerlink" title="第一章 行列式"></a>第一章 行列式</h2><h3 id="第一节-全排列及其逆序数、对换"><a href="#第一节-全排列及其逆序数、对换" class="headerlink" title="第一节 全排列及其逆序数、对换"></a>第一节 全排列及其逆序数、对换</h3><h4 id="一、全排列的定义"><a href="#一、全排列的定义" class="headerlink" title="一、全排列的定义"></a>一、全排列的定义</h4><p>n个不同的元素排成一列， 叫做这n个元素的<strong>全排列</strong>，简称<strong>排列</strong>。</p><h4 id="二、排列的逆序数"><a href="#二、排列的逆序数" class="headerlink" title="二、排列的逆序数"></a>二、排列的逆序数</h4><p>对于n个不同的元素，规定各元素之间由小到大为<strong>标准次序</strong>。<br><span style="color:red;font-size:20px">定义：</span>当某两个元素的先后次序与标准次序不同时，就说有一个<strong>逆序</strong>，一个排列中所有逆序的总数叫做这个<strong>排列的逆序数</strong>。</p><p><strong>例：</strong>12345为标准次序，t(12345)=0；32145有3个逆序数，t(32145)=3 </p><p>$\displaystyle t\left(n(n-1)(n-2)\cdots21\right)=n-1+n-2+\cdots+2+1=\frac{n(n-1)}{2}$</p><h4 id="三、排列的奇偶性"><a href="#三、排列的奇偶性" class="headerlink" title="三、排列的奇偶性"></a>三、排列的奇偶性</h4><p>逆序数为奇数的排列称为奇排列；逆序数为偶数的排列称为偶排列</p><h4 id="四、对换"><a href="#四、对换" class="headerlink" title="四、对换"></a>四、对换</h4><p><span style="color:blue;font-size:20px">定理：</span>一个排列中任意两个元素对换，排列改变奇偶性</p><p><span style="color:green;font-size:20px">推论：</span>奇排列对换成标准排列的对换次数为奇数，偶排列对换成标准排列的对换次数为偶数</p><h3 id="第二节-行列式的定义"><a href="#第二节-行列式的定义" class="headerlink" title="第二节 行列式的定义"></a>第二节 行列式的定义</h3><h4 id="一、二元线性方程组"><a href="#一、二元线性方程组" class="headerlink" title="一、二元线性方程组"></a>一、二元线性方程组</h4><p><strong>例1：</strong>用消元法解二元线性方程组</p><script type="math/tex; mode=display">\begin{cases}a_{11} x_{1}+a_{12} x_{2}=b_{1}\qquad (1) \\a_{21} x_{1}+a_{22} x_{2}=b_{2}\qquad (2)\end{cases}\\(1) \times a_{22}: a_{11} a_{22} x_{1}+a_{12} a_{22} x_{2}=b_{1} a_{22}\\(2) \times a_{12}: a_{11} a_{21} x_{1}+a_{12} a_{22} x_{2}=b_{2} a_{12}</script><p>两式相减消去$x_2$，得</p><script type="math/tex; mode=display">(a_{11}a_{22}-a_{12}a_{21}x_1)=b_1a_{22}-a_{12}b_2</script><p>类似地，消去$x_1$，得</p><script type="math/tex; mode=display">(a_{11}a_{22}-a_{12}a_{21}x_2)=b_2a_{11}-a_{21}b_1</script><p>当<script type="math/tex">a_{11} a_{22}-a_{12} a_{21} \neq 0</script> 时，方程组的解为</p><script type="math/tex; mode=display">\displaystyle x_{1}=\frac{b_{1} a_{22}-a_{12} b_{2}}{a_{11} a_{22}-a_{12} a_{21}}, \quad x_{2}=\frac{a_{11} b_{2}-b_{1} a_{21}}{a_{11} a_{22}-a_{12} a_{21}}</script><h4 id="二、二阶行列式"><a href="#二、二阶行列式" class="headerlink" title="二、二阶行列式"></a>二、二阶行列式</h4><p><span style="color:red;font-size:20px">定义：</span><script type="math/tex">\begin{vmatrix}a_{11}&a_{12}\\a_{21}&a_{22}\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21}</script>（行列式是一个<strong>数</strong>）</p><p>利用二阶行列式的概念，二元线性方程组的解也可写成二阶行列式，即</p><p>记<script type="math/tex">D=\begin{vmatrix}a_{11}&a_{12}\\a_{21}&a_{22}\end{vmatrix}=a_{11} a_{22}-a_{12} a_{21}\quad \\D_1=\begin{vmatrix}b_{1}&a_{12}\\b_{2}&a_{22}\end{vmatrix}=b_{1} a_{22}-a_{12} b_{2}\\D_2=\begin{vmatrix}a_{11}&b_{1}\\a_{21}&b_{2}\end{vmatrix}=a_{11} b_{2}-b_{1} a_{21}</script></p><p>那么行列式的解可写作<script type="math/tex">\displaystyle x_1=\frac{D_1}{D},x_2=\frac{D_2}{D}</script></p><p><strong>注意：</strong>分子分母都为原方程组的系数构成的行列式</p><h4 id="三、三阶行列式"><a href="#三、三阶行列式" class="headerlink" title="三、三阶行列式"></a>三、三阶行列式</h4><p><span style="color:red;font-size:20px">定义：</span><script type="math/tex">\begin{vmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\end{vmatrix}=a_{11} a_{22} a_{33}+a_{12} a_{23} a_{31}+a_{13} a_{21} a_{32}-a_{11} a_{23} a_{32}-a_{12} a_{21} a_{33}-a_{13} a_{22} a_{31},</script></p><p>三元线性方程组的解问题也同理</p><h3 id="第三节-n阶行列式的定义"><a href="#第三节-n阶行列式的定义" class="headerlink" title="第三节 n阶行列式的定义"></a>第三节 n阶行列式的定义</h3><p>$a_{xy}$的第一个下标称为行标，第二个下标称为列标，在行列式的每一项中，所有元素都处在不同的行，不同的列</p><p><strong>列标</strong>的排列为偶排列时的项为正号，列标的排列为奇排列时的项为负号，因此各项的正负号可以表示为$(-1)^t$</p><p>二阶：<script type="math/tex">\begin{vmatrix}a_{11} & a_{12} \\a_{21} & a_{22}\end{vmatrix}=\sum(-1)^{t\left(p_{1} p_{2}\right)} a_{1 p_{1}} a_{2 p_{2}}</script>，共有两项</p><p>三阶：<script type="math/tex">\begin{vmatrix}a_{11} & a_{12} & a_{13} \\a_{21} & a_{22} & a_{23} \\a_{31} & a_{32} & a_{33}\end{vmatrix}=\sum(-1)^{t\left(p_{1} p_{2} p_{3}\right)} a_{1 p_{1}} a_{2 p_{2}} a_{3 p_{3}}</script>，共有六项</p><p>n阶的行列式有n!项</p><p><strong>例：</strong>已知<script type="math/tex">a_{23}a_{31}a_{42}a_{65}a_{56}a_{14}</script>是六阶行列式中的一项，试确定该项所带符号</p><p>解：<script type="math/tex">a_{23}a_{31}a_{42}a_{65}a_{56}a_{14}=a_{14}a_{23}a_{31}a_{42}a_{56}a_{65}</script></p><p>t(431265)=6，所以该项带正号</p><p><strong>notes:</strong></p><ol><li>行列式结果是一个数</li><li>当n=1时，竖杠不用写，直接写$a_{11}$，与绝对值分开</li><li>二阶、三阶行列式有对角线法则，四阶及四阶以上的行列式没有对角线法则</li></ol><p>主对角线以下（上）的元素都为0的行列式叫做<strong>上（下）三角行列式</strong><br>主对角线以下和以上的元素都为0的行列式叫做<strong>对角行列式</strong><br>三角行列式和对角行列式的值都是主对角线的元素相乘</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>n阶行列式共有n!项，每项都是位于不同行、不同列的n个元素的乘积组成，正负号由下标排列的逆序数决定。</p><h3 id="第四节-行列式的性质"><a href="#第四节-行列式的性质" class="headerlink" title="第四节 行列式的性质"></a>第四节 行列式的性质</h3><p><span style="color:sienna;font-size:20px">性质1：</span>行列式和它的转置行列式相等（行列式对行有的性质对列也有）</p><p><span style="color:sienna;font-size:20px">性质2：</span>对换行列式的两行（列），行列式变号（$r_i\leftrightarrow r_j$)</p><p><span style="color:green;font-size:20px">推论：</span>如果行列式有两行（列）完全相同，则此行列式等于零</p><p><span style="color:sienna;font-size:20px">性质3：</span>行列式的某一行（列）中的所有元素都乘同一数k，等于用数k乘此行列式（$r_i\times k$)</p><p><span style="color:green;font-size:20px">推论：</span>行列式中某一行（列)中的元素的公因子可以提到行列式记号的外面</p><p><span style="color:sienna;font-size:20px">性质4：</span>行列式中如果有两行（列）元素成比例，则此行列式等于零</p><p><span style="color:sienna;font-size:20px">性质5：</span>若行列式中某一行(列)元素均为两数之和，则行列式可按照该行分拆成两个行列式之和，其他各行保持不变(每次只能按照一行或者一列分拆)</p><p><span style="color:sienna;font-size:20px">性质6：</span>把行列式的某一行(列)的各元素乘以同一数然后加到另一行(列)对应的元素上去，行列式值不变（$r_i+kr_j$）</p><p><strong>计算行列式常用的方法一：</strong>任一n阶行列式均可以只经过行(列)变换化为上(下)三角形行列式</p><p>  <strong>note：</strong>若各行元素之和相同，则可将各列加到第一列提取公因子再造零</p><h3 id="第五节-行列式按行（列）展开"><a href="#第五节-行列式按行（列）展开" class="headerlink" title="第五节 行列式按行（列）展开"></a>第五节 行列式按行（列）展开</h3><p>一般来说，低阶行列式的计算比高阶行列式的计算要简便，我们先引进余子式和代数余子式的概念</p><h4 id="一、余子式和代数余子式的定义"><a href="#一、余子式和代数余子式的定义" class="headerlink" title="一、余子式和代数余子式的定义"></a>一、余子式和代数余子式的定义</h4><p><strong>余子式：</strong><script type="math/tex">在n阶行列式中，划去元素a_{ij}所在的第i行和第j列，余下元素保持原来位置组成一个n-1阶行列式，\\称为元素a_{ij}的余子式，记为M_{ij}</script></p><p><strong>代数余子式：</strong><script type="math/tex">A_{ij}=(-1)^{i+j}M_{ij}</script></p><p><strong>note：</strong><script type="math/tex">A_{ij}与a_{ij}的数值无关，与a_{ij}的位置有关</script></p><h4 id="二、有关定理、范德蒙德行列式"><a href="#二、有关定理、范德蒙德行列式" class="headerlink" title="二、有关定理、范德蒙德行列式"></a>二、有关定理、范德蒙德行列式</h4><p><span style="color:blue;font-size:20px">引理：</span><script type="math/tex">一个n阶行列式，如果其中第i行所有元素除a_{ij}外都为零，那么这个行列式等于a_{ij}与它的代数余子式的乘积，\\即D=a_{ij}A_{ij}</script></p><p><span style="color:blue;font-size:20px">定理（拉普拉斯定理）：</span>行列式D等于它任一行(列)的各个元素与其代数余子式的乘积之和（行列式按行（列）展开定理）</p><p><span style="color:green;font-size:20px">推论：</span><script type="math/tex">a_{i1}A_{j1}+a_{i2}A_{j2}+\cdots+a_{in}A_{jn}=\begin{cases}0\qquad(i\neq j)\\D\qquad(i=j)\end{cases}</script></p><p><strong>note：</strong>展开时尽量划边，让余子式易于辨认</p><p><strong>计算行列式常用的方法二：</strong>利用性质将行列式D化为某行(某列)只有一个非零元素，然后按该行(列)将行列式展开</p><p><strong>范德蒙德行列式：</strong><script type="math/tex">\displaystyle\begin{vmatrix}1 & 1 & 1 & \cdots & 1 \\x_{1} & x_{2} & x_{3} & \cdots & x_{n} \\x_{1}^{2} & x_{2}^{2} & x_{3}^{2} & \cdots & x_{n}^{2} \\\cdots & \cdots & \cdots &  & \cdots \\x_{1}^{n-2} & x_{2}^{n-2} & x_{3}^{n-2} & \cdots & x_{n}^{n-2} \\x_{1}^{n-1} & x_{2}^{n-1} & x_{3}^{n-1} & \cdots & x_{n}^{n-1}\end{vmatrix}=\prod_{n \geq i>j \geq 1}(x_{i}-x_{j})</script></p><p>特点：第一行都为1；每列等比；$x_i、x_j$为第二行元素，共有n-1+n-2+···+1=$\displaystyle \frac{n(n-1)}{2}$项</p><p><strong>计算行列式常用的方法三：</strong>递推法（建立<script type="math/tex">D_n与D_{n-1}</script>之间的关系式）</p><p><strong>note：</strong>三对角线形可用递推法</p><center><span style="color:blue;font-size:15px">2021/6/29</span></center><h2 id="第二章-矩阵及其运算"><a href="#第二章-矩阵及其运算" class="headerlink" title="第二章 矩阵及其运算"></a>第二章 矩阵及其运算</h2><h3 id="第一节-线性方程组和矩阵"><a href="#第一节-线性方程组和矩阵" class="headerlink" title="第一节 线性方程组和矩阵"></a>第一节 线性方程组和矩阵</h3><script type="math/tex; mode=display">\begin{cases} 2 x_{1}-x_{2}-x_{3}+x_{4}=2 \\ x_{1}+x_{2}-2 x_{3}+x_{4}=4\\ 4 x_{1}-6 x_{2}+2 x_{3}-2 x_{4}=4 \end{cases} \quad \Leftrightarrow \quad\begin{pmatrix} 2 & -1 & -1 & 1 & |2 \\ 1 & 1 & -2 & 1 & |4 \\ 4 & -6 & 2 & -2 & |4\end{pmatrix}</script><p>线性方程组与矩阵的对应关系：<br>上述的有序数表完全确定了原线性方程组, 对它的研究可以判断方程组的解的情况。</p><h4 id="一、线性方程组"><a href="#一、线性方程组" class="headerlink" title="一、线性方程组"></a>一、线性方程组</h4><p>称<script type="math/tex">\begin{cases} a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1\\ a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2\\ \cdots\qquad\cdots\qquad\cdots\qquad\cdots\\a_{m1}x_1+a_{m2}x_2+\cdots+a_{mn}x_n =b_m\end{cases}</script>为<strong>n元非齐次线性方程组</strong>；当b全为0时，称为<strong>n元齐次线性方程组</strong></p><h4 id="二、矩阵的定义"><a href="#二、矩阵的定义" class="headerlink" title="二、矩阵的定义"></a>二、矩阵的定义</h4><p><span style="color:red;font-size:20px">定义：</span>由$m\times n$个数$a_{ij}$（i=1,2,···,m；j=1,2,···,n）排成的m行n列的<strong>数表</strong>称为m行n列矩阵，</p><p>记作<script type="math/tex">A=\begin{pmatrix}a_{11}&a_{12}&\cdots&a_{1n}\\a_{21}&a_{22}&\cdots&a_{2n}\\\vdots&\vdots&&\vdots\\a_{m1}&a_{m2}&\cdots&a_{mn}\end{pmatrix}</script></p><p>行数和列数都等于n的矩阵称为<strong>n阶矩阵</strong>或<strong>n阶方阵</strong>，记作$A_n$</p><p>只有一行的矩阵称为<strong>行矩阵</strong>或者<strong>行向量</strong>；只有一列的矩阵称为<strong>列矩阵</strong>或者<strong>列向量</strong></p><p>两个行数、列数相等的矩阵称为<strong>同型矩阵</strong>；若同型矩阵的每个对应元素都相等，则称这两个<strong>矩阵相等</strong>，记作A=B</p><p>元素都是零的矩阵称为<strong>零矩阵</strong>，记作O，不同型的零矩阵是不同的</p><p>称<script type="math/tex">\begin{cases} y_1=a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n\\ y_2=a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n\\ \cdots\qquad\cdots\qquad\cdots\qquad\cdots\\y_m=a_{m1}x_1+a_{m2}x_2+\cdots+a_{mn}x_n \end{cases}</script>为由$x_1,x_2,\cdots,x_n$到$y_1,y_2,\cdots,y_n$的<strong>线性变换</strong>，A是线性变换的矩阵</p><h3 id="第二节-矩阵的运算"><a href="#第二节-矩阵的运算" class="headerlink" title="第二节 矩阵的运算"></a>第二节 矩阵的运算</h3><h4 id="一、矩阵的加法"><a href="#一、矩阵的加法" class="headerlink" title="一、矩阵的加法"></a>一、矩阵的加法</h4><p>同型矩阵才能进行加法运算</p><h4 id="二、数与矩阵相乘"><a href="#二、数与矩阵相乘" class="headerlink" title="二、数与矩阵相乘"></a>二、数与矩阵相乘</h4><p>数乘=遍乘</p><h4 id="三、矩阵与矩阵相乘"><a href="#三、矩阵与矩阵相乘" class="headerlink" title="三、矩阵与矩阵相乘"></a>三、矩阵与矩阵相乘</h4><p>有<script type="math/tex">A_{m\times n}B_{n\times s}=C_{ms}</script></p><p>矩阵的乘法不满足交换律，即在一般情况下$AB\neq BA$；</p><p>若$AB=BA$，则称方阵A和B是<strong>可交换的</strong>；（对角矩阵可交换）</p><p>若两个矩阵A、B满足AB=0，不能得出A=0或B=0的结论；若A$\neq $0而A(X-Y)=O，也不能得出X=Y的结论</p><p>EA=AE=A（可见单位矩阵E在矩阵乘法中的作用类似于数1  ）</p><p>引入矩阵乘法的目的是进行线性变换的合成（$y=Ax，x=Bz\Rightarrow y=A(Bz)=(AB)z$）</p><p>矩阵的幂：$A^k$就是k个A连乘，显然只有方阵的幂才有意义</p><p>当$AB\neq BA$时，$(AB)^k\neq A^kB^k、(A+B)^2\neq A^2+2AB+B^2、(A+B)(A-B)\neq A^2-B^2$</p><p><strong>好求方幂的矩阵：</strong>（1）一列乘一行（2）严格上三角矩阵（3）对角阵</p><h4 id="四、矩阵的转置"><a href="#四、矩阵的转置" class="headerlink" title="四、矩阵的转置"></a>四、矩阵的转置</h4><ol><li><p><span style="color:red;font-size:20px">定义：</span>把矩阵A的行换成同序数的列得到的新矩阵，叫作A的转置矩阵，记作$A^T$</p></li><li><p>转置矩阵满足的运算规律：</p><p>(1)$(A^T)^T=A$</p><p>(2)$(A\pm B)^T=A^T\pm B^T$</p><p>(3)$(\lambda A^T)=\lambda A^T$</p><p>(4)$(AB)^T=B^TA^T$</p></li></ol><p><strong>note1：</strong>若$A^T=A$，称A为对称矩阵；若$A^T=-A$，称A为反对称矩阵</p><p>$\displaystyle A=\frac{A+A^T}{2}（对称矩阵）+\frac{A-A^T}{2}（反对称矩阵）$</p><p>所以任意一个方阵一定可以写成一个对称矩阵和一个反对称矩阵之和</p><p><strong>note2：</strong>A为$m\times n$型，则$A^T$为$n\times m$型；$AA^T$，$A^TA$分别为m，n阶方阵且为对称矩阵</p><p><strong>note3：</strong>$\alpha=(a_1,a_2,\cdots,a_n)^T,\alpha^T=(a_1,a_2,\cdots,a_n)$</p><p>$\alpha^T\alpha=a_1^2+a_2^2+\cdots+a_n^2\geq0;\alpha^T\alpha=0\Leftrightarrow \alpha=0$（<strong>一行乘一列为数</strong>）</p><p>$\alpha\alpha^T=\begin{pmatrix}a_1^2&amp;a_1a_2&amp;\cdots&amp;a_1a_n\\a_2a_1&amp;a_2^2&amp;\cdots&amp;a_2a_n\\\cdots&amp;\cdots&amp;&amp;\cdots\\a_na_1&amp;a_na_2&amp;\cdots&amp;a_n^2\end{pmatrix};\alpha\alpha^T=0\Leftrightarrow \alpha=0$（<strong>一列乘一行为矩阵</strong>）</p><h4 id="五、方阵的行列式"><a href="#五、方阵的行列式" class="headerlink" title="五、方阵的行列式"></a>五、方阵的行列式</h4><ol><li><p><span style="color:red;font-size:20px">定义：</span>由n阶<strong>方阵</strong>A的元素所构成的行列式（各元素的位置不变），称为方阵A的行列式，记号|A|或detA</p></li><li><p>性质：设A、B为n阶方阵，则有</p><p>（1）$|A^T|=|A|$（$(A+E)^T=A^T+E\Rightarrow|A+E|=|A^T+E|$）</p><p>（2）$|\lambda A|=\lambda^n|A|$</p><p>（3）$|AB|=|A||B|=|B||A|=|BA|$（$AB\neq BA$）</p><p><strong>note1：</strong>$AB=0\not\Rightarrow A=0或B=0$</p><p>$\qquad AB=0\Rightarrow |A|=0或|B|=0$</p><p><strong>note2：</strong>如果A，B不是方阵，则$|AB|\neq |BA|$</p><p><strong>note3：</strong>$|A+B|\neq|A|+|B|$</p></li></ol><h4 id="六、方阵的伴随矩阵"><a href="#六、方阵的伴随矩阵" class="headerlink" title="六、方阵的伴随矩阵"></a>六、方阵的伴随矩阵</h4><p><span style="color:red;font-size:20px">定义：</span><script type="math/tex">A=(a_{i j})_{n}，A_{i j} 为|A|中 a_{i j}</script>的代数余子式，记 </p><script type="math/tex; mode=display">A^{*}=\begin{pmatrix}A_{11} & A_{21} & \cdots & A_{n 1} \\A_{12} & A_{22} & \cdots & A_{n 2} \\& \cdots & \cdots & \\A_{1 n} & A_{2 n} & \cdots & A_{n n}\end{pmatrix}</script><p>称A*为A的伴随矩阵（注意下标！）</p><p><strong>note：</strong>二阶矩阵求伴随阵口诀：主对调，副变号；二阶矩阵(A*)*=A​</p><p><strong>性质：</strong>$AA^<em>=A^</em>A=|A|E$</p><p>(<script type="math/tex">AA^*=|A|E\Rightarrow|A||A^*|=||A|E|=|A|^n\Rightarrow|A^*|=|A|^{n-1}</script>)</p><center><span style="color:blue;font-size:15px">2021/6/30</span></center><h3 id="第三节-逆矩阵"><a href="#第三节-逆矩阵" class="headerlink" title="第三节 逆矩阵"></a>第三节 逆矩阵</h3><p><span style="color:red;font-size:20px">定义：</span>设A是n阶方阵，如果有一个n阶方阵B，使AB=BA=E，则说A是可逆的，并把B称为A的逆矩阵，简称逆阵。记为$A^{-1}$，读作A逆。</p><p>n阶方阵A可逆的充要条件是$|A|\neq0$，当A可逆时，<script type="math/tex">A^{-1}=\frac{1}{|A|}A^*(|A|=0\Leftrightarrow |A^*|=0)</script> </p><p><strong>note：</strong>伴随求逆，二阶最方便，三阶还可以，四阶五阶太麻烦，不可取</p><p><strong>推论</strong>：若AB=E（或BA=E），则$B=A^{-1}$</p><p>若$|A|=0$，则称A为<strong>奇异矩阵</strong>（退化矩阵）(不可逆)；若$|A|\neq 0$，则称A为<strong>非奇异矩阵</strong>（非退化矩阵）(可逆)</p><p><strong>方阵A的逆矩阵的求法：</strong></p><p>（1）利用公式<script type="math/tex">A^{-1}=\frac{1}{|A|}A^*</script>（适用于二阶、三阶矩阵求逆）（$A^*=|A|A^{-1}$）</p><p>（2）寻找方阵B，使得AB=E（适用于抽象矩阵求逆）</p><p>（3）利用矩阵的初等变换求逆矩阵（后面讲）</p><p><strong>例：</strong>设方阵A满足方程$A^2-A-2E=0$，证明A，A+2E都可逆，并求它们的逆矩阵</p><p>证：<script type="math/tex">(1)由A^2-A-2E=0\\得A(A-E)=2E\Rightarrow A\frac{A-E}{2}=E\\所以A可逆，且A^{-1}=\frac 1 2(A-E)\\(2)由A^2-A-2E=0\\得(A+2E)(A-3E)+4E=0\\(A+2E[-\frac 1 4(A-3E)])=E\\所以A+2E可逆，且(A+2E)^{-1}=-\frac 1 4(A-3E)</script></p><p><strong>逆矩阵满足以下运算规律：</strong></p><p>（1）$若A可逆，则A^{-1}也可逆，且(A^{-1})^{-1}=A$</p><p>（2）$若A可逆，数\lambda\neq0，则\lambda A也可逆，且(\lambda A)^{-1}=\frac 1\lambda A^{-1}$</p><p>（3）$若A，B为同阶方阵且均可逆，则AB亦可逆，且（AB)^{-1}=B^{-1}A^{-1}$</p><p>（4）$若A可逆，则A^T也可逆，且(A^T)^{-1}=(A^{-1})^T$</p><p>（5）$若A可逆，则|A^{-1}|=|A|^{-1}$</p><p><strong>note：</strong>$(A+B)^{-1}\neq A^{-1}+B^{-1}$</p><p><strong>伴随矩阵的性质：</strong></p><p>（1）$|A^*|=|A|^{n-1}$</p><p>（2）<script type="math/tex">(kA)^*=K^{n-1}A^*</script></p><p>（3）<script type="math/tex">(A^*)^T=(A^T)^*</script></p><p>（4）<script type="math/tex">(A^*)^{-1}=(A^{-1})^*=\frac A {|A|}</script>（假设A可逆）</p><p>（5）设A为n阶可逆阵，则<script type="math/tex">(A^*)^*=|A|^{n-2}A，当n=2时，(A^*)^*=A</script></p><p>（6）设A，B均为可逆矩阵，则<script type="math/tex">(AB)^*=B^*A^*</script></p><div class="table-container"><table><thead><tr><th>转置</th><th>逆$（AA^{-1}=E)$</th><th>伴随$(A^{-1}=\frac{1}{\vert A\vert }A^*)$</th></tr></thead><tbody><tr><td>$(A^T)^T$=A</td><td>$(A^{-1})^{-1}=A$</td><td><script type="math/tex">(A^*)^*=\vert A\vert ^{n-2}A</script></td></tr><tr><td>$(kA)^T=kA^T$</td><td>$(kA)^{-1}=\frac 1 k A^{-1}$</td><td><script type="math/tex">(kA)^*=k^{n-1}A^*</script></td></tr><tr><td>$(AB)^T=B^TA^T$</td><td>$(AB)^{-1}=B^{-1}A^{-1}$</td><td><script type="math/tex">(AB)^*=B^*A^*</script></td></tr><tr><td>$(A+B)^T=A^T+B^T$</td><td>无</td><td>无</td></tr><tr><td>$(A^T)^{-1}=(A^{-1})^T$</td><td><script type="math/tex">(A^{-1})^*=(A^*)^{-1}=\frac{A}{\vert A\vert }</script></td><td><script type="math/tex">(A^*)^T=(A^T)^*</script></td></tr></tbody></table></div><h3 id="第四节-克拉默法则"><a href="#第四节-克拉默法则" class="headerlink" title="第四节 克拉默法则"></a>第四节 克拉默法则</h3><p><strong>克拉默法则：</strong>如果一个（方程个数和未知数个数相同的）非齐次线性方程组的系数矩阵A的行列式不等于零，那么，方程组有唯一解$x_n=\frac{|A_n|}{A}$</p><p><strong>notes：</strong></p><p>（1）如果线性方程组系数行列式D≠0，则有解，且解唯一；若系数行列式为零，则解不唯一或无解 。</p><p>（2）Cramer法则仅用于未知数个数与方程个数相同的情况。</p><p><strong>推论：</strong>若<strong>齐次</strong>线性方程组的系数行列式D≠0，则方程组只有零解</p><p><strong>notes：</strong></p><p>（1）齐次方程组一定有解</p><p>（2）若齐次线性方程组有非零解，则D=0</p><h3 id="第五节-矩阵分块法"><a href="#第五节-矩阵分块法" class="headerlink" title="第五节 矩阵分块法"></a>第五节 矩阵分块法</h3><p><span style="color:red;font-size:20px">定义：</span>将矩阵A用若干条纵线和若干条横线分成许多个小矩阵，每一个小矩阵称为A的子块，以子块为元素的形式上的矩阵称为分块矩阵</p><p><strong>分块矩阵的运算：</strong></p><p>（1）设矩阵A与B的行数相同，列数相同，采用同样的分块法，那么<strong>加减法</strong>与矩阵加减法类似</p><p>（2）数乘=遍乘</p><p>（3）<script type="math/tex">A=\left(\begin{array}{ccc}A_{11} & \cdots & A_{1 t} \\\vdots & & \vdots \\A_{s 1} & \cdots & A_{s t}\end{array}\right), \quad B=\left(\begin{array}{ccc}B_{11} & \cdots & B_{1 r} \\\vdots & & \vdots \\B_{t 1} & \cdots & B_{t r}\end{array}\right)\\其中 A_{i 1}, A_{i 2}, \cdots A_{i t} 的列数分别等于 B_{1 j}, B_{2 j}, \cdots B_{t j} 的行数。\\A B=\left(\begin{array}{ccc}C_{11} & \cdots & C_{1 r} \\\vdots & & \vdots \\C_{s 1} & \cdots & C_{s r}\end{array}\right)\\其中 \displaystyle C_{i j}=\sum_{k=1}^{t} A_{i k} B_{k j} \quad(i=1, \cdots s ; j=1, \cdots, r)</script></p><p>（4）转置：行列交换，同时每个小子块发生转置（公转且自转）</p><p><strong>notes：</strong></p><p>1.乘法要保证有意义</p><p>2.按普通矩阵一样乘</p><p><strong>分块对角矩阵：</strong>设<script type="math/tex">A=\begin{pmatrix}B&0\\0&C\end{pmatrix}</script>，其中B，C均为方阵，则</p><p>（1）<script type="math/tex">|A|=|B||C|</script></p><p>（2）<script type="math/tex">A^n=\begin{pmatrix}B^n&0\\0&C^n\end{pmatrix}</script></p><p>（3）A可逆的充分必要条件为B，C均可逆，且<script type="math/tex">A^{-1}=\begin{pmatrix}B^{-1}&0\\0&C^{-1}\end{pmatrix}(注意:\begin{pmatrix}0&B\\C&0\end{pmatrix}^{-1}=\begin{pmatrix}0&C^{-1}\\B^{-1}&0\end{pmatrix})</script></p><p>（4）<script type="math/tex">A^*=|A|A^{-1}=|B||C|\begin{pmatrix}B^{-1}&0\\0&C^{-1}\end{pmatrix}=\begin{pmatrix}|C|B^*&0\\0&|B|C^*\end{pmatrix}</script></p><center><span style="color:blue;font-size:15px">2021/7/2</span></center><h2 id="第三章-矩阵的初等变换和线性方程组"><a href="#第三章-矩阵的初等变换和线性方程组" class="headerlink" title="第三章 矩阵的初等变换和线性方程组"></a>第三章 矩阵的初等变换和线性方程组</h2><h3 id="第一节-矩阵的初等变换"><a href="#第一节-矩阵的初等变换" class="headerlink" title="第一节 矩阵的初等变换"></a>第一节 矩阵的初等变换</h3><p>消元法解线性方程组的三种同解变换：</p><p>（1）一个方程加到另一个方程</p><p>（2）非零数乘某个方程</p><p>（3）互换两个方程的位置</p><p>在上述变换过程中，实际上只对方程组的系数和常数进行运算，未知数并未参与运算，因此，对方程组的变换可以完全转换为对它的<strong>增广矩阵</strong>的变换</p><p><span style="color:red;font-size:20px">定义：（初等行变换）</span></p><p>（1）对调两行（$r_i\leftrightarrow r_j$）</p><p>（2）以数k≠0乘某一行中所有元素（$r_i\times k$）</p><p>（3）某行所有元素k倍加到另一行对应元素上去（$r_i+kr_j$）</p><p>把行换成列，即得到矩阵的<strong>初等列变换</strong>的定义；矩阵的初等行变换和初等列变换，统称为<strong>初等变换</strong></p><p><strong>note：</strong>解方程组不可以用列变换</p><p><strong>矩阵的等价关系：</strong>如果矩阵A结果有限次（初等行变换\初等列变换\初等变换）变成矩阵B，就称矩阵A与B（行等价\列等价\等价），记作（$ A\overset{r}\sim B\setminus A\overset{c}\sim B\setminus A\sim B$）</p><p><strong>行阶梯形矩阵：</strong>(经过<strong>初等行变换</strong>)<br>（1）可以画一条阶梯线，线的下方全为零;<br>（2）每个台阶只占一行，阶梯竖线右边第一个元素非零。<br><strong>行最简形矩阵：</strong>在行阶梯形中，经过<strong>初等行变换</strong>化为<br>（3） 每个非零行的首非零元素全为1,<br>（4）每个非零行的首非零元素所在列的其他元素为0。<br><strong>标准形：</strong><br>在行最简形矩阵中，再经过有限次<strong>初等列变换</strong>可变成<script type="math/tex">F=\begin{pmatrix}E_r&O\\O&O\end{pmatrix}</script></p><p><span style="color:red;font-size:20px">定义：（初等矩阵）</span>由单位矩阵E经过一次初等变换得到的矩阵称为<strong>初等矩阵</strong>。</p><p>三种初等变换对应有三种初等矩阵</p><p>（1）对换阵（$E\overset{r_i\leftrightarrow r_j}\longrightarrow E(i,j)$）</p><p>（2）数乘阵（$E\overset{r_i\times k}\longrightarrow E(i(k))$）</p><p>（3）倍加阵（$E\overset{r_i+k r_j}\longrightarrow E(ij(k))$）</p><p><strong>性质（行左列右）：</strong>对$A_{m\times n}$施行一次初等行(列)变换就相当于在 A的左(右)乘以一个相应的m(n)阶初等矩阵。</p><p><strong>定理：</strong>初等矩阵均可逆，且其逆仍然是同类型的初等矩阵，</p><p>且<script type="math/tex">(E(ij))^{-1}=E(ij)\quad[E(ij)E(ij)=E]\\(E(i(k)))^{-1}=E(i(\frac 1 k))\quad[E(i(\frac 1 k))E(i(k))=E]\\(E(ij(k)))^{-1=}E(ij(-k))\quad [E(ij(-k))E(ij(k))=E]</script></p><p><strong>推论1：</strong>方阵A可逆的充分必要条件是A通过初等行变换得到E</p><p><strong>推论2：</strong>A可逆的充分必要条件是存在有限个初等矩阵$P_1,P_2,\cdots,P_l$使得$A= P_1P_2\cdots P_l$</p><p><strong>推论3：</strong> <script type="math/tex">A_{m\times n}通过有限次初等变换得到B_{m\times n}的充分必要条件是存在可逆阵P_{m\times n},Q_{m\times n,}使得PAQ=B</script></p><p><strong>利用初等行变换求逆矩阵的方法：</strong>$(A|E)\overset{初等行变换}\longrightarrow (E|A^{-1})$(从上往下化成上三角，再重下往上化成对角，再每一行乘上倒数)</p><p><strong>利用初等行变换解矩阵方程AX=B的步骤：</strong>$(A|B)\overset{初等行变换}\longrightarrow (E|A^{-1}B)=(E|X)$</p><h3 id="第二节-矩阵的秩"><a href="#第二节-矩阵的秩" class="headerlink" title="第二节 矩阵的秩"></a>第二节 矩阵的秩</h3><p><span style="color:red;font-size:20px">定义：（子式）</span><script type="math/tex">在A_{m\times n}中，任取k行与k列(k≤m,k≤n),位于这些行列交叉处的k^2个元素，\\不改变它们在A中所处的位置次序而得的k阶行列式称为矩阵A的一个k阶子式。(k阶子式共有C^k_m\times C^k_n个)</script></p><p><strong>notes：</strong></p><p>（1）$A_{m\times n}$的每一个元素都是其的一阶子式，共m×n个</p><p>（2）若A为n阶方阵，|A|为A的唯一的n阶子式， |A|中每个元素的余子式为A的n-1阶子式， 共$n^2$个。</p><p>（3）若矩阵A中所有k阶子式都为零，则高于k阶的子式（若有）都为零。</p><p><span style="color:red;font-size:20px">定义：（矩阵的秩）</span>若矩阵A中有一个不等于0的r阶子式D，且所有r+1阶子式全等于0，则称D为A的最高阶非零子式，r称为A的秩，记作R(A)或者r(A)。规定零矩阵的秩为零。<strong>R(A)即为A的最高阶非零子式的阶数</strong>。（rank)</p><p><strong>notes：</strong></p><p>（1）R(A)≥r⇔A中至少有一个r阶子式不为零；R(A)&lt;r+1⇔A中所有r+1阶子式等于零</p><p>（2）对于n阶方阵A，|A|≠0⇔R(A)=n,称A是满秩的；|A|=0⇔R(A)&lt;n,称A是降秩的。</p><p>（3）行阶梯型矩阵的秩等于非零行的行数</p><p><strong>定理1：</strong>若A~B，则R(A)= R(B)</p><p><strong>求矩阵秩R(A)的方法：</strong>利用初等(行)变换将矩阵A化为阶梯形；此阶梯形矩阵中非零行的行数即为矩阵的秩R(A)</p><p><strong>秩的性质与结论（部分）：</strong></p><p><strong>（1）</strong>$0≤R(A_{m\times n})≤\min\{m,n\}$</p><p>（2）$R(A^T)=R(A)=R(AA^T)=R(A^TA))$</p><p>（3）若A~B，则R(A)=R(B)；反之，若A，B同型，且R(A)=R(B)，则A，B等价</p><p>（4）若P，Q可逆，则R(PAQ)=R(A)</p><p><strong>（5）</strong>R(A|B)≥R(A)；R(A|B)≥R(B)</p><p><strong>（6）R(A+B)≤</strong>R(A+B|B)= R(A|B)≤<strong>R(A)+R(B)</strong></p><p><strong>（7）</strong>R(AB)≤R(A)；R(AB)≤R(B)；若B可逆，则R(AB)=R(A)</p><p><strong>（8）</strong><script type="math/tex">若A_{m\times n}B_{n\times s}=0,则R(A)+R(B)≤n</script></p><p><strong>例：</strong>设A为n阶方阵，证明：<script type="math/tex">R(A^*)=\begin{cases}n,若R(A)=n\\1,若R(A)=n-1\\0,若R(A)<n-1\end{cases}</script></p><p>证：<script type="math/tex">AA^*=A^*A=|A|E,|A^*|=|A|^{n-1},A^*中的元素是A的代数余子式(n-1阶子式)\\当R(A)=n时,|A|\neq 0,|A^*|\neq 0,R(A^*)=n\\当R(A)<n-1时,A的余子式均为0,A^*为零矩阵\\当R(A)=n-1时,AA^*=|A|E=0\Rightarrow R(A)+R(A^*)\leq n \Rightarrow R(A^*)\leq 1\\又因为A至少有一个n-1阶子式不为0,所以A^*不是零矩阵,所以R(A^*)\geq 1</script></p><p>一个n阶矩阵的秩可能是0到n，不过一个n阶矩阵的伴随的秩只可能是n，1，0</p><center><span style="color:blue;font-size:15px">2021/7/3</span></center><h3 id="第三节-线性方程组的解"><a href="#第三节-线性方程组的解" class="headerlink" title="第三节 线性方程组的解"></a>第三节 线性方程组的解</h3><h4 id="一、非齐次线性方程组"><a href="#一、非齐次线性方程组" class="headerlink" title="一、非齐次线性方程组"></a>一、非齐次线性方程组</h4><p><strong>定理：</strong>对于线性方程组$A_{m\times n}x=b$</p><p>（1）无解⇔R(A)&lt;R(A,b)；（R(A,b)=R(A)+1）</p><p>（2）有唯一解⇔R(A)=(A,b)=n；</p><p>（3）有无穷多解⇔R(A)=R(A,b)&lt;n；</p><p><strong>推论：</strong>线性方程组$A_{m\times n}x=b$有解⇔R(A)=R(A,b)</p><p>当线性方程组<script type="math/tex">A_{m\times n}x=b</script>有<strong>无穷多解</strong>时，其所有解的共同表达式称为线性方程组$A_{m\times n}x=b$的<strong>通解</strong>或<strong>一般解</strong></p><p>特别的，对于方阵$A_n,A_nx=b$有唯一解⇔$|A_n|≠0$（参见克拉默法则）；若|A|=0，可能无解或无穷多解</p><p><strong>求解Ax=b的方法：</strong></p><p>（1）写出增广矩阵(A,b)<br>（2）利用<strong>初等行变换</strong>将其化为<strong>行阶梯形</strong>，判断R(A)=R(A,b)，从而确定线性方程组是否有解<br>（3）如果线性方程组有解，就继续将(A,b)化为<strong>行最简形</strong><br>（4）从行最简形写回线性方程组，并将每个首非零元素对应的变量放在等号的左边，其余变量（称为<strong>自由末知量</strong>）移到等号的右边<br>（5）添加方程$x_i= x_i$，其中xi为每个自由未知量<br>（6）将自由未知量xi换成c1，c2等，写出线性方程组的解或通解</p><h4 id="二、齐次线性方程组"><a href="#二、齐次线性方程组" class="headerlink" title="二、齐次线性方程组"></a>二、齐次线性方程组</h4><p>（1）只有零解（有唯一解）⇔R(A)=n；</p><p>（2）有非零解（有无穷多解）⇔R(A)&lt;n；</p><p><strong>推论1：（方阵情况）</strong>（只有方阵才能谈行列式）</p><p>（1）$A_nx=0$只有零解⇔|A|≠0</p><p>（2）$A_nx=0$有非零解⇔|A|=0</p><p><strong>推论2：</strong>方程的个数小于未知数个数，则一定有非零解。</p><center><span style="color:blue;font-size:15px">2021/7/4</span></center><h2 id="第四章-向量组的线性相关性"><a href="#第四章-向量组的线性相关性" class="headerlink" title="第四章 向量组的线性相关性"></a>第四章 向量组的线性相关性</h2><h3 id="第一节-向量组及其线性组合"><a href="#第一节-向量组及其线性组合" class="headerlink" title="第一节 向量组及其线性组合"></a>第一节 向量组及其线性组合</h3><h4 id="一、向量"><a href="#一、向量" class="headerlink" title="一、向量"></a>一、向量</h4><ol><li><p><span style="color:red;font-size:20px">定义1</span>称$\begin{pmatrix}a_1\\a_2\\\vdots\\a_n\end{pmatrix}$为n维列向量，其中ai称为第i个分量。$(b_1,b_2,\cdots,b_n)$为n维行向量</p><p><strong>note：</strong>列向量用$\alpha,\beta,\gamma,\cdots$表示，行向量用$\alpha^T,\beta^T,\gamma^T,\cdots$表示；</p></li><li><p>向量的线性运算（加减法、数乘）</p></li><li><p><strong>向量组：</strong>若干个<strong>同维数</strong>的行（列）向量所组成的集合；</p></li><li><p>向量组和矩阵的关系（含有有限个向量的有序向量组可以与矩阵一一对应）（第二章已经介绍）</p></li><li><p>方程组的向量表示（第二章已经介绍）</p><script type="math/tex; mode=display">\begin{pmatrix}a_{11}&a_{12}&\cdots&a_{1n}\\a_{21}&a_{22}&\cdots&a_{2n}\\\vdots&\vdots&\ddots&\vdots\\a_{m1}&a_{m2}&\cdots&a_{mn}\end{pmatrix}\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix}=\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\end{pmatrix}\Leftrightarrow(\alpha_1,\alpha_1,\cdots,\alpha_n)\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix}=\beta\Leftrightarrow x_1\alpha_1+x_2\alpha_2+\cdots+x_n\alpha_n=\beta</script></li></ol><h4 id="二、向量组的线性表示（以列向量为对象）（与非齐有关-Ax-B"><a href="#二、向量组的线性表示（以列向量为对象）（与非齐有关-Ax-B" class="headerlink" title="二、向量组的线性表示（以列向量为对象）（与非齐有关 Ax=B)"></a>二、向量组的线性表示（以列向量为对象）（与非齐有关 Ax=B)</h4><ol><li><p><span style="color:red;font-size:20px">定义2：</span>设向量组A：$α_1,α_2,\cdots,α_m$以及任意一组实数$k_1,k_2,\cdots,k_m$，称$k_1α_1+k_2α_1+\cdots+k_mα_m$为向量组A的一个线性组合</p><p><strong>note：</strong>零向量可写成任意同维数向量的线性组合</p></li><li><p><span style="color:red;font-size:20px">定义3：</span>给定向量组A，如果存在一组数k使得$\beta=k_1α_1+k_2α_1+\cdots+k_mα_m$，则称向量b能由向量组A线性表示</p><p><strong>定理1：</strong><script type="math/tex">向量β能由向量组A线性表示\\⇔线性方程组x_1α_1+x_2α_1+\cdots+x_mα_m=\beta，即Ax=\beta有解\\⇔R(α_1,α_2,\cdots,α_m)=R(α_1,α_2,\cdots,α_m,\beta)，即R(A)=R(A,B)</script></p></li></ol><h4 id="三、向量组的等价"><a href="#三、向量组的等价" class="headerlink" title="三、向量组的等价"></a>三、向量组的等价</h4><p><span style="color:red;font-size:20px">定义4：</span>若向量组B中的每个向量都能由A中的向量线性表示，则称<strong>向量组B能由向量组A线性表示</strong>；若向量组A和向量组B能相互线性表示，则称这两个向量组<strong>等价</strong></p><p><strong>note：</strong>矩阵等价与向量组等价有区别：向量组等价不能确定向量组构成的矩阵等价；矩阵等价不能确定其行(列)向量组等价</p><p><img src="/images/linear-algebra/image-20210704205828955.png" alt=""></p><p><img src="/images/linear-algebra/image-20210704210041624.png" alt=""></p><p><strong>note2：</strong>由上可知若AB=C，则</p><p>（1）C的列向量可由A的列向量线性表示（A<span style="color:blue">B</span>=C)（表示的系数为B的列元素）</p><p>（1）C的行向量可由B的行向量线性表示（<span style="color:blue">A</span>B=C)（表示的系数为A的行元素）</p><p><strong>note3：</strong>矩阵A经初等行变换变成矩阵B，则A的行向量组与B的行向量组等价。但是列向量组未必等价。同理，矩阵A经初等列变换变成矩阵B，则A的列向量组与B的列向量组等价。但是行向量组未必等价。</p><p><strong>推论：</strong>列向量组A与列向量组B等价$\Leftrightarrow R(A)=R(B)=R(A,B)$（三秩相等即等价）</p><p><strong>定理1：</strong>向量组B能由向量组A线性表示，则R(B)=R(AK)≤R(A)</p><center><span style="color:blue;font-size:15px">2021/7/5</span></center><h3 id="第二节-向量组的线性相关性（与齐次有关-Ax-0）"><a href="#第二节-向量组的线性相关性（与齐次有关-Ax-0）" class="headerlink" title="第二节 向量组的线性相关性（与齐次有关 Ax=0）"></a>第二节 向量组的线性相关性（与齐次有关 Ax=0）</h3><h4 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h4><p><span style="color:red;font-size:20px">定义：</span>给定向量组A:$a_1,a_2,\cdots,a_m$，如果存在<strong>不全为零</strong>的数$k_1,k_2,\cdots,k_m$，使得$k_1α_1+k_2α_1+\cdots+k_mα_m=0$，则称向量组A<strong>线性相关</strong>，否则称它<strong>线性无关</strong>（齐次线性方程组只有零解）。</p><p><strong>note：</strong>线性相关的充分条件（1）有零向量（2）有两个向量成比例（3）有一个可以由其余向量表示（充要）</p><p><strong>note1：</strong>线性相关无关的<strong>直观意义</strong></p><p>（1）α线性相关⇔α=0；α线性无关⇔α≠0；</p><p>（2）$α_1,a_2$线性相关⇔$α_1,a_2$成比例（或平行）；$α_1,a_2$线性无关⇔$α_1,a_2$不成比例（或不平行）</p><p>（3）$α_1,a_2,a_3$线性相关⇔$α_1,a_2,a_3$共面；$α_1,a_2,a_3$线性无关⇔$α_1,a_2,a_3$不共面；</p><h4 id="二、相关定理（相关结论）"><a href="#二、相关定理（相关结论）" class="headerlink" title="二、相关定理（相关结论）"></a>二、相关定理（相关结论）</h4><p>（1）向量组A线性相关⇔A中至少有一个向量可由其余向量线性表示</p><p>（2）向量组中含有零向量，则该向量组线性相关</p><p><strong>定理1：</strong></p><p>（1）向量组A线性相关⇔线性方程组Ax=0有非零解⇔A的秩小于m（向量的个数）</p><p>（2）向量组A线性无关⇔线性方程组Ax=0只有零解⇔A的秩等于m</p><p><strong>note：</strong>判断相关无关，只要将向量组构成矩阵A，比较R(A)与向量个数之间的关系</p><p><strong>note1：</strong><script type="math/tex">设n维向量组α_1,a_2,\cdots,α_s线性无关，且(β_1,β_2,\cdots,β_s)=(α_1,a_2,\cdots,α_s)k_{s\times s},\\则(β_1,β_2,\cdots,β_s)线性无关⇔k_{s\times s}≠0(可逆\Rightarrow A与B的秩相等)</script></p><p><strong>定理2：</strong></p><p>（1）<script type="math/tex">若α_1,a_2,\cdots,α_m线性相关，则α_1,a_2,\cdots,α_m,α_{m+1}必线性相关;\\反之，若α_1,α_2,α_m,α_{m+1}线性无关，则α_1,a_2,\cdots,α_m线性无关;</script></p><p>（2）<script type="math/tex">若α_1,a_2,\cdots,α_m线性无关，而α_1,a_2,\cdots,α_m,β线性相关，\\则β能由α_1,a_2,\cdots,α_m线性表示，且表达式唯一</script></p><p>（3）m个n维向量组成的向量组，当向量个数m大于维数n时，该向量组一定线性相关。<br>特别地，n+1个n维向量一定线性相关。</p><p><strong>定理3：</strong>线性无关的向量组中每个向量分别添加分量后的新向量组一定线性无关。</p><p><strong>定理4：</strong>对矩阵进行初等<strong>行</strong>变换不改变其<strong>列向量组</strong>的线性相关性；<br>对矩阵进行初等<strong>列</strong>变换不改变其<strong>行向量组</strong>的线性相关性。</p><center><span style="color:blue;font-size:15px">2021/7/7</span></center><h3 id="第三节-向量组的秩"><a href="#第三节-向量组的秩" class="headerlink" title="第三节 向量组的秩"></a>第三节 向量组的秩</h3><h4 id="一、定义和性质"><a href="#一、定义和性质" class="headerlink" title="一、定义和性质"></a>一、定义和性质</h4><p><span style="color:red;font-size:20px">定义：</span>设有向量组A，若在A中能选出r个向量满足</p><p>（1）这r个向量组成的向量组线性无关</p><p>（2）向量组A中任意r+1个向量（如果有的话）都线性相关。</p><p>或（2’）A中任意一个向量都可以由这r个向量线性表示</p><p>满足(1)(2)的r个向量是向量组A的一个最大(线性)无关组，数r称为<strong>向量组A的秩</strong>，记为$r=R_A$</p><p><strong>note1：</strong>向量组A的最大无关组可能不唯一；如果$R_A=r$，则向量组A中的任意r个线性无关的向量所组成的向量组都是A的最大无关组。</p><p><strong>note2：</strong>如果向量组A线性无关，则A的唯一最大无关组就是它本身。</p><p><strong>性质：</strong></p><p>（1）向量组与最大无关组等价</p><p>（2）同一向量组的任意两个最大无关组等价</p><p>（3）两个等价向量组的最大无关组等价</p><h4 id="二、相关定理"><a href="#二、相关定理" class="headerlink" title="二、相关定理"></a>二、相关定理</h4><p><strong>定理：</strong>矩阵的秩等于矩阵的列向量组的秩，也等于矩阵行向量组的秩</p><p><strong>求列向量组A的最大无关组和秩r的方法：</strong></p><p>（1）先将列向量组A构成矩阵</p><p>（2）对矩阵作初等行变换化为行阶梯型，则在行阶梯型中：非零行的行数即为向量组A的秩；每个非零行的首非零元素所在的列向量的全体即为列向量组的一个最大无关组。</p><p>（3）继续将矩阵A作初等行变换化成行最简形，则利用行最简形，可将其余向量由最大无关组线性表示。</p><p>原理：对矩阵就行初等行变换不改变其列向量组的线性无关性</p><center><span style="color:blue;font-size:15px">2021/7/8</span></center><h3 id="第四节-线性方程组的的解的结构"><a href="#第四节-线性方程组的的解的结构" class="headerlink" title="第四节 线性方程组的的解的结构"></a>第四节 线性方程组的的解的结构</h3><h4 id="一、齐次线性方程组的解的结构"><a href="#一、齐次线性方程组的解的结构" class="headerlink" title="一、齐次线性方程组的解的结构"></a>一、齐次线性方程组的解的结构</h4><ol><li><p>齐次线性方程组解向量的性质</p><p><strong>性质1：</strong>齐次的解相加还是齐次的解</p><p><strong>性质2：</strong>齐次的解乘常数还是齐次的解</p><p><span style="color:red;font-size:20px">定义：</span>齐次线性方程组的所有解构成的向量组的最大无关组称为该齐次线性方程组的基础解系</p></li></ol><p><img src="/images/linear-algebra/image-20210708145621760.png" alt=""></p><ol><li><p>齐次线性方程组的基础解系的性质</p><p><strong>定理：</strong><script type="math/tex">设R(A_{m\times n})=r，则n元齐次线性方程组A_{m\times n}x=0</script>的基础解系中有n-r个解向量，即s=n-r</p><p>R(A)：有效方程个数；n：未知量个数；n-R(A)：自由未知量个数</p><p><strong>推论：</strong><script type="math/tex">A_{m\times n}x=0的任意n-r(A)个线性无关的解即为A_{m\times n}x=0的基础解系</script></p><p><strong>结论：</strong>若<script type="math/tex">\xi_1,\xi_2,\cdots,\xi_{n-r}为A_{m \times n} x=0</script>的一个基础解系</p><p>则 <script type="math/tex">A_{m \times n} x=0 的通解为\quad x=c_{1} \xi_{1}+c_{2} \xi_{2}+\cdots+c_{n-r} \xi_{n-r}</script></p></li></ol><h4 id="二、非齐次线性方程组解的结构"><a href="#二、非齐次线性方程组解的结构" class="headerlink" title="二、非齐次线性方程组解的结构"></a>二、非齐次线性方程组解的结构</h4><p><strong>性质：</strong></p><p>（1）两个非齐的解相减是齐次的解</p><p>（2）齐次的解加非齐的解是非齐的解</p><p><strong>note：</strong>当<script type="math/tex">R(A)=r<n时, 求 A x=b的通解只要求A x=b的一个特解\eta^{*}和 A x=0 的通解\\ x=c_{1} \xi_{1}+\cdots+c_{n-r} \xi_{n-r}，则 A x=b 的通解为 x=\eta^{*}+c_{1} \xi_{1}+\cdots+c_{n-r} \xi_{n-r}</script></p><h3 id="第五节-向量空间"><a href="#第五节-向量空间" class="headerlink" title="第五节 向量空间"></a>第五节 向量空间</h3><h4 id="一、向量空间的定义"><a href="#一、向量空间的定义" class="headerlink" title="一、向量空间的定义"></a>一、向量空间的定义</h4><p><span style="color:red;font-size:20px">定义：</span>设V为n维向量的集合，如果集合V非空，且集合V对于向量的加法和数乘两种运算<strong>封闭</strong>，那么称集合V为<strong>向量空间</strong></p><p><strong>note：</strong>向量空间必含零向量</p><p>n元齐次线性方程组的解集是一个向量空间（称为齐次线性方程组的<strong>解空间</strong>）</p><h4 id="二、生成空间"><a href="#二、生成空间" class="headerlink" title="二、生成空间"></a>二、生成空间</h4><p>设 <script type="math/tex">\alpha_{1}, \cdots, \alpha_{m}</script> 为一n维向量组，则</p><script type="math/tex; mode=display">V=\left\{\lambda_{1} \alpha_{1}+\cdots+\lambda_{m} \alpha_{m} \mid \lambda_{1}, \cdots, \lambda_{m} \in R\right\}</script><p>是一向量空间, 称V是由 <script type="math/tex">\alpha_{1}, \cdots, \alpha_{m} 所生成的向量空间。 记为 V=L\{\alpha_{1}, \cdots, \alpha_{m}\}</script>.</p><p><strong>note：</strong></p><p>（1）<script type="math/tex">\alpha,\cdots,\alpha_m与=L\{\alpha_{1}, \cdots, \alpha_{m}\}</script>等价</p><p>（2）等价的向量组所生成的向量空间是相等的</p><h4 id="三、向量空间的基，维数与坐标"><a href="#三、向量空间的基，维数与坐标" class="headerlink" title="三、向量空间的基，维数与坐标"></a>三、向量空间的基，维数与坐标</h4><ol><li><h5 id="基、维数"><a href="#基、维数" class="headerlink" title="基、维数"></a>基、维数</h5><p><span style="color:red;font-size:20px">定义：</span>设V为向量空间，$\alpha,\cdots,\alpha_r∈V$且满足:<br>（1）$\alpha,\cdots,\alpha_r$线性无关;<br>（2）任意α∈V都可由$\alpha,\cdots,\alpha_r$线性表示.<br>则称$\alpha,\cdots,\alpha_r$是V的基，r为V的维数。记为dimV =r。<br>规定零空间的维数为0，没有基</p><p><strong>note：</strong></p><p>（1）若向量空间V看成向量组，则V的基就是V的最大无关组，向量空间的维数r就是V的秩。<br>进而V中任何r个线性无关的向量都是V的基。</p><p>（2）<script type="math/tex">若 \alpha_{1}, \cdots, \alpha_{r} 是向量空间 V的基, 则V =L\left\{\alpha_{1}, \cdots, \alpha_{r}\right\};\\若V =L\left\{\alpha_{1}, \cdots, {\alpha}_{m}\right\}，则 \alpha_{1}, \cdots, \alpha_{m} 的最大无关组为 V 的基。</script></p></li><li><h5 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h5><p><span style="color:red;font-size:20px">定义：</span><script type="math/tex">设 \alpha_{1}, \cdots, \alpha_{r} 是向量空间V的一组基，那么对\forall \beta \in V 都可唯一表示为\\\beta=x_{1} \alpha_{1}+\cdots+x_{r} \alpha_{r}，称有序数组 \left(x_{1}, \cdots, x_{r}\right) 是向量 \beta 在基 \alpha_{1}, \cdots, \alpha_{r} 的坐标。</script></p><p><strong>note：</strong>基给定后，求一个向量的坐标就是求非齐次线性方程组的解。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同济高数第七版（11-12章）</title>
      <link href="2021/05/27/tongji-calculus-11-12/"/>
      <url>2021/05/27/tongji-calculus-11-12/</url>
      
        <content type="html"><![CDATA[<center><span style="color:blue;font-size:15px">2021/5/27</span></center><h2 id="第十一章-曲线积分与曲面积分"><a href="#第十一章-曲线积分与曲面积分" class="headerlink" title="第十一章 曲线积分与曲面积分"></a>第十一章 曲线积分与曲面积分</h2><p>上一章已经把积分概念从积分范围为数轴上一个区间的情形推广到积分范围为平面或空间内的一个闭区域的情形，本章将把积分概念推广到积分范围为一段曲线弧或一片曲面的情形。</p><h3 id="第一节-对弧长的曲线积分（第一类曲线积分）"><a href="#第一节-对弧长的曲线积分（第一类曲线积分）" class="headerlink" title="第一节 对弧长的曲线积分（第一类曲线积分）"></a>第一节 对弧长的曲线积分（第一类曲线积分）</h3><h4 id="一、对弧长的曲线积分的概念与性质"><a href="#一、对弧长的曲线积分的概念与性质" class="headerlink" title="一、对弧长的曲线积分的概念与性质"></a>一、对弧长的曲线积分的概念与性质</h4><p>背景：曲线形构件的质量</p><p><span style="color:red;font-size:20px">定义</span> <script type="math/tex">设L为xOy面内的一条光滑曲线弧,函数f(x,y)在L上有界.\\在L上任意插入一点列M_1,M_2,...M_{n-1}把L分成n个小段.设第i个小段的长度为\triangle s_i,\\又(\xi_i,\eta_i)为第i个小段上任意取定的一点,作乘积f(\xi_i,\eta_i)\triangle s_i，(i=1,2,...,n),\\并作和\sum^n_{i=1}f(\xi_i,\eta_i)\triangle s_i,如果当各小弧段的长度的最大值λ→0时,这和的极限总存在,\\且与曲线弧L的分法及点(\xi_i,\eta_i)的取法无关,\\那么称此极限为函数f(x,y)在曲线弧L上对弧长的曲线积分或第一类曲线积分,记作\int _Lf(x,y)ds,即\\\displaystyle\int_Lf(x,y)ds=\lim_{\lambda\to0}\sum^n_{i=1}f(\xi_i,\eta_i)\triangle s_i</script></p><p><strong>性质1-性质5：</strong>和二重积分类似</p><h4 id="二、对弧长的曲线积分的计算法"><a href="#二、对弧长的曲线积分的计算法" class="headerlink" title="二、对弧长的曲线积分的计算法"></a>二、对弧长的曲线积分的计算法</h4><p><strong>1.直角坐标形式</strong></p><p>$L:y=\varphi(x)\qquad(a\leq x\leq b)$</p><p>$\displaystyle ds=\sqrt{(dx)^2+(dy)^2}=\sqrt{1+(\frac{dy}{dx})^2}dx=\sqrt{1+f’^2(x)}dx$</p><p>$\displaystyle\int_Lf(x,y)ds=\int^b_af(x,\varphi(x))\sqrt{1+f’^2(x)}dx$</p><p>同理也可化作对y的定积分</p><p><strong>用极坐标的时候先转换为参数方程形式</strong></p><p><strong>2.参数方程形式</strong></p><p>$L:\begin{cases}x=\varphi(t)\\y=\psi(t)\end{cases}\qquad(\alpha\leq x\leq \beta)$</p><p>$\displaystyle ds=\sqrt{(dx)^2+(dy)^2}=\sqrt{(\frac{dx}{dt})^2+(\frac{dy}{dt})^2}dt=\sqrt{\varphi’^2(t)+\psi’^2(t)}dt$</p><p>:<script type="math/tex">\displaystyle\int_Lf(x,y)ds=\int^\beta_\alpha f(\varphi(t),\psi(t))\sqrt{\varphi'^2(t)+\psi'^2(t)}dt</script></p><center><span style="color:blue;font-size:15px">2021/5/31</span></center><h3 id="第二节-对坐标的曲线积分（第二类曲线积分）"><a href="#第二节-对坐标的曲线积分（第二类曲线积分）" class="headerlink" title="第二节 对坐标的曲线积分（第二类曲线积分）"></a>第二节 对坐标的曲线积分（第二类曲线积分）</h3><h4 id="一、对坐标的曲线积分的概念与性质"><a href="#一、对坐标的曲线积分的概念与性质" class="headerlink" title="一、对坐标的曲线积分的概念与性质"></a>一、对坐标的曲线积分的概念与性质</h4><p><strong>引例：</strong>变力沿曲线做功</p><blockquote><p>1.$\forall\vec{ds}\in L,\vec{ds}=\{dx,dy,dz\},\vec F=\{P(x,y,z),Q,R\}$</p><p>2.$dW=\vec F·\vec{ds}=Pdx+Qdy+Rdz$</p><p>3.$W=\int_LdW=\int_LPdx+Qdy+Rdz$</p></blockquote><p><span style="color:red;font-size:20px">定义:</span> 设L是xoy面内从点A到点B的一条<strong>有向</strong>光滑曲线弧</p><p>即<script type="math/tex">\displaystyle\int_LP(x,y)dx+Q(x,y)dy=\lim_{\lambda\to 0}\sum^n_{i=1}[P(\xi_i,\eta_i)\triangle x_i+Q(\xi_i.\eta_i)\triangle y_i]=\int_L\vec F·\vec{ds}</script></p><p><img src="/images/tongji-calculus-11-12/image-20210531162122654.png" alt=""></p><h4 id="二、对坐标的曲线积分的计算法"><a href="#二、对坐标的曲线积分的计算法" class="headerlink" title="二、对坐标的曲线积分的计算法"></a>二、对坐标的曲线积分的计算法</h4><p><strong>1.直角坐标形式</strong></p><p>$L:y=\varphi(x)\qquad(起点:x=a,终点:x=b)$</p><p>$\displaystyle\int_LP(x,y)dx+Q(x,y)dy$</p><p>$\displaystyle =\int_a^bP(x,\varphi(x))dx+Q(x,\varphi(x))\varphi’(x)dx$</p><p>同理也可化作对y的定积分</p><p><strong>2.参数方程形式</strong>(三维时方法相同)</p><p>$L:\begin{cases}x=\varphi(t)\\y=\psi(t)\end{cases}\qquad(起点:t=\alpha,终点:t=\beta)$</p><p>$\displaystyle\int_LP(x,y)dx+Q(x,y)dy$</p><p>$\displaystyle =\int_\alpha^\beta P(\varphi(t),\psi(t))\varphi’(t)dt+Q(\varphi(t),\psi(t))\psi’(t)dt$</p><h4 id="三、两类曲线积分的关系"><a href="#三、两类曲线积分的关系" class="headerlink" title="三、两类曲线积分的关系"></a>三、两类曲线积分的关系</h4><p>$\displaystyle\int_LP(x,y)dx+Q(x,y)dy=\int_L\vec F·\vec{ds}$</p><p>$\displaystyle\int_LPdx+Qdy=\int_L(P\cos\alpha+Q\cos\beta)ds$</p><h3 id="第三节-格林公式及其应用"><a href="#第三节-格林公式及其应用" class="headerlink" title="第三节 格林公式及其应用"></a>第三节 格林公式及其应用</h3><h4 id="一、格林公式（二重积分和线积分的转换）"><a href="#一、格林公式（二重积分和线积分的转换）" class="headerlink" title="一、格林公式（二重积分和线积分的转换）"></a>一、格林公式（二重积分和线积分的转换）</h4><p><span style="color:blue;font-size:20px">定理1：</span>设闭区域D由分段光滑的曲线L围成，若函数P(x,y)及Q(x,y)在D上具有一阶连续偏导数，则</p><p>$\displaystyle\iint\limits_D\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right)dxdy=\oint_LPdx+Qdy$，其中L是D的取正向的边界曲线</p><blockquote><p>单连通区域逆时针方向为正方向</p><p>多连通区域的正方向是外边界为逆时针，内边界为顺时针</p><p>（区域在始终在边界方向的左侧）</p></blockquote><p>使用格林的三种情况：直接用，补线（曲线不封闭），挖洞（当有点不可偏导时）</p><blockquote><p>L围成的闭区域的面积A=$\displaystyle\frac{1}{2}\oint_Lxdy-ydx$</p></blockquote><center><span style="color:blue;font-size:15px">2021/6/1</span></center><h4 id="二、平面上曲线积分与路径无关的条件"><a href="#二、平面上曲线积分与路径无关的条件" class="headerlink" title="二、平面上曲线积分与路径无关的条件"></a>二、平面上曲线积分与路径无关的条件</h4><p><span style="color:blue;font-size:20px">定理2：</span> 设区域$\sigma$为一个单连通区域，若函数P(x,y),Q(x,y)在$\sigma$内有一阶连续偏导数，则曲线积分$\int_LPdx+Qdy$在$\sigma$内与路径无关的充要条件是：$\displaystyle \frac{\partial Q}{\partial x}=\frac{\partial P}{\partial y}$在$\sigma$内恒成立</p><h4 id="三、二元函数的全微分求积"><a href="#三、二元函数的全微分求积" class="headerlink" title="三、二元函数的全微分求积"></a>三、二元函数的全微分求积</h4><p><span style="color:blue;font-size:20px">定理3：</span> 设区域$\sigma$为一个单连通区域，若函数P(x,y),Q(x,y)在$\sigma$内有一阶连续偏导数，则曲线积分$\int_LPdx+Qdy$在$\sigma$内为某一函数u(x,y)的充要条件是：$\displaystyle \frac{\partial Q}{\partial x}=\frac{\partial P}{\partial y}$在$\sigma$内恒成立，且</p><p>$\displaystyle u(x,y)=\int^{(x,y)}_{(x_0,y_0)}P(x,y)dx+Q(x,y)dy$</p><p><strong>求原函数：</strong></p><p><strong>解法一：</strong>用线积分求</p><blockquote><p>因为以上公式的曲线积分与路径无关，为计算简便起见，可以选择平行于坐标轴的直线段连成的折线作为积分路线（方便的话也可以用圆什么的），当然要假定这些折线完全位于$\sigma$内</p></blockquote><p><strong>解法二：</strong>用偏积分求（$\frac{\partial u}{\partial x}=P$）</p><p><strong>解法三：</strong>用凑全微分法求</p><blockquote><p>首选凑微分（方便），不好凑的话优先选偏积分法</p></blockquote><p><strong>若线积分与路径无关：</strong></p><p><strong>解法一：</strong>改换路径</p><p><strong>解法二：</strong>求出原函数</p><p><span style="color:blue;font-size:20px">推论：</span> 设区域$\sigma$为一个单连通区域，若函数P(x,y),Q(x,y)在$\sigma$内有一阶连续偏导数，则曲线积分$\int_LPdx+Qdy$在$\sigma$内与路径无关的充要条件是在$\sigma$内存在函数u(x,y)，使du=Pdx+Qdy</p><h4 id="内容小结："><a href="#内容小结：" class="headerlink" title="内容小结："></a>内容小结：</h4><p><img src="/images/tongji-calculus-11-12/image-20210601161919304.png" alt=""></p><h3 id="第四节-对面积的曲面积分（第一类曲面积分）"><a href="#第四节-对面积的曲面积分（第一类曲面积分）" class="headerlink" title="第四节 对面积的曲面积分（第一类曲面积分）"></a>第四节 对面积的曲面积分（第一类曲面积分）</h3><h4 id="一、对面积的曲面积分的概念与性质"><a href="#一、对面积的曲面积分的概念与性质" class="headerlink" title="一、对面积的曲面积分的概念与性质"></a>一、对面积的曲面积分的概念与性质</h4><p>背景：弯曲薄片的质量</p><p><span style="color:red;font-size:20px">定义</span> <script type="math/tex">设曲面\Sigma是光滑的,函数f(x,y,z)在\Sigma上有界.\\把\Sigma任意分成n小块\triangle S_i(\triangle S_i,同时也代表第i小块的面积)\\设(\xi_i,\eta_i,\zeta_i)是\triangle S_i上任意取定的一点,作乘积f(\xi_i,\eta_i,\zeta_i)\triangle S_i，(i=1,2,...,n),\\并作和\sum^n_{i=1}f(\xi_i,\eta_i,\zeta_i)\triangle s_i,如果当各小块曲面的直径的最大值λ→0时,这和的极限总存在,\\且与曲面\Sigma的分法及点(\xi_i,\eta_i,\zeta_i)的取法无关,\\那么称此极限为函数f(x,y,z)在曲面\Sigma上对面积的曲面积分或第一类曲面积分,记作\iint \limits_\Sigma f(x,y,z)dS,即\\\displaystyle\iint \limits_\Sigma f(x,y,z)dS=\lim_{\lambda\to0}\sum^n_{i=1}f(\xi_i,\eta_i,\zeta_i)\triangle S_i</script></p><p>性质与曲线积分的性质相类似</p><h4 id="二、对面积的区面积法的计算法"><a href="#二、对面积的区面积法的计算法" class="headerlink" title="二、对面积的区面积法的计算法"></a>二、对面积的区面积法的计算法</h4><p>将对面积的曲面积分化为相应的二重积分</p><p>对<script type="math/tex">\displaystyle\iint \limits_\Sigma f(x,y,z)dS\qquad曲面\Sigma:z=\varphi(x,y),(x,y)\in D_{xy}</script></p><p>$ds=\sqrt{1+{z_x}^2+{z_y}^2}d\sigma$</p><p>$\left(\displaystyle \vec n=(-z_x,-z_y,1),\cos \gamma=\frac{1}{\sqrt{1+z_x+z_y}},ds·\cos\gamma=d\sigma,ds=\sqrt{1+{z_x}^2+{z_y}^2}d\sigma\right)$</p><p>所以<script type="math/tex">\displaystyle\iint \limits_\Sigma f(x,y,z)dS=\iint \limits_{D_{xy}}f(x,y,\varphi(x,y))\sqrt{1+{z_x}^2+{z_y}^2}d\sigma</script></p><p>如果积分曲面由方程x=x(y,z)或y=y(z,x)给出，也可类似地把对面积的曲面积分化为相应的二重积分</p><h3 id="第五节-对坐标的曲面积分（第二类曲面积分）"><a href="#第五节-对坐标的曲面积分（第二类曲面积分）" class="headerlink" title="第五节 对坐标的曲面积分（第二类曲面积分）"></a>第五节 对坐标的曲面积分（第二类曲面积分）</h3><h4 id="一、对坐标的曲面积分的概念与性质"><a href="#一、对坐标的曲面积分的概念与性质" class="headerlink" title="一、对坐标的曲面积分的概念与性质"></a>一、对坐标的曲面积分的概念与性质</h4><p>背景：在一个流速场内一定时间内流向某曲面一侧的流量</p><p><img src="/images/tongji-calculus-11-12/image-20210601223753010.png" alt=""></p><p><span style="color:red;font-size:20px">定义:</span> 设$\Sigma$是光滑的<strong>有向</strong>曲面，</p><p>有<script type="math/tex">\displaystyle\iint\limits_\Sigma R(x,y,z)dxdy=\lim_{\lambda\to 0}\sum^n_{i=1}R(\xi_i,\eta_i,\zeta_i)(\triangle S_i)_{xy}\\\displaystyle\iint\limits_\Sigma P(x,y,z)dydz=\lim_{\lambda\to 0}\sum^n_{i=1}P(\xi_i,\eta_i,\zeta_i)(\triangle S_i)_{yz}\\\displaystyle\iint\limits_\Sigma Q(x,y,z)dzdx=\lim_{\lambda\to 0}\sum^n_{i=1}Q(\xi_i,\eta_i,\zeta_i)(\triangle S_i)_{zx}\\\displaystyle 常见的形式是\iint\limits_\Sigma Pdydz+Qdzdx+Rdxdy</script></p><blockquote><p>关于对坐标的曲面积分，必须注意积分曲面所取的侧</p></blockquote><center><span style="color:blue;font-size:15px">2021/6/2</span></center><h4 id="二、对坐标的曲面积分的计算法"><a href="#二、对坐标的曲面积分的计算法" class="headerlink" title="二、对坐标的曲面积分的计算法"></a>二、对坐标的曲面积分的计算法</h4><p><strong>直接法：</strong></p><p>（1）$曲面\Sigma:z=\varphi(x,y),(x,y)\in D_{xy}$</p><script type="math/tex; mode=display">\displaystyle\iint\limits_\Sigma R(x,y,z)dxdy=\pm\iint\limits_{D_{xy}}R(x,y,\varphi(x,y))dxdy</script><p>注意正负！曲面的方向与z轴的方向相同（夹角小于90度）时为正，相反时为负</p><p>对其他坐标轴投影的方法类似</p><h4 id="三、两类曲面积分的关系"><a href="#三、两类曲面积分的关系" class="headerlink" title="三、两类曲面积分的关系"></a>三、两类曲面积分的关系</h4><script type="math/tex; mode=display">\displaystyle \iint\limits_\Sigma Pdydz+Qdzdx+Rdxdy=\iint\limits_\Sigma(P\cos\alpha+Q\cos\beta+R\cos\gamma)dS</script><script type="math/tex; mode=display">\displaystyle \iint\limits_\Sigma \vec A·d\vec {S}=\iint\limits_\Sigma\vec A·\vec {e_n}dS\qquad(\vec A=(P,Q,R),d\vec {S}=(dydz,dzdx,dxdy))</script><p><strong>归一法：</strong></p><p>如果曲面能写成$z=\varphi(x,y)$的形式，则​</p><script type="math/tex; mode=display">\displaystyle \iint\limits_\Sigma P(x,y,z)dydz+Q(x,y,z)dzdx+R(x,y,z)dxdy\\\displaystyle=\pm\left[P(x,y,\varphi(x,y))(-\frac{\partial z}{\partial x})+Q(x,y,\varphi(x,y)))(-\frac{\partial z}{\partial y})+R(x,y,\varphi(x,y))\right]dxdy\\\left(\vec n=(-\frac{\partial z}{\partial x},-\frac{\partial z}{\partial y},1),\vec{e_n}=\frac{1}{\sqrt{1+{z_x}^2+{z_y}^2}}(-\frac{\partial z}{\partial x},-\frac{\partial z}{\partial y},1),dS=\sqrt{1+{z_x}^2+{z_y}^2}dxdy\right)</script><h4 id="内容小结：-1"><a href="#内容小结：-1" class="headerlink" title="内容小结："></a>内容小结：</h4><p><img src="/images/tongji-calculus-11-12/image-20210602153753096.png" alt=""></p><h3 id="第六节-高斯公式-散度"><a href="#第六节-高斯公式-散度" class="headerlink" title="第六节 高斯公式 散度"></a>第六节 高斯公式 散度</h3><h4 id="一、高斯公式（三重积分和曲面积分的转换）"><a href="#一、高斯公式（三重积分和曲面积分的转换）" class="headerlink" title="一、高斯公式（三重积分和曲面积分的转换）"></a>一、高斯公式（三重积分和曲面积分的转换）</h4><p><span style="color:blue;font-size:20px">定理：</span>设空间有界闭区域$\Omega$由分片光滑的闭曲面$\Sigma$围成，若函数P(x,y,z),Q(x,y,z),R(x,y,z)在该区域上具有一阶连续偏导数，则</p><p>:<script type="math/tex">\displaystyle\iint\limits_\Sigma Pdydz+Qdzdx+Rdxdy=\iiint\limits_\Omega \left(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}\right)dv</script>，($\Sigma$是<strong>外侧</strong>曲面)</p><h4 id="二、散度"><a href="#二、散度" class="headerlink" title="二、散度"></a>二、散度</h4><p>$\vec A(P,Q,R),\triangledown(\frac{\partial }{\partial x},\frac{\partial }{\partial y},\frac{\partial }{\partial z})(向量微分算子)\qquad div\vec A=\vec A ·\vec\triangledown=\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}$</p><h4 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h4><p><img src="/images/tongji-calculus-11-12/image-20210602200027501.png" alt=""></p><h3 id="第七节-斯托克斯公式-旋度"><a href="#第七节-斯托克斯公式-旋度" class="headerlink" title="第七节 斯托克斯公式 旋度"></a>第七节 斯托克斯公式 旋度</h3><p>斯托克斯公式是格林公式的推广，格林公式表达了平面闭区域上的二重积分与其边界曲线上的曲线积分间的关系，而斯托克斯公式则把曲面$\Sigma$上的曲面积分与沿着$\Sigma$的边界曲线的曲线积分联系起来</p><h4 id="一、斯托克斯公式"><a href="#一、斯托克斯公式" class="headerlink" title="一、斯托克斯公式"></a>一、斯托克斯公式</h4><p><span style="color:blue;font-size:20px">定理：</span>设$\Gamma$为分段光滑的空间有向闭曲线，$\Sigma$是以$\Gamma$为边界的分片光滑的有向曲面，$\Gamma$的正向与$\Sigma$的侧符合右手规则，若函数P(x,y,z),Q(x,y,z),R(x,y,z)在曲面$\Sigma$上（连同边界）具有一阶连续偏导数，则</p><p>:<script type="math/tex">\displaystyle\oint_\Gamma Pdx+Qdy+Rdz=\iint\limits_\Sigma\begin{vmatrix}dydz&dzdx&dxdy\\\frac{\partial }{\partial x}&\frac{\partial }{\partial y}&\frac{\partial }{\partial z}\\P&Q&R\end{vmatrix}=\iint\limits_\Sigma\begin{vmatrix}\cos\alpha&\cos\beta&\cos\gamma\\\frac{\partial }{\partial x}&\frac{\partial }{\partial y}&\frac{\partial }{\partial z}\\P&Q&R \end{vmatrix}dS</script>，($\Sigma$是<strong>外侧</strong>曲面)</p><h4 id="二、旋度"><a href="#二、旋度" class="headerlink" title="二、旋度"></a>二、旋度</h4><p>$\displaystyle\vec A(P,Q,R),\qquad rot\vec A=\triangledown\times\vec A=\begin{vmatrix}\vec i&amp;\vec j&amp;\vec k\\\frac{\partial }{\partial x}&amp;\frac{\partial }{\partial y}&amp;\frac{\partial }{\partial z}\\P&amp;Q&amp;R \end{vmatrix}$</p><center><span style="color:blue;font-size:15px">2021/6/4</span></center><h2 id="第十二章-无穷级数"><a href="#第十二章-无穷级数" class="headerlink" title="第十二章 无穷级数"></a>第十二章 无穷级数</h2><h3 id="第一节-常数项级数的概念和性质"><a href="#第一节-常数项级数的概念和性质" class="headerlink" title="第一节 常数项级数的概念和性质"></a>第一节 常数项级数的概念和性质</h3><h4 id="一、常数项级数的概念"><a href="#一、常数项级数的概念" class="headerlink" title="一、常数项级数的概念"></a>一、常数项级数的概念</h4><p>若ui为常数数列，<script type="math/tex">\displaystyle \sum^\infty_{i=1}u_i</script>就叫做（常数项）<strong>无穷级数</strong>，简称（常数项）<strong>级数</strong>，其中第n项$u_i$叫做级数的<strong>一般项</strong></p><p>取级数的前n项的和$s_n=u_i+u_2+…+u_n$称为级数的<strong>部分和</strong>，当n依次取1,2,3时，构成一个新的数列{$s_n$}</p><p><span style="color:red;font-size:20px">定义:</span> <script type="math/tex">如果级数\displaystyle \sum^\infty_{i=1}u_i的部分和数列\{s_n\}有极限s，即\lim_{n\to\infty}s_n=s,那么称无穷级数\sum^\infty_{i=1}u_i收敛\\这时极限s叫做这极限的和，并写成s=u_1+u_2+...+u_i+...\\如果\{s_n\}没有极限，那么称无穷级数\displaystyle \sum^\infty_{i=1}u_i发散</script></p><blockquote><p>级数和数列极限有着紧密的联系，级数$\displaystyle \sum^\infty_{i=1}u_i与数列\{s_n\}$同时收敛或同时发散，且在收敛时，有</p><script type="math/tex; mode=display">\displaystyle \sum^\infty_{i=1}u_i=\lim_{n\to\infty}s_n,\qquad即\sum^\infty_{i=1}u_i=\lim_{n\to\infty}\sum^n_{i=1}u_i</script></blockquote><p><strong>note：</strong><script type="math/tex">\displaystyle \sum^\infty_{n=0}a·q^n\displaystyle\begin{cases}发散，\qquad |q|\geq1\\\frac{aq}{1-q}，\qquad |q|<1\end{cases}</script>称为几何级数（等比级数）</p><h4 id="二、收敛级数的基本性质"><a href="#二、收敛级数的基本性质" class="headerlink" title="二、收敛级数的基本性质"></a>二、收敛级数的基本性质</h4><p><span style="color:sienna;font-size:20px">性质1：</span>级数的每一项同乘一个不为零的常数后，它的收敛性不会改变</p><p><span style="color:sienna;font-size:20px">性质2：</span>两个收敛级数逐项相加或相减构成的新级数仍收敛</p><p><span style="color:sienna;font-size:20px">性质3：</span>在级数中去掉，加上或改变有限项，不会改变级数的收敛性</p><p><span style="color:sienna;font-size:20px">性质4：</span>如果级数收敛，那么对这级数的项任意加括号后所成的级数仍收敛，且其和不变<br>如果加括号后所承担级数收敛，那么不能断定去括号后原来的级数也收敛<br>如果加括号后所成的级数发散，那么原来级数也发散<br>【添加括号会提高收敛性】</p><p><span style="color:sienna;font-size:20px">性质5（级数收敛的必要条件）：</span>如果级数收敛，则一般项$\displaystyle \lim_{n\to\infty}u_n=0$，反之不对</p><h3 id="第二节-常数项级数的审敛法"><a href="#第二节-常数项级数的审敛法" class="headerlink" title="第二节 常数项级数的审敛法"></a>第二节 常数项级数的审敛法</h3><p>正项级数特别重要，以后将看到许多级数的收敛性问题可归结为正项级数的收敛性问题</p><h4 id="一、正项级数及其审敛法"><a href="#一、正项级数及其审敛法" class="headerlink" title="一、正项级数及其审敛法"></a>一、正项级数及其审敛法</h4><p>各项都是正数或零的级数称为正项级数，正向级数的部分和数列{$s_n$}显然是一个单调增加数列，如果级数收敛，根据有极限的数列是有界数列可知，数列{$s_n$}有界</p><p> <span style="color:blue;font-size:20px">定理1（基本定理）：</span>正项级数$\displaystyle \sum^\infty_{n=1}u_n$收敛的<strong>充分必要条件</strong>是：它的部分和数列{$s_n$}有界<br>如正项级数发散，那么它的部分和数列$s_n\to\infty(n\to\infty)$</p><p> <span style="color:blue;font-size:20px">定理2（比较审敛法）：</span><script type="math/tex">设\displaystyle \sum^\infty_{n=1}a_n与\sum^\infty_{n=1}b_n是两个正项级数，且a_n\leq b_n,则\\（1）若\displaystyle\sum^\infty_{n=1}b_n收敛，\sum^\infty_{n=1}a_n也收敛\\（2）若\displaystyle\sum^\infty_{n=1}a_n发散，\sum^\infty_{n=1}b_n也发散</script></p><p>   <strong>note：</strong>p级数<script type="math/tex">\displaystyle \sum^\infty_{n=1}\frac{1}{n^p}(p>0)</script>当p&gt;1时收敛，当p≤1时发散（当p=1时，称此级数为调和级数）</p><p> <span style="color:blue;font-size:20px">定理3（比较审敛法的极限形式）：</span></p><p><img src="/images/tongji-calculus-11-12/image-20210604161637929.png" alt=""></p><blockquote><p>比较审敛法的缺点：要求依赖别的级数，需要对原来的级数进行适当的放大或缩小，参照物不好找</p></blockquote><p> <span style="color:blue;font-size:20px">定理4（比值审敛法）：</span><script type="math/tex">设\displaystyle \sum^\infty_{n=1}u_n为正项级数，若\lim_{n\to\infty}\frac{u_{n+1}}{u_n}=\rho\\则当\rho<1时，级数收敛，当\rho>1时，级数发散，\rho=1时都有可能</script></p><p> <span style="color:blue;font-size:20px">定理5（根值审敛法）：</span><script type="math/tex">设\displaystyle \sum^\infty_{n=1}u_n为正项级数，若\lim_{n\to\infty}\sqrt[n] u_n=\rho\\则当\rho<1时，级数收敛，当\rho>1(或+\infty)时，级数发散，\rho=1时都有可能</script></p><h4 id="二、交错级数及其审敛法"><a href="#二、交错级数及其审敛法" class="headerlink" title="二、交错级数及其审敛法"></a>二、交错级数及其审敛法</h4><p>交错级数的各项是正负交替的，可以写成下面的形式$u_1-u_2+u_3-u_4+…$或$-u_1+u_2-u_3+u_4-…$</p><p> <span style="color:blue;font-size:20px">定理6（莱布尼兹审敛法）：</span><script type="math/tex">如果交错级数\displaystyle \sum^\infty_{n=1}(-1)^{n-1}u_n满足条件\\(1)u_n\geq u_{n+1}\qquad(2)\displaystyle\lim_{n\to\infty}u_n=0\\那么级数收敛，且s\leq u_1，其余项的绝对值|r_n|\leq u_{n+1}</script></p><blockquote><script type="math/tex; mode=display">\displaystyle\sum^\infty_{n=1}a_n收敛不能推出\displaystyle\sum^\infty_{n=1}{a_n}^2收敛，例如\displaystyle\sum^\infty_{n=1}\frac{(-1)^n}{\sqrt n}收敛，而\displaystyle\sum^\infty_{n=1}[\frac{(-1)^n}{\sqrt n}]^2=\sum^\infty_{n=1}\frac{1}{n}发散</script><p>因为平方虽然会使一般项趋于0的速度更快，但同时也可能消去一般项中的负值</p></blockquote><h4 id="三、绝对收敛与条件收敛"><a href="#三、绝对收敛与条件收敛" class="headerlink" title="三、绝对收敛与条件收敛"></a>三、绝对收敛与条件收敛</h4><blockquote><p>取绝对值不会改变一般项趋于0的速度，但会消掉负值，所以会提高发散性</p></blockquote><p>（1）若级数<script type="math/tex">\displaystyle\sum^\infty_{n=1}a_n</script>收敛，而<script type="math/tex">\displaystyle\sum^\infty_{n=1}|a_n|</script>发散，称<script type="math/tex">\displaystyle\sum^\infty_{n=1}a_n</script>条件收敛</p><p>（2）若级数<script type="math/tex">\displaystyle\sum^\infty_{n=1}|a_n|</script>收敛，称<script type="math/tex">\displaystyle\sum^\infty_{n=1}a_n</script>绝对收敛</p><p> <span style="color:blue;font-size:20px">定理7：</span>如果级数<script type="math/tex">\displaystyle\sum^\infty_{n=1}a_n</script>绝对收敛，那么级数<script type="math/tex">\displaystyle\sum^\infty_{n=1}a_n</script>必定收敛</p><center><span style="color:blue;font-size:15px">2021/6/6</span></center><h3 id="第三节-幂级数"><a href="#第三节-幂级数" class="headerlink" title="第三节 幂级数"></a>第三节 幂级数</h3><h4 id="一、函数项级数的概念"><a href="#一、函数项级数的概念" class="headerlink" title="一、函数项级数的概念"></a>一、函数项级数的概念</h4><p>如果给定一个定义在区间I上的函数列{<script type="math/tex">u_n(x)</script>}，称<script type="math/tex">\displaystyle \sum_{n=1}^\infty</script>为定义在区间I上的函数项无穷级数，简称<strong>（函数项）级数</strong></p><p>对于每一个确定的值$x_0\in I$，如果级数发散，称点$x_0$为级数的<strong>收敛点</strong>，如果级数发散，称点$x_0$为级数的<strong>发散点</strong></p><p>函数项级数的收敛点的全体称为它的<strong>收敛域</strong>，发散点的全体称为它的<strong>发散域</strong></p><p>对于收敛域内的任意一个数x，函数项级数成为一收敛的常数项级数，因而有一确定的和s，这样，在收敛域上，函数项级数的和是x的函数s(x)，通常称s(x)为函数项级数的<strong>和函数</strong>，函数的定义域就是级数的收敛域，并写成<br>$\displaystyle \sum^{\infty}_{n=1}u_n(x)=s(x)$</p><h4 id="二、幂级数及其收敛性"><a href="#二、幂级数及其收敛性" class="headerlink" title="二、幂级数及其收敛性"></a>二、幂级数及其收敛性</h4><p>函数项级数中简单而常见的一类级数就是各项都是常数乘幂级数的函数项级数，即<strong>幂级数</strong>，它的形式是</p><script type="math/tex; mode=display">\displaystyle \sum^\infty_{n=0}a_nx^n=a_0+a_1x+a_2x^2+......或\displaystyle \sum^\infty_{n=0}a_n(x-x_0)^n=a_0+a_1(x-x_0)+a_2(x-x_0)^2+......</script><p>其中常数$a_0,a_1,a_2……$称为幂级数的系数</p><p> <span style="color:blue;font-size:20px">定理1（阿贝尔(Abel)定理）：</span>如果级数 <script type="math/tex">\displaystyle \sum_{n=0}^{\infty} a_{n} x^{n}</script>当 <script type="math/tex">x=x_{0}\left(x_{0} \neq 0\right)</script>时收敛，那么适合不等式<script type="math/tex">|x|<| x_0|</script> 的一切x使这幕级数绝对收敛，反之，如果级数<script type="math/tex">\displaystyle \sum_{n=0}^{\infty} a_{n} x^{n}</script> 当 <script type="math/tex">x=x_{0}</script> 时发散，那么适合不等式 <script type="math/tex">|x|>|x_{0}|</script> 的一切x使这幕级数发散</p><p><span style="color:green;font-size:20px">推论：</span>如果幕级数 <script type="math/tex">\displaystyle\sum_{n=0}^{\infty} a_{n} x^{n}</script> 不是仅在x=0点收敛，也不是在整个数轴上都收敛，那么必有一个确定的正数R存在，使得<br>当 |x|$&lt;$R时，幕级数绝对收敛<br>当 |x|$&gt;$R时，幕级数发散<br>当 x=R​与x=-R​时，幕级数可能收敛也可能发散</p><p>正数R通常叫做幂级数的<strong>收敛半径</strong>，开区间(-R,R)称为幂级数的<strong>收敛区间</strong>，再由幂级数在$x=\pm R$处的收敛性就可以决定它的<strong>收敛域</strong></p><p> <span style="color:blue;font-size:20px">定理2：</span>对于<script type="math/tex">\displaystyle\sum_{n=0}^{\infty} a_{n} x^{n}，若\displaystyle\lim_{n\to\infty}\left|\frac{a_{n+1}}{a_n}\right|=\rho,则R=\begin{cases}\frac{1}{\rho},\qquad\rho\not=0\\+\infty ,\quad\rho=0\\0,\qquad\rho=+\infty\end{cases}</script></p><p> <span style="color:blue;font-size:20px">定理3：</span>对于<script type="math/tex">\displaystyle\sum_{n=0}^{\infty} a_{n} x^{n}，若\displaystyle\lim_{n\to\infty}\sqrt[n]{|a_n|}=\rho,则R=\begin{cases}\frac{1}{\rho},\qquad\rho\not=0\\+\infty ,\quad\rho=0\\0,\qquad\rho=+\infty\end{cases}</script></p><p><strong>note:</strong>对于<script type="math/tex">\displaystyle\sum_{n=0}^{\infty} a_{n} x^{2n+1}，若\displaystyle\lim_{n\to\infty}\left|\frac{a_{n+1}}{a_n}\right|=\rho,则R=\begin{cases}\sqrt\frac{1}{\rho},\qquad\rho\not=0\\+\infty ,\quad\rho=0\\0,\qquad\rho=+\infty\end{cases}</script>(跨度是2，所以是1/2次方)</p><h4 id="三、幂函数的运算（幂级数的和函数的性质）"><a href="#三、幂函数的运算（幂级数的和函数的性质）" class="headerlink" title="三、幂函数的运算（幂级数的和函数的性质）"></a>三、幂函数的运算（幂级数的和函数的性质）</h4><p><span style="color:sienna;font-size:20px">性质1：</span>幂级数的和函数在其收敛域上连续</p><p><span style="color:sienna;font-size:20px">性质2：</span>幂函数的和函数在其收敛域上可积，并有连续积分公式</p><script type="math/tex; mode=display">\displaystyle\int_{0}^{x} s(t) \mathrm{d} t =\int_{0}^{x}\left[\sum_{n=0}^{\infty} a_{n} t^{n}\right] \mathrm{d} t=\sum_{n=0}^{\infty} \int_{0}^{x} a_{n} t^{n} \mathrm{~d} t =\sum_{n=0}^{\infty} \frac{a_{n}}{n+1} x^{n+1}(x \in I)</script><p>逐项积分后所得到的幂级数和原级数有相同的收敛半径</p><p><span style="color:sienna;font-size:20px">性质3：</span>幂函数的和函数在其收敛区间(-R,R)上可导，并有连续求导公式<script type="math/tex">\displaystyle s^{\prime}(x)=\left(\sum_{n=0}^{\infty} a_{n} x^{n}\right)^{\prime}=\sum_{n=0}^{\infty}\left(a_{n} x^{n}\right)^{\prime}=\sum_{n=1}^{\infty} n a_{n} x^{n-1}(|x|<R)</script>（x=0对于的常数项求导消失）</p><p>逐项求导后所得到的幂级数和原级数有相同的收敛半径</p><p>反复应用上述结论可知，<strong>幂级数的和函数在其收敛区间内具有任意阶导数</strong></p><center><span style="color:blue;font-size:15px">2021/6/7</span></center><h3 id="第四节-函数展开成幂级数"><a href="#第四节-函数展开成幂级数" class="headerlink" title="第四节 函数展开成幂级数"></a>第四节 函数展开成幂级数</h3><p>如果能找到一个幂级数，它在某区间内收敛，且其和恰好就是给定的函数f(x)，那么<strong>函数f(x)在该区间内就能展开成幂级数</strong></p><p>如果函数在x0的领域内能展开为$x-x_0$的幂级数，那么</p><script type="math/tex; mode=display">\displaystyle f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+...\\=\displaystyle\sum^\infty_{n=0}\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n</script><p>称为f(x)在$x=x_0$时的泰勒级数</p><p>当<script type="math/tex">x_0=0时，\displaystyle\sum^\infty_{n=0}\frac{f^{(n)}(0)}{n!}(x)^n</script>称为f(x)的麦克劳林级数</p><p> <span style="color:blue;font-size:20px">定理：</span><script type="math/tex">设f(x)在x=x_0的某邻域内任意阶可导,\\则f(x)在x=x_0邻域内能展开为\displaystyle\sum^\infty_{n=0}\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n的充要条件是\\\displaystyle\lim_{n\to\infty}R_n(x)=0</script></p><blockquote><p>泰勒公式中要求n+1阶可导，而泰勒级数要求任意阶可导($n\to\infty$)</p></blockquote><p><strong>常用的泰勒级数：</strong></p><p><img src="/images/tongji-calculus-11-12/image-20210607192959677.png" alt=""></p><p>将函数展开成幂级数的方法：</p><p>（1）直接法：求出f(x)的各阶导数，代入公式</p><p>（2）间接法：利用已有公式和幂级数的性质（逐项可积，逐项可导）</p><h4 id="内容小结-1"><a href="#内容小结-1" class="headerlink" title="内容小结"></a>内容小结</h4><p><img src="/images/tongji-calculus-11-12/image-20210607194250752.png" alt=""></p><p><img src="/images/tongji-calculus-11-12/image-20210607194433350.png" alt=""></p><center><span style="color:blue;font-size:15px">2021/6/8</span></center><h3 id="第七节-傅里叶级数"><a href="#第七节-傅里叶级数" class="headerlink" title="第七节 傅里叶级数"></a>第七节 傅里叶级数</h3><p>本节着重研究如何把函数展开成三角函数</p><h4 id="一、三角级数"><a href="#一、三角级数" class="headerlink" title="一、三角级数"></a>一、三角级数</h4><p>周期函数反映了客观世界中的周期运动，正弦函数就是一种简单而常见的周期函数，例如描述简谐运动的函数$y=A\sin(\omega t+\varphi)$.但是在实际问题中，除了正弦函数外，还会遇到非正弦函数的周期函数，它们反映了比较复杂的周期运动，如电子技术中常用的周期为T的矩形波就是一个非正弦函数的例子。</p><p>我们也想将周期函数展开成由简单的周期函数例如三角函数函数组成的级数，可以写作</p><script type="math/tex; mode=display">\displaystyle\frac{a_{0}}{2}+\sum_{n=1}^{\infty}\left(a_{n} \cos \frac{n \pi t}{l}+b_{n} \sin \frac{n \pi t}{l}\right)</script><p>形如上式的级数叫做<strong>三角级数</strong>，将周期函数按上述方法展开，就是把一个比较复杂的周期运动看成是许多不同频率的简谐振动的叠加，在电工学上，这种展开称为<strong>谐波分析</strong>，其中常数项$\frac{a_0}2$称为<strong>直流分量</strong>，$a_1\cos x+b_1\sin x$称为<strong>一次谐波</strong>，$a_2\cos 2x+b_2\sin 2x$称为<strong>二次谐波</strong>等等</p><p>令 $\frac{\pi t}{l}=x$，上式成为</p><script type="math/tex; mode=display">\displaystyle \frac{a_{0}}{2}+\sum_{n=1}^{\infty}\left(a_{n} \cos n x+b_{n} \sin n x\right)</script><p>这就把以2l为周期的三角级数转换成以2π为周期的三角函数</p><h4 id="二、函数展开成傅里叶级数"><a href="#二、函数展开成傅里叶级数" class="headerlink" title="二、函数展开成傅里叶级数"></a>二、函数展开成傅里叶级数</h4><p> <span style="color:blue;font-size:20px">定理（狄利克雷充分条件）：</span></p><p>：<script type="math/tex">设f(x) 是周期为2π的周期函数,如果它满足:\\(1)在一个周期([-π,π])内连续或只有有限个第一类间断点，\\(2)在一个周期([-π,π])内至多只有有限个极值点，\\那么f(x)的傅里叶级数收敛,并且\\\displaystyle a_0=\frac1\pi\int^\pi_{-\pi}f(x)dx\\\displaystyle a_n=\frac1\pi\int^\pi_{-\pi}f(x)\cos nxdx\qquad(n=1,2,3,···)\\\displaystyle b_n=\frac1\pi\int^\pi_{-\pi}f(x)\sin nxdx\qquad(n=1,2,3,···)\\当x是f(x)的连续点时，级数收敛于f(x)；\\当x是f(x)的间断点时，级数收敛于\frac1 2[f(x^-)+f(x^+)]\\</script></p><p><strong>例1</strong>：<script type="math/tex">f(x)以2π为周期，f(x)在[-π,π]上表达式为:f(x)=\begin{cases}-1,\quad-\pi\leq x<0\\1,\qquad0\leq x<-\pi\end{cases}\\将f(x)展开成傅里叶级数，并作出其和函数的图像</script></p><p>（1）画出f(x)的图像，找出间断点$x=k\pi(k\in z)$</p><p>（2）<script type="math/tex">\displaystyle a_0=\frac1\pi\int^\pi_{-\pi}f(x)dx=0\\\displaystyle a_n=\frac1\pi\int^\pi_{-\pi}f(x)\cos nxdx=0\qquad(n=1,2,3,···)\\\displaystyle b_n=\frac1\pi\int^\pi_{-\pi}f(x)\sin nxdx=\begin{cases}\frac{4}{n\pi},\quad n=1,3,5,···\\0,\qquad n=2,4,6,···\end{cases}</script></p><p>（3）<script type="math/tex">\displaystyle f(x)=\frac{4}{\pi}\sum^\infty_{n=0}\frac{\sin((2n+1)x)}{2n+1}\qquad(-\infty<x<+\infty且x\not=k\pi(k\in z))</script></p><p>（4）当<script type="math/tex">\displaystyle x=k\pi(k\in z))时，\frac{4}{\pi}\sum^\infty_{n=0}\frac{\sin((2n+1)x)}{2n+1}=\frac{f(k\pi-0)+f(k\pi+0)}{2}=0</script></p><p>（5）令<script type="math/tex">\displaystyle s(x)=\frac{4}{\pi}\sum^\infty_{n=0}\frac{\sin((2n+1)x)}{2n+1}</script>，和函数的图像为：</p><p><img src="/images/tongji-calculus-11-12/image-20210608194126375.png" alt=""></p><p>此级数趋于f(x)的过程（$x\not=k\pi(k\in z)$）</p><p><img src="/images/tongji-calculus-11-12/image-20210608191239021.png" alt=""></p><blockquote><p>如果函数f(x)只在$[-\pi,\pi]$上有定义，我们可以在定义域外补充函数的定义，使它扩广成周期为2π的周期函数F(x)，这种拓广函数的定义域的过程称为<strong>周期延拓</strong></p><p>再将F(x)展开成傅里叶级数，最后限制x在(-π,π)内，此时F(x)=f(x)，这样便得到f(x)的傅里叶级数展开式</p><p>根据收敛定理，这级数在区间$x=\pm\pi$处收敛于$\displaystyle \frac{f(\pi^-)+f(-\pi^+)}{2}$</p></blockquote><h4 id="三、正弦级数和余弦级数"><a href="#三、正弦级数和余弦级数" class="headerlink" title="三、正弦级数和余弦级数"></a>三、正弦级数和余弦级数</h4><p>一般来说，一个函数的傅里叶级数既含有正弦项，也含有余弦项，但是一些函数的傅里叶级数只含有正弦项或者只含有常数项和余弦项，这和f(x)的奇偶性是有密切关系的。由于奇函数在对称区间上的积分为0，偶函数在对称区间上的积分等于半区间上积分的两倍，因此</p><p>当f(x)为奇函数时，f(x)cos nx是奇函数，f(x)sin nx是偶函数</p><p>故<script type="math/tex">\displaystyle \begin{cases}a_0=0\\a_n=0\\b_n=\frac2\pi\int^\pi_{0}f(x)\sin nxdx\qquad(n=1,2,3,···)\end{cases}</script></p><p>即<strong>奇函数</strong>的傅里叶级数是只含有正弦项的<strong>正弦级数</strong><script type="math/tex">\displaystyle\sum^\infty_{n=1}b_n\sin nx</script></p><p>当f(x)为偶函数时，f(x)cos nx是偶函数，f(x)sin nx是奇函数</p><p>故<script type="math/tex">\displaystyle \begin{cases}a_0=\frac2\pi\int^\pi_{0}f(x)dx\\a_n=\frac2\pi\int^\pi_{0}f(x)\cos nxdx\qquad(n=1,2,3,···)\\b_n=0\end{cases}</script></p><p>即<strong>偶函数</strong>的傅里叶级数是只含常数项和余弦项的<strong>余弦级数</strong><script type="math/tex">\displaystyle\frac{a_n}{2}+\sum^\infty_{n=1}a_n\cos nx</script></p><blockquote><p>如果函数f(x)只在$[0,\pi]$上有定义，我们可以在($-\pi,0$)内补充函数的定义，使它在($-\pi,\pi$)上成为奇函数（偶函数），这种拓广函数定义域的过程称为<strong>奇延拓</strong>（<strong>偶延拓</strong>）。然后将奇延拓（偶延拓）后的函数展开成傅里叶级数，这个级数必定是正弦级数（余弦级数），再限制x在($0,\pi$)上，此时F(x)=f(x)，这样便得到f(x)的正弦级数（余弦级数）展开式</p></blockquote><h3 id="第八节-周期为2l的周期函数的傅里叶级数"><a href="#第八节-周期为2l的周期函数的傅里叶级数" class="headerlink" title="第八节 周期为2l的周期函数的傅里叶级数"></a>第八节 周期为2l的周期函数的傅里叶级数</h3><p> <span style="color:blue;font-size:20px">定理：</span></p><p>：<script type="math/tex">设f(x) 是周期为2l的周期函数,如果它在[-l,l]上满足收敛定理的条件，则其傅里叶级数展开式为\\f(x)=\displaystyle \frac{a_{0}}{2}+\sum_{n=1}^{\infty}\left(a_{n} \cos \frac{n\pi x}{l}+b_{n} \sin \frac{n\pi x}{l}\right)(x\in C)，其中\\\displaystyle a_0=\frac1 l\int^\pi_{-\pi}f(x)dx\\\displaystyle a_n=\frac1 l\int^\pi_{-\pi}f(x)\cos\frac{n\pi x}{l}dx\qquad(n=1,2,3,···)\\\displaystyle b_n=\frac1 l\int^\pi_{-\pi}f(x)\sin\frac{n\pi x}{l}dx\qquad(n=1,2,3,···)\\当x是f(x)的连续点时，级数收敛于f(x)；\\当x是f(x)的间断点时，级数收敛于\frac1 2[f(x^-)+f(x^+)]\\</script></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同济高数第七版（8-10章）</title>
      <link href="2021/05/16/tongji-calculus-8-10/"/>
      <url>2021/05/16/tongji-calculus-8-10/</url>
      
        <content type="html"><![CDATA[<center><span style="color:blue;font-size:15px">2021/5/17</span></center><h2 id="第八章-向量代数与空间解析几何"><a href="#第八章-向量代数与空间解析几何" class="headerlink" title="第八章 向量代数与空间解析几何"></a>第八章 向量代数与空间解析几何</h2><h3 id="第一节-向量及线性运算"><a href="#第一节-向量及线性运算" class="headerlink" title="第一节 向量及线性运算"></a>第一节 向量及线性运算</h3><h4 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h4><p><span style="color:red;font-size:20px">定义（向量）：</span>有<strong>大小</strong>，有<strong>方向</strong>的量叫做向量</p><p><span style="color:red;font-size:20px">定义（向量相等）：</span>若两个向量方向相同，长度相等，记作<strong>向量相等</strong>($\vec a=\vec b$)</p><p><span style="color:red;font-size:20px">定义（向量的模）：</span>向量的大小叫作<strong>向量的模</strong>，记作$|\vec a|$<br>若$|\vec a|=0$，称其为<strong>零向量</strong>（零向量的方向是任意的）<br>若$|\vec a|=1$，称其为<strong>单位向量</strong></p><p><span style="color:red;font-size:20px">定义（向量夹角）：</span>规定不超过$\pi$的角称为<strong>向量夹角</strong>$(\widehat{\vec a,\vec b})=\theta$</p><h4 id="二、向量的线性运算"><a href="#二、向量的线性运算" class="headerlink" title="二、向量的线性运算"></a>二、向量的线性运算</h4><ol><li>$\vec a+\vec b$<br>几何：（1）平行四边形法则（2）三角形法则</li><li>$\vec a-\vec b(\vec{BA})$<br>几何：从b的终点指向a的终点（起点相同时）<br>代数：$\vec a-\vec b=\{a_1-a_2,b_1-b_2,c_1-c_2\}$</li><li>$k\vec a$</li></ol><h4 id="三、空间直角坐标系"><a href="#三、空间直角坐标系" class="headerlink" title="三、空间直角坐标系"></a>三、空间直角坐标系</h4><p>空间直角坐标系有8个<strong>卦限</strong>，x,y,z轴的正方向对应的是第一挂限，z&gt;0对应前4卦限，z&lt;0对应后4卦限</p><p>$\vec i,\vec j,\vec k$分别是与x,y,z轴的正方向方向相同的单位向量，{a,b,c}称为<strong>向量$\vec a$的坐标形式</strong></p><p>设$\vec a$的起点和终点分别是$A(x_1,y_1,z_1),B(x_2,y_2,z_2)$，则$\vec a=\vec{BA}=\{x_2-x_1,y_2-y_1,z_2-z_1\}$</p><h4 id="四、向量线性运算的代数描述"><a href="#四、向量线性运算的代数描述" class="headerlink" title="四、向量线性运算的代数描述"></a>四、向量线性运算的代数描述</h4><p>设$\vec a=\{a_x,a_y,a_z\},\vec b=\{b_x,b_y,b_z\}$，则</p><ul><li>$\vec a+\vec b=\{a_x+b_x,a_y+b_y,a_z+b_z\}$</li><li>$\vec a-\vec b=\{a_x-b_x,a_y-b_y,a_z-b_z\}$</li><li>$k\vec a==\{ka_x,ka_y,ka_z\}$</li></ul><h4 id="五、向量的模，单位向量，方向角，方向余弦，投影"><a href="#五、向量的模，单位向量，方向角，方向余弦，投影" class="headerlink" title="五、向量的模，单位向量，方向角，方向余弦，投影"></a>五、向量的模，单位向量，方向角，方向余弦，投影</h4><p><strong>1.向量的模：</strong>$|\vec a|=\sqrt{a_x^2+a_y^2+a_z^2}或\sqrt{(x_2-x_1)^2,(y_2-y_1)^2,(z_2-z_1)^2}$</p><p><strong>2.单位向量：</strong>$\vec a$的单位向量记作$\displaystyle\vec a_0,\vec a_0=\frac{\vec a}{|\vec a|}=\frac{\{a_x,a_y,a_z\}}{\sqrt{a_x^2+a_y^2+a_z^2}}$</p><p><strong>3.方向角：</strong>$\vec a$与x,y,z轴正方向的夹角称为$\vec a$的方向角，记为$\alpha,\beta,\gamma$</p><p><strong>4.方向余弦：</strong>称$\cos\alpha,\cos\beta,\cos\gamma为\vec a$的方向余弦</p><ul><li>$\displaystyle\cos\alpha=\frac{a_x}{|\vec a|},\cos\beta=\frac{a_y}{|\vec a|},\cos\gamma=\frac{a_z}{|\vec a|}$</li><li>$\displaystyle\{\cos\alpha,\cos\beta,\cos\gamma\}=\vec a_0=\frac{\vec a}{|\vec a|}$</li><li>$\cos^2\alpha+\cos^2\beta+\cos^2\gamma=1$</li></ul><p><strong>5.向量在坐标轴上的投影：</strong> 投影向量是一个向量，<strong>投影</strong>是投影向量的模</p><p>在u轴上的投影$prj_u\vec{AB}=|\vec{AB}\cos\theta|$</p><center><span style="color:blue;font-size:15px">2021/5/18</span></center><h3 id="第二节-数量积、向量积、混合积"><a href="#第二节-数量积、向量积、混合积" class="headerlink" title="第二节 数量积、向量积、混合积"></a>第二节 数量积、向量积、混合积</h3><h4 id="一、两向量的数量积（点乘-内积"><a href="#一、两向量的数量积（点乘-内积" class="headerlink" title="一、两向量的数量积（点乘/内积)"></a>一、两向量的数量积（点乘/内积)</h4><p>$\vec a·\vec b=|\vec a||\vec b|\cos\theta$（结果是一个数，只有大小没有方向）</p><p><strong>性质：</strong></p><ul><li>向量的内积等于其中一个向量的模乘另一个向量在这个向量的方向上的投影的乘积</li><li>$\vec a·\vec a=|\vec a|^2$</li><li>如果两个非零向量$\vec a·\vec b=0\quad(a_xb_x+a_yb_y+a_zb_z=0)$，那么$\vec a\perp\vec b$，反之亦然</li><li>若$\vec a·\vec a=0，则\vec a=\vec 0$</li></ul><p><strong>数量级符合下列运算规律：</strong></p><ul><li>交换律：$\vec a·\vec b=\vec b·\vec a$</li><li>分配率：$（\vec a+\vec b）·\vec c=\vec a·\vec c+\vec b·\vec c$</li></ul><p><strong>数量积的坐标表达式：</strong></p><p>坐标表达式：<script type="math/tex">\vec i·\vec j=\vec j·\vec k=\vec k·\vec i=0\\\vec i·\vec i=\vec j·\vec j=\vec k·\vec k=1\\设\vec a=\{a_x,a_y,a_z\}=a_x\vec i+a_y\vec j+a_z\vec k\\\quad\vec b=\{b_x,b_y,b_z\}=b_x\vec i+b_y\vec j+b_z\vec k,则\\\vec a·\vec b=(a_x\vec i+a_y\vec j+a_z\vec k)·(b_x\vec i+b_y\vec j+b_z\vec k)=...\\=a_xb_x+a_yb_y+a_zb_z</script></p><h4 id="二、向量的向量积（叉乘-外积）"><a href="#二、向量的向量积（叉乘-外积）" class="headerlink" title="二、向量的向量积（叉乘/外积）"></a>二、向量的向量积（叉乘/外积）</h4><p>$大小:|\vec a\times\vec b|=|\vec a||\vec b|\sin\theta\quad方向：右手定则$（结果是一个向量）（方向和x,y,z轴对应，a对应x，b对应y，axb对应z）</p><p><strong>性质：</strong></p><ul><li>$\vec a\times\vec a=0$</li><li>$\vec a\times\vec b=\vec 0\Leftrightarrow \vec a\parallel \vec b$</li><li>$\vec a\times\vec b\perp\vec a,\quad\vec a\times\vec b\perp\vec b$</li><li>$\vec a\times\vec b=-\vec b\times\vec a$</li></ul><p><strong>数量级符合下列运算规律：</strong></p><ul><li>反交换律：$\vec a\times\vec b=-\vec b\times\vec a$</li><li>分配率：$(\vec a+\vec b)\times \vec c=\vec a\times\vec c+\vec b\times\vec c$</li></ul><p><strong>向量积的坐标表达式：</strong></p><p>坐标表达式：<script type="math/tex">\vec i\times\vec i=\vec j\times\vec j=\vec k\times\vec k=0\\\vec i\times\vec j=\vec k,\vec j\times\vec k=\vec i,\vec k\times\vec i=\vec j\\(\vec j\times\vec i=-\vec k,\vec k\times\vec j=-\vec i,\vec i\times\vec k=-\vec j)\\设\vec a=\{a_x,a_y,a_z\}=a_x\vec i+a_y\vec j+a_z\vec k\\\quad\vec b=\{b_x,b_y,b_z\}=b_x\vec i+b_y\vec j+b_z\vec k,则\\\vec a\times\vec b=(a_x\vec i+a_y\vec j+a_z\vec k)\times(b_x\vec i+b_y\vec j+b_z\vec k)=...\\=(a_yb_z-a_zb_y)i+(a_zb_x-a_xb_z)j+(a_xb_y-a_yb_x)k</script></p><p>写成三阶行列式：<script type="math/tex">\vec a\times\vec b=\begin{vmatrix}\vec i&\vec j&\vec k\\a_x&a_y&a_z\\b_x&b_y&b_z\end{vmatrix}</script></p><p><strong>向量积的又一几何意义：三角形的面积</strong></p><p>三角形的面积等于$ab\sin\theta$</p><p>所以$S_\triangle=\frac{1}{2}|\vec a||\vec b|\sin\theta=\frac{1}{2}|\vec a\times\vec b|$（所以ab的叉乘的模是ab对应的平行四边形的面积）</p><h4 id="三、向量的混合积（三重积）"><a href="#三、向量的混合积（三重积）" class="headerlink" title="三、向量的混合积（三重积）"></a>三、向量的混合积（三重积）</h4><p>$[\vec a\vec b\vec c]=(\vec a\times\vec b)·\vec c$（结果是一个数，只有大小没有方向）</p><p><strong>混合积的坐标表达式：</strong></p><p>坐标表达式：<script type="math/tex">[\vec a\vec b\vec c]=(\vec a\times\vec b)·\vec c=\begin{vmatrix}a_x&a_y&a_z\\b_x&b_y&b_z\\c_x&c_y&c_z\end{vmatrix}</script></p><p><strong>混合积的几何意义：</strong></p><p>混合积的绝对值表示以向量abc为棱的平行六面体的体积<br>如果c的方向与ab叉乘的方向相同，符号位正，反之符号为负</p><p>三向量$\vec a、\vec b、\vec c$共面的充分必要条件是它们的混合积=0​</p><h3 id="第三节-平面及其方程（应用一）"><a href="#第三节-平面及其方程（应用一）" class="headerlink" title="第三节 平面及其方程（应用一）"></a>第三节 平面及其方程（应用一）</h3><h4 id="一、曲面方程与空间曲线方程的概念"><a href="#一、曲面方程与空间曲线方程的概念" class="headerlink" title="一、曲面方程与空间曲线方程的概念"></a>一、曲面方程与空间曲线方程的概念</h4><p>曲面：F(x,y,z)=0</p><p>空间曲线：F(x,y,z)=0;G(x,y,z)=0（两个空间曲面的交线）</p><p>平面与空间直线分别是曲面与空间曲线的特例</p><h4 id="二、平面的点法式方程"><a href="#二、平面的点法式方程" class="headerlink" title="二、平面的点法式方程"></a>二、平面的点法式方程</h4><p>（知道平面上的一点和一个法向量/平面上的两个向量/平面上的三个点时）</p><p>已知<script type="math/tex">平面上一点M_0(x_0,y_0,z_0),法向量\vec n(A,B,C),设M(x,y,z)为平面上\Pi的任意一点，可知\vec{M_0M}\perp\vec n\\即\vec{M_0M}·\vec n=0\Leftrightarrow \Pi :A(x-x_0)+B(y-y_0)+C(z-z_0)=0</script></p><h4 id="三、平面的截距式方程"><a href="#三、平面的截距式方程" class="headerlink" title="三、平面的截距式方程"></a>三、平面的截距式方程</h4><p>（平面与x,y,z轴的交点分别为(a,0,0)，(0,b,0)，(0,0,c)，由点法式求得，a,b,c依次叫做平面在x, y,z轴上的<strong>截距</strong>）</p><p>$\displaystyle\Pi:\frac{x}{a}+\frac{y}{b}+\frac{z}{c}=1$</p><h4 id="四、平面的一般式方程"><a href="#四、平面的一般式方程" class="headerlink" title="四、平面的一般式方程"></a>四、平面的一般式方程</h4><p>$\Pi:Ax+By+Cz+D=0$（任一平面都可以用三元一次方程来表示）</p><p>法向量$\vec n=(A,B,C)$</p><p>当D=0时，表示一个通过原点的平面</p><p>当A=0时，法向量垂直于x轴，平面与x轴平行，其他同理</p><p>当A=B=0时，法向量垂直于x轴和y轴，平面与xOy面平行，其他同理</p><h4 id="五、两平面的夹角"><a href="#五、两平面的夹角" class="headerlink" title="五、两平面的夹角"></a>五、两平面的夹角</h4><p>两平面的法向量的夹角($\leq\frac{\pi}{2}$)称为两平面的夹角</p><p>由$\vec n_1·\vec n_2=|\vec n_1||\vec n_2|\cos\theta$，得$\displaystyle\cos\theta=|\frac{\vec n_1·\vec n_2}{|\vec n_1||\vec n_2|}|$</p><h4 id="六、平面外一点与平面的距离"><a href="#六、平面外一点与平面的距离" class="headerlink" title="六、平面外一点与平面的距离"></a>六、平面外一点与平面的距离</h4><p><strong>注：</strong>$\displaystyle prj_{\vec a}\vec b=|\vec b|\cos\theta=\frac{|\vec a||\vec b|\cos\theta}{|\vec a|}=\frac{\vec a·\vec b}{|\vec a|}$</p><p>设$M_1(x_1,y_1,z_1)是平面上一点，M_0(x_0,y_0,z_0)$是平面Ax+By+Cz+D=0外一点，则</p><p>$d=\displaystyle |prj_{\vec n}\vec{M_0M_1}|=\frac{|\vec n·\vec{M_0M_1}|}{|\vec n|}=\frac{|A(x_1-x_0)+B(y_1-y_0)+C(z_1-z_0)|}{\sqrt{A^2+B^2+C^2}}=…$</p><p>得$\displaystyle d=\frac{|Ax_0+By_0+Cz_0+D|}{\sqrt{A^2+B^2+C^2}}$</p><h3 id="第四节-空间直线及其方程（应用二）"><a href="#第四节-空间直线及其方程（应用二）" class="headerlink" title="第四节 空间直线及其方程（应用二）"></a>第四节 空间直线及其方程（应用二）</h3><h4 id="一、空间直线的一般式方程"><a href="#一、空间直线的一般式方程" class="headerlink" title="一、空间直线的一般式方程"></a>一、空间直线的一般式方程</h4><p>L:$\begin{cases}A_1x+B_1y+C_1z+D_1=0\\A_2x+B_2y+C_2z+D_2=0\end{cases}$(两个平面的相交线)</p><h4 id="二、空间直线的对称式（点向式）方程"><a href="#二、空间直线的对称式（点向式）方程" class="headerlink" title="二、空间直线的对称式（点向式）方程"></a>二、空间直线的对称式（点向式）方程</h4><p>如果一个非零向量平行于一条已知直线，那么这个向量就叫做这条直线的<strong>方向向量</strong></p><p>已知直线L上的一点$M_0(x,y,z)$和它的方向向量$\vec s=(m,n,p)\parallel L$，设点M(x,y,z)是直线L上的任一点，</p><p>则$\vec{M_0M}=(x-x_0,y-y_0,z-z_0),$有L：$\displaystyle\frac{x-x_0}{m}=\frac{y-y_0}{n}=\frac{z-z_0}{p}$</p><h4 id="三、参数式方程"><a href="#三、参数式方程" class="headerlink" title="三、参数式方程"></a>三、参数式方程</h4><p>令$\displaystyle\frac{x-x_0}{m}=\frac{y-y_0}{n}=\frac{z-z_0}{p}=t$，则L的参数式方程为L：$\begin{cases}x=x_0+mt\\y=y_0+nt\\z=z_0+pt\end{cases}$</p><p>点向式和参数式是可以相互转化的</p><h4 id="四、两直线的夹角"><a href="#四、两直线的夹角" class="headerlink" title="四、两直线的夹角"></a>四、两直线的夹角</h4><p><strong>回顾：</strong>两向量：$\displaystyle\cos\theta=\frac{\vec{a}·\vec{b}}{|\vec a||\vec b|}$两平面：$\displaystyle\cos\theta=\frac{|\vec{n_1}·\vec{n_2}|}{|\vec {n_1}||\vec {n_2}|}$</p><p>两直线：$\displaystyle\cos\theta=\frac{|\vec{s_1}·\vec{s_2}|}{|\vec {s_1}||\vec {s_2}|}$</p><h4 id="五、直线与平面的夹角"><a href="#五、直线与平面的夹角" class="headerlink" title="五、直线与平面的夹角"></a>五、直线与平面的夹角</h4><p>$\displaystyle\sin\theta=|\cos(\widehat{\vec n,\vec s})|=\frac{|\vec{n}·\vec{s}|}{|\vec {n}||\vec {s}|}$</p><h4 id="六、平面束"><a href="#六、平面束" class="headerlink" title="六、平面束"></a>六、平面束</h4><p>通过定直线的所有平面的全体称为<strong>平面束</strong></p><p>设L:$\begin{cases}A_1x+B_1y+C_1z+D_1=0\\A_2x+B_2y+C_2z+D_2=0\end{cases}$</p><p>则过L的平面束方程为$\Pi:A_1x+B_1y+C_1z+D_1+\lambda(A_2x+B_2y+C_2z+D_2)=0$</p><center><span style="color:blue;font-size:15px">2021/5/19</span></center><h3 id="第五节-曲面及其方程"><a href="#第五节-曲面及其方程" class="headerlink" title="第五节 曲面及其方程"></a>第五节 曲面及其方程</h3><h4 id="一、柱面"><a href="#一、柱面" class="headerlink" title="一、柱面"></a>一、柱面</h4><p>一般地，只含x,y而缺z的方程F(x,y)=0在空间直角坐标系中表示<strong>母线</strong>平行于z轴的<strong>柱面</strong>，其<strong>准线</strong>是xOy面上的曲线C：F(x,y)=0</p><h4 id="二、旋转曲面"><a href="#二、旋转曲面" class="headerlink" title="二、旋转曲面"></a>二、旋转曲面</h4><p>以一条平面曲线绕其平面上的一条直线旋转一周所成的曲面叫做<strong>旋转曲面</strong>，旋转曲线和定直线叫做旋转曲面的<strong>母线</strong>和<strong>轴</strong></p><p>在xoy面上的曲线$F(x,y)=0$绕x轴旋转一周而成的曲面为$F(x,\pm \sqrt{y^2+z^2})$</p><p>其他同理</p><h4 id="三、二次曲面"><a href="#三、二次曲面" class="headerlink" title="三、二次曲面"></a>三、二次曲面</h4><ul><li>椭圆锥面：$\displaystyle \frac{x^2}{a^2}+\frac{y^2}{b^2}=z^2$</li><li>椭球面：$\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1$</li><li>单叶双曲面：$\displaystyle \frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1$（在xoz平面上的双曲线绕z轴旋转）</li><li>双叶双曲面：$\displaystyle \frac{x^2}{a^2}-\frac{y^2}{b^2}-\frac{z^2}{c^2}=1$（在xoz平面上的双曲线绕x轴旋转）</li><li>椭圆抛物面：$\displaystyle \frac{x^2}{a^2}+\frac{y^2}{b^2}=z$</li><li>双曲抛物面（马鞍面）：$\displaystyle \frac{x^2}{a^2}-\frac{y^2}{b^2}=z$</li></ul><h3 id="第六节-空间曲线及其方程"><a href="#第六节-空间曲线及其方程" class="headerlink" title="第六节 空间曲线及其方程"></a>第六节 空间曲线及其方程</h3><h4 id="一、空间曲线的一般式方程"><a href="#一、空间曲线的一般式方程" class="headerlink" title="一、空间曲线的一般式方程"></a>一、空间曲线的一般式方程</h4><p>L:$\begin{cases}F(x,y,z)=0\\G(x,y,z)=0\end{cases}$(两个曲面的相交线)</p><h4 id="二、空间曲线的参数方程"><a href="#二、空间曲线的参数方程" class="headerlink" title="二、空间曲线的参数方程"></a>二、空间曲线的参数方程</h4><p>L:$\begin{cases}x=x(t)\\y=y(t)\\z=z(t)\end{cases}$，例如螺旋线：$\begin{cases}x=a\cos \omega t\\y=a\sin \omega t\\z=vt\end{cases}$</p><h4 id="三、空间曲线在坐标面上的投影"><a href="#三、空间曲线在坐标面上的投影" class="headerlink" title="三、空间曲线在坐标面上的投影"></a>三、空间曲线在坐标面上的投影</h4><p>由曲线的一般式消去变量z后（如果可能的话）得到的方程H(x,y)=0是一个品行与z轴的柱面</p><p>L:$\begin{cases}H(x,y)=0\\z=0\end{cases}$就是空间曲线在xoy面上的投影</p><h2 id="第九章-多元函数微分法及其应用"><a href="#第九章-多元函数微分法及其应用" class="headerlink" title="第九章 多元函数微分法及其应用"></a>第九章 多元函数微分法及其应用</h2><p>本章将在一元函数微分学的基础上，讨论多元函数的微分法及其应用</p><h3 id="第一节-多元函数的基本概念"><a href="#第一节-多元函数的基本概念" class="headerlink" title="第一节 多元函数的基本概念"></a>第一节 多元函数的基本概念</h3><p>本节知识现阶段研究有限，不是重点，掌握基本方法即可</p><h4 id="一、平面点集和n维空间"><a href="#一、平面点集和n维空间" class="headerlink" title="一、平面点集和n维空间"></a>一、平面点集和n维空间</h4><p>考研不要求</p><h4 id="二、多元函数的概念"><a href="#二、多元函数的概念" class="headerlink" title="二、多元函数的概念"></a>二、多元函数的概念</h4><p>若在区域D上任意的(x,y)都存在唯一的z与(x,y)对应，称z为(x,y)的函数，记z=f(x,y)</p><p>D为定义域，值域$R=\{z|z=f(x,y),(x,y)\in D\}$</p><h4 id="三、多元函数的极限"><a href="#三、多元函数的极限" class="headerlink" title="三、多元函数的极限"></a>三、多元函数的极限</h4><p><span style="color:red;font-size:20px">定义：</span>设$f(x,y)$在点$M_0 (x_0,y_0)$的某个去心领域内有定义（聚点），若$\forall\varepsilon&gt;0$，$\exists\delta&gt;0$，</p><p>当$0&lt;\sqrt{(x-x_0)^2+(y-y_0)^2}&lt;\delta$时，恒有$|f(x)-A|&lt;\varepsilon$，则称A为$(x,y)\to (x_0,y_0)$时$f(x,y)$的极限</p><p><strong>note：</strong>这里没有左右极限的概念，因为实际上有无数个方向，必须每个方向的极限值都存在且相等该点才有极限</p><h4 id="四、多元函数的连续性和性质"><a href="#四、多元函数的连续性和性质" class="headerlink" title="四、多元函数的连续性和性质"></a>四、多元函数的连续性和性质</h4><p><span style="color:red;font-size:20px">定义（连续性）：</span>设二元函数$f(x,y)$的定义域为D，$P_0(x_0,y_0)$为定义域上的一点，如果</p><p>$\displaystyle\lim_{(x,y)\to(x_0,y_0)}f(x,y)=f(x_0,y_0)$那么称函数$f(x,y)$在点$P_0(x_0,y_0)$处连续</p><p><strong>note：</strong>有界闭区域对于一元函数的闭区间</p><p><span style="color:sienna;font-size:20px">性质1（有界性和最大值最小值定理）：</span>在有界闭区域D上的多元连续函数，必定在D上有界，并且能取到它的最大值和最小值</p><p><span style="color:sienna;font-size:20px">性质2（介值定理）：</span>在有界闭区域D上的多元连续函数必取得介于最大值和最小值之间的任何值</p><h3 id="第二节-偏导数"><a href="#第二节-偏导数" class="headerlink" title="第二节 偏导数"></a>第二节 偏导数</h3><h4 id="一、偏导数的定义及其计算法"><a href="#一、偏导数的定义及其计算法" class="headerlink" title="一、偏导数的定义及其计算法"></a>一、偏导数的定义及其计算法</h4><p><span style="color:red;font-size:20px">定义：</span>$设函数z=f(x,y)在点(x_0,y_0)的某一邻域内有定义$</p><p>如果$\displaystyle \lim_{\triangle x\to 0}\frac{f(x_0+\triangle x,y_0)-f(x_0,y_0)}{\triangle x}$存在，那么称此极限为函数z=f(x,y)在点$(x_0,y_0)$处对x的<strong>偏导数</strong></p><p>如果函数z=f(x,y)在区域D内每一点(x,y)处对x的偏导数都存在，那么这个偏导数就是x、y的函数，它就称为函数z=f(x,y)对自变量x的<strong>偏导函数</strong>，记作$\frac{\partial z}{\partial x},\frac{\partial f}{\partial x},z_x或f_x(x,y),其他同理$</p><p><strong>note：</strong>对于多元函数来说，即使各偏导数在某点都存在，也不能保证函数在该点连续（一元函数左导数右导数存在且相等就可导，连续）。这是因为各偏导数存在只能保证点P沿着平行于坐标轴的方向趋于$P_0$ ，但不能保证点P按任何方式趋于$P_0$时，函数值f(P)都趋于$f(P_0)$。</p><h4 id="二、高阶偏导数"><a href="#二、高阶偏导数" class="headerlink" title="二、高阶偏导数"></a>二、高阶偏导数</h4><p>二阶及二阶以上的偏导数统称为高阶偏导数</p><p>设函数z=f(x,y)在区域D内具有偏导数$\displaystyle\frac{\partial z}{\partial x}=f_x(x,y),\frac{\partial z}{\partial y}=f_y(x,y)$<br>于是在D内$f_x(x,y),f_y(x,y)$都是x，y的函数。如果这两个函数的偏导数也存在，那么称它们是函数z=f(x,y)的<strong>二阶偏导数</strong>。按照对变量求导次序的不同有四个二阶偏导数：</p><p>f(x,y)对x的二阶偏导数：$\displaystyle\frac{\partial }{\partial x}(\frac{\partial z}{\partial x})=\frac{\partial^2 z}{\partial x^2}=f_{xx}(x,y)$</p><p>f(x,y)对x，y的二阶混合偏导数：$\displaystyle\frac{\partial }{\partial y}(\frac{\partial z}{\partial x})=\frac{\partial^2 z}{\partial x\partial y}=f_{xy}(x,y)$</p><p>f(x,y)对y，x的二阶混合偏导数：$\displaystyle\frac{\partial }{\partial x}(\frac{\partial z}{\partial y})=\frac{\partial^2 z}{\partial y\partial x}=f_{yx}(x,y)$</p><p>f(x,y)对y的二阶偏导数：$\displaystyle\frac{\partial }{\partial y}(\frac{\partial z}{\partial y})=\frac{\partial^2 z}{\partial y^2}=f_{yy}(x,y)$</p><p><span style="color:blue;font-size:20px">定理：</span>如果函数z=f(x,y)的两个二阶混合偏导数$\frac{\partial^2 z}{\partial x\partial y}$及$\frac{\partial^2 z}{\partial y\partial x}$在区域D内连续，那么在该区域内这两个二阶混合偏导数必相等</p><center><span style="color:blue;font-size:15px">2021/5/20</span></center><h3 id="第三节-全微分"><a href="#第三节-全微分" class="headerlink" title="第三节 全微分"></a>第三节 全微分</h3><h4 id="一、全微分的定义"><a href="#一、全微分的定义" class="headerlink" title="一、全微分的定义"></a>一、全微分的定义</h4><p><img src="/images/tongji-calculus-8-10/image-20210520111858542.png" alt=""></p><p><span style="color:blue;font-size:20px">定理1：</span><script type="math/tex">\displaystyle如果函数z= f(x,y)在点(x, y)处可微，则该函数在点(x,y)的偏导数\frac{\partial z}{\partial x}与\frac{\partial z}{\partial y}必定存在，且\\\displaystyle dz=\frac{\partial z}{\partial x}\triangle x+\frac{\partial z}{\partial x}\triangle y\qquad(A=\frac{\partial z}{\partial x},B=\frac{\partial z}{\partial y})\qquad(可微\Rightarrow可偏导)</script></p><blockquote><p> $连续\not\Rightarrow可微$</p><p> $可偏导\not\Rightarrow可微$</p><p> 自己的理解：可微是二维的，针对各个方向的（除了x，y轴还对其他方向求增量），而可偏导仅仅是对于x轴和y轴两个方向，条件太弱了</p></blockquote><p>例：<script type="math/tex">f(x,y)=\begin{cases}\frac{xy}{\sqrt{x^2+y^2}}\quad(x,y)\not=(0,0)\\0\qquad\qquad(x,y)=(0,0)\end{cases}</script>在点(0,0)处可偏导，但不可微</p><iframe src="https://ggb123.cn/calculator/jshh4k9r?embed" width="700" height="600" allowfullscreen="" style="border: 1px solid #e4e4e4;border-radius: 4px;" frameborder="0"></iframe><p>证：<br>可偏导：<script type="math/tex">f_x(0,0)=\displaystyle \lim_{x\to 0}\frac{f(x,0)-f(0,0)}{x}=\lim_{x\to 0}\frac{\frac{0}{|x|}-0}{x}=0</script>，同理对y的偏导也存在</p><p>可微：<script type="math/tex">\displaystyle \triangle z=f(0+\triangle x,0+\triangle y)-f(0,0)=\frac{\triangle x \triangle y}{\sqrt{(\triangle x)^2+(\triangle y)^2}}\\若可微，则\triangle z=A\triangle x+B\triangle y+o(\rho)\\\displaystyle因为A=f_x(0,0),B=f_y(0,0)所以\triangle z可写作0+0+\frac{\triangle x \triangle y}{\sqrt{(\triangle x)^2+(\triangle y)^2}}\\\displaystyle因为\lim_{\rho\to 0}\frac{\frac{\triangle x \triangle y}{\sqrt{(\triangle x)^2+(\triangle y)^2}}}{\rho}=\lim_{(\triangle x,\triangle y)\to (0,0)}\frac{\frac{\triangle x \triangle y}{\sqrt{(\triangle x)^2+(\triangle y)^2}} }{\sqrt{(\triangle x)^2+(\triangle y)^2}}=\lim_{(\triangle x,\triangle y)\to (0,0)}\frac{ {\triangle x \triangle y} } {(\triangle x)^2+(\triangle y)^2}不存在\\\displaystyle所以\frac{\triangle x \triangle y}{\sqrt{(\triangle x)^2+(\triangle y)^2} }不是\rho的高阶无穷小，所以不可微</script></p><p><span style="color:blue;font-size:20px">定理2：</span> 如果函数z= f(x,y)的偏导数$\displaystyle\frac{\partial z}{\partial x},\frac{\partial z}{\partial y}$在点$(x_0,y_0)$处连续（二维上），则函数在该点可微（加减项把全增量写成偏增量然后用拉格朗日中值定理证明）</p><h4 id="二、内容小结"><a href="#二、内容小结" class="headerlink" title="二、内容小结"></a>二、内容小结</h4><p><img src="/images/tongji-calculus-8-10/image-20210520160432110.png" alt=""></p><h3 id="第四节-多元复合函数的求导法则"><a href="#第四节-多元复合函数的求导法则" class="headerlink" title="第四节 多元复合函数的求导法则"></a>第四节 多元复合函数的求导法则</h3><p><span style="color:blue;font-size:20px">定理：</span> <script type="math/tex">设u=u(x,y)，v=v(x,y)在点(x,y)处有对x及对y的偏导数，\\函数z=f(u,v)在对应点(u,v)处有连续偏导数,\\则z= f[u(x,y),v(x,y)]在点(x,y)处的两个偏导数存在，且有\\\displaystyle\frac{\partial z}{\partial x}=\displaystyle\frac{\partial z}{\partial u}\displaystyle\frac{\partial u}{\partial x}+\displaystyle\frac{\partial z}{\partial v}\displaystyle\frac{\partial v}{\partial x}</script></p><h4 id="全微分形式的不变性："><a href="#全微分形式的不变性：" class="headerlink" title="全微分形式的不变性："></a>全微分形式的不变性：</h4><p><img src="/images/tongji-calculus-8-10/image-20210520215445626.png" alt=""></p><center><span style="color:blue;font-size:15px">2021/5/21</span></center><h3 id="第五节-隐函数的求导公式"><a href="#第五节-隐函数的求导公式" class="headerlink" title="第五节 隐函数的求导公式"></a>第五节 隐函数的求导公式</h3><p><span style="color:blue;font-size:20px">定理（隐函数存在定理）：</span> </p><p>:<script type="math/tex">\\设函数F(x,y)在点P(x_0,y_0)的某一领域内具有连续偏导数，且F(x_0,y_0)=0，F_y(x_0,y_0)\not=0，\\则方程F(x,y)=0在点(x_0,y_0)的某一邻域内恒能确定一个连续且具有连续导数的函数y=f(x),\\它满足条件y_0=f(x_0)，并由\displaystyle\frac{dy}{dx}=-\frac{F_x}{F_y}</script></p><p><strong>有几个方程，就有几个函数（受约束），剩下的字母都是自变量（独立变化）</strong></p><p><strong>如果只有 一个方程，可以对自变量求(偏)导直接求得</strong></p><p><strong>如果有两个方程，对自变量求(偏)导后用雅可比行列式求得</strong></p><p><strong>例：</strong><script type="math/tex">\displaystyle\begin{cases}xu+yv=1\\x^2+y^2+u^2+v^2=6\end{cases},求\frac{\partial u}{\partial x},\frac{\partial u}{\partial y},\frac{\partial v}{\partial x},\frac{\partial v}{\partial x}</script></p><p>有两个方程，所以有两个函数，由题目得u和v是x和y的函数，即$\displaystyle\begin{cases}u=u(x,y)\\v=v(x,y)\end{cases}$</p><p>分别对x求偏导，得<script type="math/tex">\displaystyle\begin{cases}u+x\frac{\partial u}{\partial x}+y\frac{\partial v}{\partial x}=0\\2x+2u\frac{\partial u}{\partial x}+2v\frac{\partial v}{\partial x}=0\end{cases}\Rightarrow\begin{cases}x\frac{\partial u}{\partial x}+y\frac{\partial v}{\partial x}=-u\\u\frac{\partial u}{\partial x}+v\frac{\partial v}{\partial x}=-x\end{cases}</script></p><p>$D=\begin{vmatrix}x&amp;y\\u&amp;v\end{vmatrix}=xv-yu,D_1=\begin{vmatrix}-u&amp;y\\ -x&amp;v\end{vmatrix}=xy-uv,D_2=\begin{vmatrix}x&amp;-u\\u&amp;-x\end{vmatrix}=u^2-x^2$</p><p>$\displaystyle\frac{\partial u}{\partial x}=\frac{D_1}{D}=\frac{xy-uv}{xv-yu},\qquad\frac{\partial v}{\partial x}=\frac{D_2}{D}=\frac{u^2-x^2}{xv-yu}$，对y求偏导同理</p><h3 id="第六节-多元函数微分学的几何应用"><a href="#第六节-多元函数微分学的几何应用" class="headerlink" title="第六节 多元函数微分学的几何应用"></a>第六节 多元函数微分学的几何应用</h3><h4 id="一、空间曲线的切线与法平面"><a href="#一、空间曲线的切线与法平面" class="headerlink" title="一、空间曲线的切线与法平面"></a>一、空间曲线的切线与法平面</h4><p><strong>参数方程形式：</strong>$L:\displaystyle\begin{cases}x=\varphi(t)\\y=\psi(t)\\z=\omega(t)\end{cases}$</p><p>$\vec T=\{\varphi^{\prime}(t_0),\psi^{\prime}(t_0),\omega^{\prime}(t_0) \}$为曲线的切向量</p><ul><li>切线：$\displaystyle\frac{x-x_0}{\varphi ‘(t_0)}=\frac{y-y_0}{\psi ‘(t_0)}=\frac{z-z_0}{\omega ‘(t_0)}$</li><li>法平面：$(x-x_0)\varphi ‘(t_0)+(y-y_0)\psi ‘(t_0)+(z-z_0)\omega ‘(t_0)=0$</li></ul><p><strong>一般式：</strong>$L:\displaystyle\begin{cases}F(x,y,z)=0\\G(x,y,z)=0\end{cases}$</p><p>$\vec T=\begin{Bmatrix}\vec i&amp;\vec j&amp;\vec k\\F_x&amp;F_y&amp;F_k\\G_x&amp;G_y&amp;G_z\end{Bmatrix}(实际上是两个空间曲面的法向量的叉乘)$</p><h4 id="二、曲面的切平面与法线"><a href="#二、曲面的切平面与法线" class="headerlink" title="二、曲面的切平面与法线"></a>二、曲面的切平面与法线</h4><p>$\Pi:F(x,y,z)=0的法向量\vec n=\{F_x,F_y,F_z\}$</p><h3 id="第七节-方向导数和梯度"><a href="#第七节-方向导数和梯度" class="headerlink" title="第七节 方向导数和梯度"></a>第七节 方向导数和梯度</h3><h4 id="一、方向导数"><a href="#一、方向导数" class="headerlink" title="一、方向导数"></a>一、方向导数</h4><p>偏导数反映的是函数沿坐标轴方向的变化率，方向导数反映的是函数沿任一指定方向的变化率问题</p><p><span style="color:blue;font-size:20px">定理：</span><script type="math/tex">如果函数f(x,y)在点P_0(x_0,y_0)可微，那么函数在该点沿任一方向l的方向导数存在，且有\\\displaystyle\frac{\partial f}{\partial l}_{(x_0,y_0)}=f_x(x_0,y_0)\cos\alpha+f_y(x_0,y_0)\cos\beta\\其中\cos\alpha和\cos\beta是方向l的方向余弦</script></p><p>按照定义的话，<script type="math/tex">\displaystyle \triangle z=f(x_0+\triangle x,y_0+\triangle y)-f(x_0,y_0);\qquad \rho=\sqrt{(\triangle x)^2+(\triangle y)^2};\qquad \lim_{\rho\to0}\frac{\triangle z}{\rho}=\frac{\partial f}{\partial l}_{(x_0,y_0)}</script></p><h4 id="二、梯度"><a href="#二、梯度" class="headerlink" title="二、梯度"></a>二、梯度</h4><p>$grad f(x_0,y_0)=\triangledown f(x_0,y_0)=f_x((x_0,y_0)\vec i+f_x((x_0,y_0)\vec j$</p><p>$对于三维函数F(x,y,z)=0（或f(x,y)-z=0）来说，梯度就是曲面法向量(f_x,f_y,-1)去掉z方向的分量,\\即函数在此点沿(f_x,f_y)就是z增长率最大的方向,很容易理解$</p><p>$\displaystyle\frac{\partial f}{\partial l}_{(x_0,y_0)}=grad f(x_0,y_0)·\vec{e_l}=|grad f(x_0,y_0)|\cos\theta$</p><p><img src="/images/tongji-calculus-8-10/image-20210521180716379.png" alt=""></p><p>θ=0：l与梯度方向相同（增长率最大方向）</p><p>θ=π/2：l垂直于梯度，变化率为0，</p><p>θ=π：l与梯度方向相反（下降率最大方向）</p><h3 id="第八节-多元函数的极值及其求法"><a href="#第八节-多元函数的极值及其求法" class="headerlink" title="第八节 多元函数的极值及其求法"></a>第八节 多元函数的极值及其求法</h3><h4 id="一、多元函数的极值及最大值与最小值"><a href="#一、多元函数的极值及最大值与最小值" class="headerlink" title="一、多元函数的极值及最大值与最小值"></a>一、多元函数的极值及最大值与最小值</h4><p><span style="color:blue;font-size:20px">定理1（必要条件）：</span><script type="math/tex">设函数z=f(x,y)在点(x_0,y_0)具有偏导数，且在点(x_0,y_0)处有极值，则有\\f_x(x_0,y_0)=0,\qquad f_y(x_0,y_0)0=0</script></p><p><span style="color:blue;font-size:20px">定理2（充分条件）：</span><script type="math/tex">设函数z=f(x,y)在点(x_0,y_0)的某邻域内连续且有一阶及二阶连续偏导数，\\又f_x(x_0,y_0)=0,f_y(x_0,y_0)=0，令\\f_{xx}(x_0,y_0)=A,f_{xy}(x_0,y_0)=A,f_{yy}(x_0,y_0)=C\\则f(x,y)在(x_0,y_0)处是否取得极值的条件如下:\\(1)AC-B^2>0时具有极值，且当A<0时有极大值，当A>0时有极小值;\\(2)AC-B^2<0时没有极值\\(3)AC-B^2=0时不确定，暂时不讨论这种情况</script></p><p>如果个别点的偏导数不存在，也有可能是极值点，对这些点也应当考虑</p><h4 id="二、条件极值-拉格朗日乘数法"><a href="#二、条件极值-拉格朗日乘数法" class="headerlink" title="二、条件极值 拉格朗日乘数法"></a>二、条件极值 拉格朗日乘数法</h4><p>上面所讨论的极值问题，对于函数的自变量，除了限制在函数的定义域内以外，并无其他条件，所以有时称为<strong>无条件极值</strong>，但是实际问题中，有时会遇到对函数的自变量还有附加条件的极值问题，如求表面积为a^2而体积为最大的长方体的体积问题，这种对自变量有附加条件的极值称为<strong>条件极值</strong>，这种情况下就可以使用<strong>拉格朗日乘数法</strong></p><p><a href="https://www.zhihu.com/question/38586401">如何理解拉格朗日乘子法?</a></p><p><strong>case1：</strong><script type="math/tex">函数:z=f(x,y)\qquad 约束条件:\varphi(x,y)=0\\引入辅助函数F=f(x,y)+\lambda\varphi(x,y)\\令\begin{cases}F_x=f_x+\lambda\varphi_x=0\\F_y=f_y+\lambda\varphi_y=0\\F_{\lambda}=\varphi(x,y)=0\end{cases}\\即可解出若干组x，y为可能极值点</script></p><p><strong>case2：</strong>类似，三个自变量，两个约束条件，作辅助函数，使五个偏导等于0，解出x,y,z</p><center><span style="color:blue;font-size:15px">2021/5/24</span></center><h2 id="第十章-重积分"><a href="#第十章-重积分" class="headerlink" title="第十章 重积分"></a>第十章 重积分</h2><p>将和的极限的概念推广</p><h3 id="第一节-二重积分的概念与性质"><a href="#第一节-二重积分的概念与性质" class="headerlink" title="第一节 二重积分的概念与性质"></a>第一节 二重积分的概念与性质</h3><h4 id="一、二重积分的概念"><a href="#一、二重积分的概念" class="headerlink" title="一、二重积分的概念"></a>一、二重积分的概念</h4><p>1.曲顶柱体的体积</p><p>2.平面薄片的质量</p><p><span style="color:red;font-size:20px">定义：</span><script type="math/tex">设f(x,y)是有界闭区域D（xoy面上）上的有界函数，将闭区域D任意分成n个小闭区域\\\triangle\sigma_1,\triangle\sigma_2,...,\triangle\sigma_n,其中\triangle\sigma_i表示第i个小闭区域，也表示它的面积。\\\displaystyle在每个\triangle\sigma_i上任取一点(\xi_i,\eta_i),作\sum_{i=1}^n f(\xi_i,\eta_i)\triangle\sigma_i\\\displaystyle设\lambda为各个小闭区域中直径(闭区域中最远两点的距离)的最大值,\\若\displaystyle\lim_{\lambda\to 0}\sum_{i=1}^n f(\xi_i,\eta_i)\triangle\sigma_i存在\\则称此极限为f(x,y)在闭区域D上的二重积分，记作\\\displaystyle\mathop{\iint}\limits_Df(x,y)d\sigma=\lim_{\lambda\to 0}\sum_{i=1}^n f(\xi_i,\eta_i)\triangle\sigma_i\\如果在直角坐标系中用平行于坐标轴的直线网来划分D，可把二重积分记作\\\displaystyle\mathop{\iint}\limits_Df(x,y)dxdy</script></p><h4 id="二、二重积分的性质"><a href="#二、二重积分的性质" class="headerlink" title="二、二重积分的性质"></a>二、二重积分的性质</h4><p><span style="color:sienna;font-size:20px">性质1：</span>$\displaystyle\mathop{\iint}\limits_D[af(x,y)+bg(x,y)]d\sigma=a\mathop{\iint}\limits_Df(x,y)+b\mathop{\iint}\limits_Dg(x,y)$</p><p><span style="color:sienna;font-size:20px">性质2：</span>如果闭区域D被有限条曲线分为有限个部分闭区域，那么在D上的二重积分等于在各部分闭区域上的二重积分的和</p><p><span style="color:sienna;font-size:20px">性质3：</span>$\displaystyle\mathop{\iint}\limits_D1d\sigma=A（区域D的面积）$</p><p><span style="color:sienna;font-size:20px">性质4：</span>如果在D上，$f(x,y)\leq g(x.y)$，那么$\displaystyle\mathop{\iint}\limits_Df(x,y)d\sigma\leq\mathop{\iint}\limits_Dg(x,y)d\sigma$</p><p><span style="color:sienna;font-size:20px">性质5：</span>$\displaystyle|\mathop{\iint}\limits_Df(x,y)d\sigma|\leq\mathop{\iint}\limits_D|f(x,y)|d\sigma$</p><p><span style="color:sienna;font-size:20px">性质6（二重积分的中值定理）：</span>设函数f(x,y)在闭区域D上连续，则在D上至少存在一点$(\xi,\eta)$，使</p><p>$\displaystyle\mathop{\iint}\limits_Df(x,y)d\sigma=f(\xi,\eta)·A$</p><h3 id="第二节-二重积分的计算法"><a href="#第二节-二重积分的计算法" class="headerlink" title="第二节 二重积分的计算法"></a>第二节 二重积分的计算法</h3><p>本节介绍一种计算二重积分的方法，这种方法是把二重积分分化为两次单积分来计算</p><h4 id="一、利用直角坐标系计算二重积分"><a href="#一、利用直角坐标系计算二重积分" class="headerlink" title="一、利用直角坐标系计算二重积分"></a>一、利用直角坐标系计算二重积分</h4><p><img src="/images/tongji-calculus-8-10/image-20210524214946928.png" alt=""></p><p>Y型区域同理</p><h4 id="二、利用极坐标计算二重积分"><a href="#二、利用极坐标计算二重积分" class="headerlink" title="二、利用极坐标计算二重积分"></a>二、利用极坐标计算二重积分</h4><p>可能的特征(需要使用的情况)</p><ul><li>区域D的边界含有$x^2+y^2$</li><li>f(x,y)含有$x^2+y^2$</li></ul><p><img src="/images/tongji-calculus-8-10/image-20210524223958287.png" alt=""></p><p>=<script type="math/tex">\displaystyle\mathop{\iint}\limits_Df(x,y)d\sigma=\int^\beta _\alpha d\theta\int^{r_2(\theta)}_{r_1(\theta)}r·f(r\cos\theta,r\sin\theta)dr</script></p><center><span style="color:blue;font-size:15px">2021/5/25</span></center><h3 id="第三节-三重积分"><a href="#第三节-三重积分" class="headerlink" title="第三节 三重积分"></a>第三节 三重积分</h3><h4 id="一、三重积分的概念"><a href="#一、三重积分的概念" class="headerlink" title="一、三重积分的概念"></a>一、三重积分的概念</h4><p> 定积分及二重积分作为和的极限的概念，可以很自然地推广到三重积分</p><p>积分域$\Omega$为空间有界闭区域</p><p><span style="color:red;font-size:20px">定义：</span><script type="math/tex">\displaystyle\mathop{\iiint}\limits_\Omega f(x,y,z)dv=\lim_{\lambda\to 0}\sum_{i=1}^n f(\xi_i,\eta_i,\zeta_i)\triangle v_i</script></p><h4 id="二、三重积分的计算"><a href="#二、三重积分的计算" class="headerlink" title="二、三重积分的计算"></a>二、三重积分的计算</h4><p>计算三重积分的基本方法是将三重积分化为三次积分来计算</p><p><strong>1.利用直角坐标计算三重积分</strong></p><p><strong>先单后重（铅直投影法）：</strong></p><script type="math/tex; mode=display">\Omega=\{(x,y,z)|z_1(x,y)\leq z\leq z_2(x,y),(x,y)\in D_{xy}\}</script><p>$D_{xy}$为空间积分域在xoy平面上的投影</p><p>先对z做单积分，再做对xy的重积分</p><p>假如闭区域$D_{xy}=\{(x,y)|y_1(x)\leq y\leq y_2(x),a\leq x\leq b\}$</p><script type="math/tex; mode=display">\displaystyle\mathop{\iiint}\limits_\Omega f(x,y,z)dv=\int^a_bdx\int^{y_2(x)}_{y_1(x)}dy\int^{z_2(x,y)}_{z_1(x,y)}f(x,y,z)dz</script><p>就把三重积分化为先对z，再对y，再对x的三次积分（先单后重）</p><p><strong>先重后单（切片法）：</strong></p><script type="math/tex; mode=display">\Omega=\{(x,y,z)|(x,y)\in D_z，c\leq z\leq d\}</script><p>$D_z$是竖坐标为z的平面截闭区域$\Omega$所得到的一个平面闭区域</p><p>先对xy做重积分，再对z做定积分，有</p><script type="math/tex; mode=display">\displaystyle\mathop{\iiint}\limits_\Omega f(x,y,z)dv=\int^d_cdz\mathop{\iint}\limits_{D_z} f(x,y,z)dxdy</script><p><strong>2.利用柱面坐标计算三重积分</strong></p><p><strong>其实就是先单后重，重的部分用极坐标形式</strong></p><p>可能的特征(需要使用的情况)</p><ul><li>区域$\Omega$的边界含有$x^2+y^2$</li><li>f(x,y,z)含有$x^2+y^2$</li></ul><script type="math/tex; mode=display">\Omega=\{(x,y,z)|z_1(x,y)\leq z\leq z_2(x,y),(x,y)\in D_{xy}\}</script><p>作变换$\begin{cases}x=\rho\cos\theta\\y=\rho\sin\theta\\z=z\end{cases},dv=\rho·d\rho d\theta dz$</p><p><img src="/images/tongji-calculus-8-10/image-20210525163301667.png" alt=""></p><script type="math/tex; mode=display">\displaystyle\mathop{\iiint}\limits_\Omega f(x,y,z)dv=\mathop{\iiint}\limits_\Omega f(\rho\cos\theta,\rho\sin\theta,z)\rho·d\rho d\theta dz</script><p><strong>3.利用球面坐标计算三重积分</strong></p><p>可能的特征(需要使用的情况)</p><ul><li>区域$\Omega$的边界含有$x^2+y^2+z^2$</li><li>f(x,y,z)含有$x^2+y^2+y^2$</li></ul><p>作变换$\begin{cases}x=r\sin\varphi\cos\theta\\y=r\sin\varphi\sin\theta\\z=r\cos\varphi\end{cases},dv=r^2\sin\varphi ·drd\theta d\varphi$</p><p><img src="/images/tongji-calculus-8-10/image-20210525171922874.png" alt=""></p><p><img src="/images/tongji-calculus-8-10/image-20210525171518763.png" alt=""></p><script type="math/tex; mode=display">\displaystyle\mathop{\iiint}\limits_\Omega f(x,y,z)dv=\mathop{\iiint}\limits_\Omega f(r\sin\varphi\cos\theta,r\sin\varphi\sin\theta,r\cos\varphi)r^2\sin\varphi·dr d\varphi d\theta</script><h3 id="第四节-重积分的应用"><a href="#第四节-重积分的应用" class="headerlink" title="第四节 重积分的应用"></a>第四节 重积分的应用</h3><h4 id="一、曲面的面积"><a href="#一、曲面的面积" class="headerlink" title="一、曲面的面积"></a>一、曲面的面积</h4><p>设曲面的方程$z=f(x,y)$，则曲面上一点的法向量$\vec n$为$(-f_x,-f_y,1)(F=z-f(x,y)=0)$</p><p>$\displaystyle \cos \gamma=\frac{1}{\sqrt{1+f_x+f_y}},ds·\cos\gamma=d\sigma,ds=\sqrt{1+{f_x}^2+{f_y}^2}d\sigma$</p><p>$\displaystyle A=\mathop{\iint}\limits_Dds=\mathop{\iint}\limits_D \sqrt{1+{f_x}^2+{f_y}^2}d\sigma$</p><h4 id="二、质心"><a href="#二、质心" class="headerlink" title="二、质心"></a>二、质心</h4><p>二维情况：</p><p>$\displaystyle\overline x=\frac{M_y}{M}=\frac{\mathop{\iint}\limits_D x\rho(x,y)d\sigma}{\mathop{\iint}\limits_D \rho(x,y)d\sigma}\qquad \overline y=\frac{M_x}{M}=\frac{\mathop{\iint}\limits_D y\rho(x,y)d\sigma}{\mathop{\iint}\limits_D \rho(x,y)d\sigma}$</p><p>三维情况同理</p><h4 id="三、转动惯量"><a href="#三、转动惯量" class="headerlink" title="三、转动惯量"></a>三、转动惯量</h4><p>二维情况：</p><p>$I=\mathop{\iint}\limits_D r^2\rho(x,y)d\sigma$</p><p>三维情况同理</p><h4 id="四、引力-一质点对一物体"><a href="#四、引力-一质点对一物体" class="headerlink" title="四、引力(一质点对一物体)"></a>四、引力(一质点对一物体)</h4><p>$F=G\frac{Mm}{r^2}$</p><p>可积分算出各坐标轴的分量</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同济高数第七版（5-7章）</title>
      <link href="2021/05/07/tongji-calculus-5-7/"/>
      <url>2021/05/07/tongji-calculus-5-7/</url>
      
        <content type="html"><![CDATA[<center><span style="color:blue;font-size:15px">2021/5/7</span></center><h2 id="第五章-定积分"><a href="#第五章-定积分" class="headerlink" title="第五章 定积分"></a>第五章 定积分</h2><p>不定积分会求了，但是积分有什么用呢？本章解答</p><h3 id="第一节-定积分的概念与性质"><a href="#第一节-定积分的概念与性质" class="headerlink" title="第一节 定积分的概念与性质"></a>第一节 定积分的概念与性质</h3><h4 id="一、背景：一元不规则"><a href="#一、背景：一元不规则" class="headerlink" title="一、背景：一元不规则"></a>一、背景：一元不规则</h4><p>例：曲边梯形面积</p><h4 id="二、定积分的定义"><a href="#二、定积分的定义" class="headerlink" title="二、定积分的定义"></a>二、定积分的定义</h4><p><span style="color:blue;font-size:20px">定理：</span><script type="math/tex">设函数f(x)在[a,b]上有界\\1.(分)a=x_0<x_1<x_2<......<x_n=b\\ \triangle x_i=x_i-x_{i-1},1\leq i\leq n\\2.(近似值)\forall \xi_i\in[x_{i-1},xi]\\\triangle S_i=f(\xi_i)\triangle x_i(1\leq i\leq n)\\S\approx\displaystyle\sum^n_{i=1}f(\xi_i)\triangle x_i\\3.(精确值)\lambda=\max\{\triangle x_1,\triangle x_2,......\triangle x_n\}(\lambda 反映区间划分细腻程度)\\\displaystyle若\lim_{\lambda\to 0}\sum^n_{i=1}f(\xi_i)\triangle x_i存在，称这个极限为函数f(x)在[a,b]上的定积分，\\\displaystyle记作\int^b_af(x)dx，即\\\displaystyle\lim_{\lambda\to 0}\sum^n_{i=1}f(\xi_i)\triangle x_i=\int^b_af(x)dx</script></p><p><strong>note:</strong></p><p>1.<script type="math/tex">\displaystyle\lim_{\lambda\to 0}\sum^n_{i=1}f(\xi_i)\triangle x_i与[a,b]的分法及\xi_i的取法无关</script></p><p>2.f(x)在[a,b]上有界不一定可积</p><p><span style="color:blue;font-size:20px">定理：</span>若f(x)在[a,b]上连续，则f(x)在[a,b]上可积<br>若f(x)在[a,b]上只有有限个第一类间断点，则f(x)在[a,b]上可积</p><center><span style="color:blue;font-size:15px">2021/5/8</span></center><h4 id="三、定积分的一般性质"><a href="#三、定积分的一般性质" class="headerlink" title="三、定积分的一般性质"></a>三、定积分的一般性质</h4><p><strong>note:</strong></p><ul><li>$\int^a_af(x)dx=0$</li><li>$\int^b_af(x)dx=-\int^a_bf(x)dx$</li></ul><p><span style="color:sienna;font-size:20px">性质1：</span></p><ul><li>$\int^b_a[f(x)\pm g(x)]dx=\int^b_af(x)dx\pm\int^b_ag(x)dx$</li><li>$\int^b_akf(x)dx=k\int^b_af(x)dx$</li></ul><p><span style="color:sienna;font-size:20px">性质2：</span>$设a&lt;b,则\int^b_af(x)dx=\int^c_af(x)dx+\int^b_cf(x)dx$</p><p><span style="color:sienna;font-size:20px">性质3：</span>$\int^b_a1dx=b-a$</p><p><span style="color:sienna;font-size:20px">性质4：</span>$若在[a,b]上f(x)\geq0,则\int^b_af(x)dx\geq0$</p><p><span style="color:green;font-size:20px">推论1：</span>$若在[a,b]上f(x)\geq g(x),则\int^b_af(x)dx\geq\int^b_ag(x)dx$</p><p><span style="color:green;font-size:20px">推论2：</span>$|\int^b_af(x)dx|\leq\int^b_a|f(x)|dx$</p><p><span style="color:sienna;font-size:20px">性质5：</span>$设M和m分别是f(x)在区间[a,b]上的最大值和最小值，则\\m(b-a)\leq\int^b_af(x)dx\leq M(b-a)$</p><p><span style="color:sienna;font-size:20px">性质6（积分中值定理）：</span>$设函数f(x)在[a,b]上连续，则在[a,b]上至少存在一个点\xi，使\\\int^b_af(x)dx=f(\xi)(b-a)（使用介值定理的推论证明）\\其实\xi在(a,b)也成立,叫改进积分中值定理（使用拉格朗日中值定理证明）$</p><h3 id="第二节-积分基本公式"><a href="#第二节-积分基本公式" class="headerlink" title="第二节 积分基本公式"></a>第二节 积分基本公式</h3><p>只根据定义，很难求出定积分，我们寻找计算定积分的方法</p><h4 id="一、变限积分的函数"><a href="#一、变限积分的函数" class="headerlink" title="一、变限积分的函数"></a>一、变限积分的函数</h4><blockquote><p><strong>定积分由上下限和函数关系确定，与积分变量无关</strong></p><p>$\int^b_af(x)dx=\int^b_af(t)dt$</p><p>$\int^x_af(x)dx=\int^x_af(t)dt$</p><p>上面表达式中的x与上限的x不同</p><p>$\int^x_af(x,t)dt=\int^x_af(x,u)du$</p><p>上面表达式中的x与上限的x相同</p></blockquote><p>$定义积分上限的函数\phi(x)=\int^x_af(t)dt\quad x\in[a,b]$</p><p><span style="color:blue;font-size:20px">定理1：</span><script type="math/tex">设函数f(x)在[a,b]上连续，则\phi(x)=\int^x_af(t)dt在[a,b]上可导，并且\\\displaystyle\phi'(x)=\frac{d}{dx}\int^x_af(t)dt=f(x)\quad(a\leq x\leq b)</script></p><p><strong>note：</strong>$\displaystyle\frac{d}{dx}\int^{\varphi(x)}_af(t)dt=f[\varphi(x)]\varphi’(x)$</p><p><strong>更一般的结论：</strong><script type="math/tex">若\varphi(x),\psi(x)可导，f(x)连续，则\\\displaystyle\frac{d}{dx}\int^{\varphi(x)}_{\psi(x)}f(t)dt=f[\varphi(x)]\varphi'(x)-f[\psi(x)]\psi'(x)</script></p><p><span style="color:blue;font-size:20px">定理2：</span>$若函数f(x)在[a,b]上连续，则\phi(x)=\int^x_af(t)dt是f(x)在[a,b]上的一个原函数$</p><p>（这里的写法没有问题）</p><h4 id="二、牛顿——莱布尼兹公式"><a href="#二、牛顿——莱布尼兹公式" class="headerlink" title="二、牛顿——莱布尼兹公式"></a>二、牛顿——莱布尼兹公式</h4><p><span style="color:blue;font-size:20px">定理3（微积分基本定理）：</span><script type="math/tex">如果函数F(x)是连续函数f(x)在区间[a,b]上的一个原函数，那么\\\displaystyle\int^b_af(x)dx=F(b)-F(a)</script></p><p>证：<script type="math/tex">\phi(x)=\int^x_af(t)dt就是f(x)的一个原函数，\phi'(x)=f(x)\\\int^b_af(x)dx=\phi(b)-\phi(a)\\又因为\phi(x)-F(x)=C,\phi(x)=F(x)+C\\所以\int^b_af(x)dx=F(b)-F(a)+C-C=F(b)-F(a)</script></p><h4 id="改进积分中值定理"><a href="#改进积分中值定理" class="headerlink" title="改进积分中值定理"></a>改进积分中值定理</h4><p>设<script type="math/tex">函数f(x)在[a,b]上连续，则在(a,b)上至少存在一个点\xi，使\\\int^b_af(x)dx=f(\xi)(b-a)</script></p><p>证：<script type="math/tex">因为f(x)在[a,b]上连续，所以存在原函数，设为F(x)，所以有\\\displaystyle\int^b_af(x)dx=F(b)-F(a)\\显然F(x)在[a,b]满足微分中值定理的条件，所以在(a,b)内至少有一点\xi，使\\F(b)-F(b)=F'(\xi)(b-a)\\故\displaystyle\int^b_af(x)dx=f(\xi)(b-a)</script></p><center><span style="color:blue;font-size:15px">2021/5/9</span></center><h3 id="第三节-定积分的换元法和分部积分法"><a href="#第三节-定积分的换元法和分部积分法" class="headerlink" title="第三节 定积分的换元法和分部积分法"></a>第三节 定积分的换元法和分部积分法</h3><h4 id="一、定积分的换元法"><a href="#一、定积分的换元法" class="headerlink" title="一、定积分的换元法"></a>一、定积分的换元法</h4><p>定积分的换元法没有第一类和第二类之分，而且最后积分变量不需要变回x，只需要关注上下限和函数关系</p><p><span style="color:blue;font-size:20px">定理：</span><script type="math/tex">若f(x)在区间[a,b]上连续，函数x=\varphi(t)满足条件\\(1)\varphi(t)单调，且\varphi(\alpha)=a,\varphi(\beta)=b\\(2)x=\varphi(t)连续可导，则\\\displaystyle\int^b_af(x)dx=\int^\beta_\alpha f(\varphi(t))\varphi'(t)dt</script></p><p><strong>note1：</strong>当积分区间对称时，要想到</p><ul><li>$\int^a_{-a}f(x)dx=\int^a_0[f(x)+f(-x)]dx$</li><li>若f(x)为偶函数，则$\int^a_{-a}f(x)dx=2\int^a_0f(x)dx$</li><li>若f(x)为奇函数，则$\int^a_{-a}f(x)dx=0$</li></ul><p><span style="color:sienna;font-size:20px">性质1：</span><script type="math/tex">若f(x)在[0,1]上连续\\(1)\displaystyle\int^{\frac{\pi}{2}}_0f(\sin(x))dx=\int^{\frac{\pi}{2}}_0f(\cos(x))dx\\(1)\displaystyle\int^\pi_0xf(\sin(x))dx=\frac{\pi}{2}\int^\pi_0f(\sin(x))dx</script></p><p><strong>note2:</strong><script type="math/tex">(1)\int^0_{-a}f(x)dx\stackrel{x=-t}=\int^a_0f(-x)dx\\(2)\int^b_af(x)dx\stackrel{x+t=a+b}=\int^a_bf(x)dx\\(3)\int^{a+b}_af(x)dx\stackrel{x-a=t}=\int^b_0f(x)dx</script></p><p><span style="color:sienna;font-size:20px">性质2：</span><script type="math/tex">若f(x)是周期为T的连续函数，则\\(1)\displaystyle\int^{a+T}_af(x)dx=\int^T_0f(x)dx\\(2)\displaystyle\int^{nT}_0f(x)dx=n\int^T_0f(x)dx</script></p><h4 id="二、定积分的分部积分法"><a href="#二、定积分的分部积分法" class="headerlink" title="二、定积分的分部积分法"></a>二、定积分的分部积分法</h4><p>$\displaystyle\int^b_audv=uv|^b_a-\int^b_avdu$</p><p><strong>重要：</strong><script type="math/tex">\displaystyle I_n=\int^{\frac{\pi}{2}}_0\sin^n(x)dx\left(=\int^{\frac{\pi}{2}}_0\cos^n(x)dx\right)\\\displaystyle I_n=\frac{n-1}{n}I_{n-2}\\\displaystyle I_n=\frac{n-1}{n}*\frac{n-3}{n-2}*...*\frac{3}{4}*\frac{1}{2}*\frac{\pi}{2}\quad(n为正偶数)\\\displaystyle I_n=\frac{n-1}{n}*\frac{n-3}{n-2}*...*\frac{4}{5}*\frac{2}{3}\quad(n为大于1的正奇数)</script></p><p><img src="/images/tongji-calculus-5-7/image-20210509114132972.png" alt=""></p><h3 id="第四节-反常积分（广义积分）"><a href="#第四节-反常积分（广义积分）" class="headerlink" title="第四节 反常积分（广义积分）"></a>第四节 反常积分（广义积分）</h3><p>反常积分的本质是”变限积分的极限值”，并非积分本身。</p><p><strong>正常积分（可积）的标准：</strong></p><p>（1）区间有限（2）f(x)在有限区间上连续或有限个第一类间断点</p><p><strong>反常积分：</strong></p><h4 id="一、积分区间无限的反常积分"><a href="#一、积分区间无限的反常积分" class="headerlink" title="一、积分区间无限的反常积分"></a>一、积分区间无限的反常积分</h4><p>正常积分：$\int^b_af(x)dx=F(b)-F(a)$</p><p>反常积分：<script type="math/tex">\displaystyle\int^{+\infty}_af(x)dx=\lim_{b\to+\infty}\int^b_af(x)dx=\lim_{b\to+\infty}[F(b)-F(a)]</script></p><p><span style="color:red;font-size:20px">定义1：</span></p><p><strong>case1：</strong><script type="math/tex">设函数f(x)在区间[a,+\infty)上连续\\如果极限\displaystyle\lim_{b\to+\infty}\int^b_af(x)dx存在，称该反常积分收敛\\如果极限不存在，则称其发散</script></p><p><strong>case2：</strong>$设函数f(x)在区间(-\infty,b]上连续$</p><p><strong>case3：</strong>$设函数f(x)在区间(-\infty,+\infty)上连续$</p><h4 id="二、无界函数的反常积分"><a href="#二、无界函数的反常积分" class="headerlink" title="二、无界函数的反常积分"></a>二、无界函数的反常积分</h4><p>正常积分：$\int^b_af(x)dx=F(b)-F(a)$</p><p>反常积分：<script type="math/tex">\displaystyle\int^b_af(x)dx=\lim_{t\to a+}\int^b_tf(x)dx=\lim_{t\to a+}[F(b)-F(t)]</script></p><p><span style="color:red;font-size:20px">定义2：</span></p><p><strong>case1：</strong><script type="math/tex">设函数f(x)在区间[a,b)上连续,点a为f(x)的瑕点\\如果极限\displaystyle\lim_{t\to a+}\int^b_tf(x)dx存在，称该反常积分收敛\\如果极限不存在，则称其发散</script></p><p><strong>case2：</strong>$设函数f(x)在区间(a,b]上连续$</p><p><strong>case3：</strong>$设函数f(x)在区间[a,c)\cup(c,b]上连续$</p><h3 id="第五节-反常函数的审敛法-quad-Gamma-函数"><a href="#第五节-反常函数的审敛法-quad-Gamma-函数" class="headerlink" title="第五节 反常函数的审敛法 $\quad\Gamma$函数"></a>第五节 反常函数的审敛法 $\quad\Gamma$函数</h3><h4 id="一、无穷区间反常函数的审敛法"><a href="#一、无穷区间反常函数的审敛法" class="headerlink" title="一、无穷区间反常函数的审敛法"></a>一、无穷区间反常函数的审敛法</h4><p><strong>比较审敛原理：</strong><script type="math/tex">设函数f(x),g(x)在区间[a,+\infty)上连续，\\如果0\leq f(x)\leq g(x)(a\leq x<+\infty)，并且\int^{+\infty}_ag(x)dx收敛，那么\int^{+\infty}_af(x)dx也收敛\\如果0\leq g(x)\leq f(x)(a\leq x<+\infty)，并且\int^{+\infty}_ag(x)dx发散，那么\int^{+\infty}_af(x)dx也发散</script></p><p><strong>p积分：</strong><script type="math/tex">\displaystyle\int^{+\infty}_a\frac{dx}{x^p}(a>0)\\当p>1时收敛\\当p\leq1时发散</script></p><p><strong>比较判别法的极限形式：</strong><script type="math/tex">设f(x),g(x)在[a,+\infty)非负连续，\displaystyle\lim_{x\to+\infty}\frac{f(x)}{g(x)}=\lambda，则\\(1)当\lambda=c>0时，\int^{+\infty}_af(x)dx与\int^{+\infty}_ag(x)dx同敛散\\(2)当\lambda=0时，若\int^{+\infty}_ag(x)dx收敛，\int^{+\infty}_af(x)dx收敛\\(3)当\lambda=+\infty时，若\int^{+\infty}_ag(x)dx发散，\int^{+\infty}_af(x)dx发散</script></p><h4 id="二、无界函数积分的审敛准则"><a href="#二、无界函数积分的审敛准则" class="headerlink" title="二、无界函数积分的审敛准则"></a>二、无界函数积分的审敛准则</h4><p><strong>比较审敛原理：</strong><script type="math/tex">设函数f(x),g(x)在区间(a,b]上连续，\\如果0\leq f(x)\leq g(x)(a< x\leq b)，并且\int^b_ag(x)dx收敛，那么\int^b_af(x)dx也收敛\\如果0\leq g(x)\leq f(x)(a< x\leq b)，并且\int^b_ag(x)dx发散，那么\int^b_af(x)dx也发散</script></p><p><strong>p积分：</strong><script type="math/tex">a是间断点时，\displaystyle\int^b_a\frac{dx}{(x-a)^p}\\当p<1时收敛\\当p\geq1时发散\\b是间断点时，\displaystyle\int^b_a\frac{dx}{(b-a)^p}\\当p<1时收敛\\当p\geq1时发散</script></p><p><strong>比较判别法的极限形式：</strong><script type="math/tex">设f(x),g(x)在(a,b]非负连续，\displaystyle\lim_{x\to a+}\frac{f(x)}{g(x)}=\lambda，则\\(1)当\lambda=c>0时，\int^{b}_af(x)dx与\int^{b}_ag(x)dx同敛散\\(2)当\lambda=0时，若\int^{b}_ag(x)dx收敛，\int^{b}_af(x)dx收敛\\(3)当\lambda=+\infty时，若\int^{b}_ag(x)dx发散，\int^b_af(x)dx发散</script></p><h4 id="三、-Gamma-函数"><a href="#三、-Gamma-函数" class="headerlink" title="三、$\Gamma$函数"></a>三、$\Gamma$函数</h4><p>考研高数不考，但是在概率论中涉及</p><p><span style="color:red;font-size:20px">定义：</span>$\displaystyle\Gamma(s)=\int^{+\infty}_0x^{s-1}e^{-x}dx\qquad (s&gt;0)$</p><ul><li>$\Gamma(s+1)=s\Gamma(s)$</li><li>$\Gamma(s+1)=s!$</li><li>$\Gamma(\frac{1}{2})=\sqrt \pi$</li></ul><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p><img src="/images/tongji-calculus-5-7/image-20210510140859852.png" alt=""></p><p><strong>note：</strong><script type="math/tex">\displaystyle由右上角可知，在x\to+\infty时，\frac{1}{\ln x}>\frac{1}{x^p}>\frac{1}{e^x}，p可以取任意值\\\displaystyle当p>1时，\int^{+\infty}_1\frac{1}{x^p}收敛，所以\int^{+\infty}_1\frac{1}{e^x}\left(或\frac{x^a\ln ^nx}{e^{bx}}\right)是收敛的\\\displaystyle当p\leq1时，\int^{+\infty}_1\frac{1}{x^p}发散，所以\int^{+\infty}_2\frac{1}{\ln x}\left(或\frac{1}{\ln ^nx}\right)是发散的\\\displaystyle\int^{+\infty}_1\frac{\ln ^nx}{x^\alpha}(\alpha >1)也是收敛的</script></p><iframe src="https://www.desmos.com/calculator/yci00xdlr3" width="100%" height="500px" style="border: 1px solid #ccc" frameborder="0"></iframe><p><img src="/images/tongji-calculus-5-7/image-20210510151946627.png" alt=""></p><p><strong>note：</strong><script type="math/tex">当x\to0时，\displaystyle-\ln x=\ln\frac{1}{x}<\frac{1}{x^p}=(\frac{1}{x})^p<e^{\frac{1}{x}}，p可以取任意值\\\displaystyle当p<1时，\int^b_0\frac{1}{x^p}收敛，所以\int^b_0\ln x收敛\\\displaystyle当p\geq1时，\int^b_0\frac{1}{x^p}发散，所以\int^b_0e^{\frac{1}{x}}发散</script></p><center><span style="color:blue;font-size:15px">2021/5/13<span></span></span></center><h2 id="第六章-定积分的应用"><a href="#第六章-定积分的应用" class="headerlink" title="第六章 定积分的应用"></a>第六章 定积分的应用</h2><h3 id="第一节-定积分的元素法"><a href="#第一节-定积分的元素法" class="headerlink" title="第一节 定积分的元素法"></a>第一节 定积分的元素法</h3><p><strong>能用定积分解决的问题特征：</strong></p><p>（1）非均匀连续分布在[a,b]上的量。</p><p>（2）所求量对区间有可加性。</p><p><strong>元素法：</strong></p><p>（1）根据问题的实际情况，选取一个变量例如x为积分变量，并确定它的变化区间[a,b]</p><p>（2）设想把区间[a,b]分成n个小区间，取其中任一小区间并记作[x,x+dx]，求出对应于这个小区间的部分量$\triangle U$的近似值，如果$\triangle U$能近似地表示为[a,b]上的一个连续函数在x处的值f(x)与dx的乘积，就把f(x)dx称为量U的元素且记作dU，即</p><script type="math/tex; mode=display">dU=f(x)dx</script><p>（3）以所求量U的元素f(x)dx为被积表达式，在区间[a,b]上作定积分，得</p><script type="math/tex; mode=display">U=\displaystyle\int^b_af(x)dx</script><p>这就是所求量U的积分表达式</p><h3 id="第二节-定积分在几何上的应用"><a href="#第二节-定积分在几何上的应用" class="headerlink" title="第二节 定积分在几何上的应用"></a>第二节 定积分在几何上的应用</h3><h4 id="一、平面图形的面积"><a href="#一、平面图形的面积" class="headerlink" title="一、平面图形的面积"></a>一、平面图形的面积</h4><p>$椭圆\frac{x^2}{a^2}+\frac{y^2}{b^2}=1\qquad面积S=\pi ab$</p><p>1.直角坐标（对x或y积分）</p><p>2.极坐标（$ds=\frac{1}{2}r^2d\theta$）（$弧长L=\theta*R，扇形S=\frac{1}{2}LR=\frac{1}{2}R^2\theta$）</p><h4 id="二、体积"><a href="#二、体积" class="headerlink" title="二、体积"></a>二、体积</h4><p>1.旋转体的体积</p><p> $V_x=\pi\int^b_af^2(x)dx\qquad V_y=2\pi\int^b_axf(x)dx$</p><p>2.截口面积已知的几何体的体积</p><p>$V=\int^b_aS(x)dx$</p><h4 id="三、平面曲线的弧长"><a href="#三、平面曲线的弧长" class="headerlink" title="三、平面曲线的弧长"></a>三、平面曲线的弧长</h4><p>$\begin{aligned}ds&amp;=\sqrt{(dx)^2+(dy)^2}\\&amp;=\sqrt{1+(\frac{dy}{dx})^2}dx\\&amp;=\sqrt{1+f’^2(x)}dx\end{aligned}$</p><p>所以<script type="math/tex">\begin{aligned}s&=\int^b_a\sqrt{1+y'^2}dx\\&=\int^\beta_\alpha\sqrt{x'^2+y'^2}dt(参数方程）\\&=\int^\beta_\alpha\sqrt{\rho^2+\rho'^2}d\theta(极坐标，\rho=\rho(\theta)）\end{aligned}</script></p><h3 id="第三节-定积分在物理学上的应用"><a href="#第三节-定积分在物理学上的应用" class="headerlink" title="第三节 定积分在物理学上的应用"></a>第三节 定积分在物理学上的应用</h3><h4 id="一、功-变力沿直线做功"><a href="#一、功-变力沿直线做功" class="headerlink" title="一、功(变力沿直线做功)"></a>一、功(变力沿直线做功)</h4><p>$W=Fx$</p><p>$dW=F(x)dx$</p><h4 id="二、力"><a href="#二、力" class="headerlink" title="二、力"></a>二、力</h4><p>水的压强$p=\rho gh$</p><p>$dF=\rho gxldx$</p><p>引力$F=G\frac{Mm}{r^2}$</p><center><span style="color:blue;font-size:15px">2021/5/14<span></span></span></center><h2 id="第七章-微分方程"><a href="#第七章-微分方程" class="headerlink" title="第七章 微分方程"></a>第七章 微分方程</h2><p>微分方程+线性代数=泛函分析。连续函数可用幂函数表示出来，也就可用线性代数表示出来，微分和积分不过是一个施加在这个无穷维空间的一个线性变换。</p><p>在许多问题中，我们往往不能直接找出所需要的函数关系，而有时可以得到含有要找的函数及其导数的关系式，这样的关系式就是所谓的<strong>微分方程</strong>，简称方程，微分方程建立以后，对它进行研究，找出未知函数，就是<strong>解微分方程</strong>。</p><p>不同类型的微分方程要用不同的方法来做</p><h3 id="第一节-微分方程的基本概念"><a href="#第一节-微分方程的基本概念" class="headerlink" title="第一节 微分方程的基本概念"></a>第一节 微分方程的基本概念</h3><p><span style="color:red;font-size:20px">定义1：（微分方程）</span>凡表示<strong>未知函数</strong>、<strong>未知函数的导数</strong>与<strong>自变量</strong>之间的关系的方程，叫做<strong>微分方程</strong>，未知函数是一元函数的微分方程称作<strong>常微分方程</strong></p><p><span style="color:red;font-size:20px">定义2：（微分方程的阶）</span>微分方程中所出现的最高阶导数的阶数，叫做<strong>微分方程的阶</strong>（<strong>注意不要把次数和阶数混淆</strong>）<br>一般地，n阶微分方程的形式是$F(x,y,y’,…,y^{(n)})=0$，其中除了$y^{(n)}$外，其他变量可不出现</p><p><span style="color:red;font-size:20px">定义3：（微分方程的解）</span>若函数$y=f(x)$满足$F(x,y,y’,…,y^{(n)})=0$，这个函数就叫做<strong>微分方程的解</strong><br>若该方程的解中含n个<strong>相互独立</strong>的任意常数，称该解为<strong>通解</strong>，不含任意常数的解称为<strong>特解</strong></p><h3 id="第二节-可分离变量的微分方程（一种特定的一阶微分方程）"><a href="#第二节-可分离变量的微分方程（一种特定的一阶微分方程）" class="headerlink" title="第二节 可分离变量的微分方程（一种特定的一阶微分方程）"></a>第二节 可分离变量的微分方程（一种特定的一阶微分方程）</h3><p>如果一个一阶微分方程能写出$g(y)dy=f(x)dx$（或$\frac{dy}{dx}=f(x)g(x)$）的形式，则称其为<strong>可分离变量的微分方程</strong></p><p><strong>解法：</strong>两端求积分即可$\displaystyle\int g(y)dy=\int f(x)dx+C$</p><h3 id="第三节-（一阶）齐次微分方程-x和y齐次"><a href="#第三节-（一阶）齐次微分方程-x和y齐次" class="headerlink" title="第三节 （一阶）齐次微分方程(x和y齐次)"></a>第三节 （一阶）齐次微分方程(x和y齐次)</h3><blockquote><p>齐次：$f(ax,ay,…)=a^nf(x,y,…)$</p></blockquote><p>若一阶微分方程可化成$\displaystyle\frac{dy}{dx}=\varphi(\frac{y}{x})$的形式，那么称其为齐次方程$\displaystyle\left(f(ax,ay)=\varphi(\frac{ay}{ax})=a^0\varphi(\frac{y}{x})\right)$</p><p><strong>解法：</strong><script type="math/tex">引入u=\frac{y}{x},可以将其化为可分离变量的方程\\\displaystyle  y=ux,\frac{dy}{dx}=\frac{du}{dx}x+u=\varphi(u),\\可得\displaystyle\frac{du}{\varphi(u)-u}=\frac{dx}{x}\\\displaystyle两端积分可得\int\frac{du}{\varphi(u)-u}=\int\frac{dx}{x}+C\\求出积分后，再将u=\frac{y}{x}代回</script></p><h3 id="第四节-一阶线性微分方程"><a href="#第四节-一阶线性微分方程" class="headerlink" title="第四节 一阶线性微分方程"></a>第四节 一阶线性微分方程</h3><p>线性微分方程：（x，y，y’，y’’…都是一次幂）</p><p>形如$\displaystyle \frac{dy}{dx}+P(x)y=Q(x)$的方程叫做<strong>一阶线性微分方程</strong>，</p><p>如果Q(x)=0，那么该方程是<strong>齐次</strong>的（y和y’齐次），如果Q(x)$\not=$0，那么该方程是<strong>非齐次</strong>的</p><blockquote><p> :<script type="math/tex">Q(x)=0时:\displaystyle f(ay,ay')=a\frac{dy}{dx}+P(x)ay=af(y)\\Q(x)\not=0时:\displaystyle f(ay,ay')=a\frac{dy}{dx}+P(x)ay-Q(x)=a(\frac{dy}{dx}+P(x)y-\frac{Q(x)}{a})\not=af(y)</script></p><p>(自己想的，不一定对)</p></blockquote><h4 id="一、一阶齐次线性微分方程"><a href="#一、一阶齐次线性微分方程" class="headerlink" title="一、一阶齐次线性微分方程"></a>一、一阶齐次线性微分方程</h4><p>$\displaystyle \frac{dy}{dx}+P(x)y=0的通解为\\\displaystyle y=Ce^{-\int p(x)dx}$</p><h4 id="二、一阶非齐次微分方程"><a href="#二、一阶非齐次微分方程" class="headerlink" title="二、一阶非齐次微分方程"></a>二、一阶非齐次微分方程</h4><p>$\displaystyle \frac{dy}{dx}+P(x)y=Q(x)的通解为\\\displaystyle y=\left(\int Q(x)e^{\int p(x)dx}dx+C\right)e^{-\int p(x)dx}$</p><p><strong>(非齐次通解=齐次通解+一个非齐次特解)</strong></p><p><strong>note：</strong>有时用适当的变量代换可以将方程化为可分离变量的方程</p><h4 id="三、伯努利方程"><a href="#三、伯努利方程" class="headerlink" title="三、伯努利方程"></a>三、伯努利方程</h4><p>$\displaystyle \frac{dy}{dx}+P(x)y=Q(x)y^n(n\not=0,1)$叫做伯努利方程</p><p>伯努利方程不是线性的，但是通过变量的代换，可以化为线性方程</p><p>两边同除$y^n,得\displaystyle y^{-n}\frac{dy}{dx}+P(x)y^{1-n}=Q(x)$</p><p>即$\displaystyle \frac{d(y^{1-n})}{(1-n)dx}+P(x)y^{1-n}=Q(x)$</p><p>令$z=y^{1-n}，则\displaystyle\frac{dz}{dx}=(1-n)y^{-n}\frac{dy}{dx}$</p><p>有$\displaystyle \frac{dz}{dx}+(1-n)P(x)z=(1-n)Q(x)$（线性方程）</p><p>求出方程的通解后，用$z=y^{1-n}代换$</p><p><strong>例：</strong><script type="math/tex">\displaystyle\frac{dy}{dx}=\frac{1}{xy+x^2y^3}\\x与y对调\quad\displaystyle\frac{dx}{dy}=xy+x^2y^3(伯努利方程)\\\displaystyle\frac{1}{x^2}\displaystyle\frac{dy}{dx}=\frac{y}{x}+y^3\\\displaystyle令z=\frac{1}{x},得\frac{dz}{dy}=-\frac{1}{x^2}\frac{dx}{dy}\\\displaystyle-\frac{dz}{dy}-yz=y^3\Rightarrow \frac{dz}{dy}+yz=-y^3（线性微分方程）\\...</script></p><h3 id="第五节-可降阶的高阶微分方程"><a href="#第五节-可降阶的高阶微分方程" class="headerlink" title="第五节 可降阶的高阶微分方程"></a>第五节 可降阶的高阶微分方程</h3><p>二阶及二阶以上的微分方程就是高阶微分方程，下面介绍三种容易降阶的高阶微分方程</p><h4 id="一、-y-n-f-x-型的微分方程"><a href="#一、-y-n-f-x-型的微分方程" class="headerlink" title="一、$y^{(n)}=f(x)$型的微分方程"></a>一、$y^{(n)}=f(x)$型的微分方程</h4><p>对于<script type="math/tex">y^{(n)}=f(x)\\y^{(n-1)}=\int f(x)dx+C_1\\y^{(n-2)}=\int[f(x)dx+C_1]dx+C_2</script></p><p>连续积分n次即可得到带n个任意常数的通解</p><h4 id="二、-f-x-y’-y’’-0-qquad-缺y"><a href="#二、-f-x-y’-y’’-0-qquad-缺y" class="headerlink" title="二、$f(x,y’,y’’)=0\qquad(缺y)$"></a>二、$f(x,y’,y’’)=0\qquad(缺y)$</h4><p>设$\displaystyle y’=p，那么y’’=\frac{dp}{dx}$</p><h4 id="三、-f-y-y’-y’’-0-qquad-缺x"><a href="#三、-f-y-y’-y’’-0-qquad-缺x" class="headerlink" title="三、$f(y,y’,y’’)=0\qquad(缺x)$"></a>三、$f(y,y’,y’’)=0\qquad(缺x)$</h4><p>令$\displaystyle y’=p,y’’=\frac{dp}{dx}=\frac{dp}{dy}\frac{dy}{dx}=\frac{dp}{dy}p $</p><center><span style="color:blue;font-size:15px">2021/5/15<span></span></span></center><h3 id="第六节-高阶线性微分方程"><a href="#第六节-高阶线性微分方程" class="headerlink" title="第六节 高阶线性微分方程"></a>第六节 高阶线性微分方程</h3><h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><div class="table-container"><table><thead><tr><th>n阶齐次线性微分方程</th><th><script type="math/tex">y^{(n)}+a_1(x)y^{(n-1)}+...+a_{n-1}(x)y'+a_n(x)y=0</script></th></tr></thead><tbody><tr><td>n阶非齐次线性微分方程</td><td><script type="math/tex">y^{(n)}+a_1(x)y^{(n-1)}+...+a_{n-1}(x)y'+a_n(x)y=f(x)</script></td></tr></tbody></table></div><p>设f(x)，g(x)为两个函数<br>若f(x)，g(x)不成比例，称他们<strong>线性无关</strong><br>若f(x)，g(x)成比例，称他们<strong>线性相关</strong></p><h4 id="二、结构"><a href="#二、结构" class="headerlink" title="二、结构"></a>二、结构</h4><p>对于<script type="math/tex">y''+a(x)y'+b(x)y=0\qquad(1) 二阶齐次线性微分方程\\y''+a(x)y'+b(x)y=c(x)\qquad(2) 二阶非齐次线性微分方程</script></p><p><span style="color:blue;font-size:20px">定理1：</span>$若函数y_1(x)与y_2(x)是(1)的两个解，那么y=C_1y_1(x)+C_2y_2(x)也是(1)的解$</p><p><span style="color:blue;font-size:20px">定理2：</span>$若函数y_1(x)与y_2(x)分别为(1)(2)的解，那么y=y_1(x)+y_2(x)是(2)的解$</p><p><span style="color:blue;font-size:20px">定理3：</span>$若函数y_1(x)与y_2(x)是(2)的两个解，那么y=y_1(x)-y_2(x)是(1)的解$</p><p><span style="color:blue;font-size:20px">定理4：</span></p><ul><li>$若函数y_1(x)与y_2(x)是(1)的两个线性无关的特解，那么y=C_1y_1(x)+C_2y_2(x)是(1)的通解$</li><li>$若函数y_1(x)为(1)的通解，y_2(x)为(2)的一个特解，那么y=y_1(x)+y_2(x)是(2)的通解$</li></ul><p><span style="color:blue;font-size:20px">定理5：</span></p><p>对于<script type="math/tex">y''+a(x)y'+b(x)y=f_1(x)+f_2(x)\\若函数y_1(x)与y_2(x)分别是方程\\y''+a(x)y'+b(x)y=f_1(x)\\y''+a(x)y'+b(x)y=f_2(x)\\的一个特解，则y=y_1(x)+y_2(x)就是原方程的特解</script></p><h3 id="第七节-常系数齐次线性微分方程"><a href="#第七节-常系数齐次线性微分方程" class="headerlink" title="第七节 常系数齐次线性微分方程"></a>第七节 常系数齐次线性微分方程</h3><h4 id="一、二阶常系数齐次线性微分方程"><a href="#一、二阶常系数齐次线性微分方程" class="headerlink" title="一、二阶常系数齐次线性微分方程"></a>一、二阶常系数齐次线性微分方程</h4><p>$y’’+py’+qy=0\qquad(*)$</p><p>其中p，q为<strong>常数</strong>，称(*)为二阶常系数齐次线性微分方程</p><p>设$y=e^{\lambda x}为(*)的解，代入方程得$</p><p>$\lambda^2+p\lambda+q=0$</p><p>称为(<em>)的<em>*特征方程</em></em></p><div class="table-container"><table><thead><tr><th></th><th>$p^2-4q$</th><th>二阶常系数线性微分方程的通解</th></tr></thead><tbody><tr><td>不等实根</td><td>$\triangle&gt;0$</td><td>$y=C_1e^{\lambda_1x}+C_2e^{\lambda_2x}$</td></tr><tr><td>相等实根</td><td>$\triangle=0$</td><td>$y=(C_1+xC_2)e^{\lambda_1x}$</td></tr><tr><td>共轭复根</td><td>$\triangle&lt;0$</td><td><script type="math/tex">y=e^{\alpha x}(C_1\cos(\beta x)+C_2\sin(\beta x))\qquad(\lambda_{1,2}=\alpha\pm i\beta)</script></td></tr></tbody></table></div><blockquote><p>欧拉公式：$e^{\theta i}=\cos\theta+i\sin\theta$</p></blockquote><h4 id="二、高阶常系数齐次线性微分方程"><a href="#二、高阶常系数齐次线性微分方程" class="headerlink" title="二、高阶常系数齐次线性微分方程"></a>二、高阶常系数齐次线性微分方程</h4><p><img src="/images/tongji-calculus-5-7/image-20210515171500130.png" alt=""></p><blockquote><p>解三次方程野法：先把-2,-1,0,1,2代入，一般有个解就是这几个，然后通过此解把原方程分解成二次方程求解 </p></blockquote><p><strong>例一</strong> <script type="math/tex">求y'''-y'=0的通解\\解:\lambda^3-\lambda=0 \Rightarrow\lambda_1=0 ,\lambda_2=-1,\lambda_3=1\\通解:y=C_1+C_2e^{-x}+C_3e^x</script></p><p><strong>例二</strong> <script type="math/tex">求y'''-3y''+3y'-y=0的通解\\解:\lambda^3-3\lambda^2+3\lambda-1=0 \Rightarrow\lambda_1=\lambda_2=\lambda_3=1\\通解:y=(C_1+C_2x+C_3x^2)e^x</script></p><p><strong>例二</strong> <script type="math/tex">求y^{(4)}-2y^{(3)}+5y''=0的通解\\解:\lambda^4-2\lambda^3+5\lambda^2=0\Rightarrow\lambda^2(\lambda^2-2\lambda+5)=0\\\Rightarrow\lambda_1=\lambda_2=0,\lambda_{3,4}=1\pm2i\\通解:y=e^{0x}(C_1+C_2x)+e^x(C_3\cos(2x)+C_4\sin(2x))</script></p><h3 id="第八节-常系数非齐次线性微分方程"><a href="#第八节-常系数非齐次线性微分方程" class="headerlink" title="第八节 常系数非齐次线性微分方程"></a>第八节 常系数非齐次线性微分方程</h3><p>非齐次的通解=齐次的通解+一个非齐次的特解</p><p>我们研究两种常见的非齐次项</p><h4 id="一、-f-x-e-kx-P-n-x"><a href="#一、-f-x-e-kx-P-n-x" class="headerlink" title="一、$f(x)=e^{kx}P_n(x)$"></a>一、$f(x)=e^{kx}P_n(x)$</h4><p> 令$y_0(x)=x^aQ_n(x)e^{kx}$</p><p><strong>f(x)的特征方程的根中有几个和k相等，a就是几，没有相等的话a就是0，多项式$Q_n(x)$的次数n与$P_n(x)$的n相同</strong></p><p><strong>将$y_0(x)$代入方程中，解得多项式的系数，即可找到非齐次特解，加上齐次通解可得到非齐次通解</strong></p><p><strong>例一：</strong><script type="math/tex">求微分方程y''- 2y'- 3y=3x+1的通解.\\解:\lambda^2-2\lambda-3=0\Rightarrow\lambda_1=3,\lambda_2=-1\\令y_0(x)=x^0(ax+b)e^{0x}=ax+b\\代入原方程，得a=-1,b=\frac{1}{3}\\所以原方程的通解为y=C_1e^{-x}+C_2e^{3x}-x+\frac{1}{3}</script></p><h4 id="二、-f-x-e-alpha-x-P-l-x-cos-beta-x-Q-n-x-sin-beta-x"><a href="#二、-f-x-e-alpha-x-P-l-x-cos-beta-x-Q-n-x-sin-beta-x" class="headerlink" title="二、$f(x)=e^{\alpha x}[P_l(x)\cos\beta x+Q_n(x)\sin\beta x]$"></a>二、$f(x)=e^{\alpha x}[P_l(x)\cos\beta x+Q_n(x)\sin\beta x]$</h4><p> 令<script type="math/tex">y_0(x)=x^ae^{\alpha x}[R_m^{(1)}(x)\cos\beta x+R_m^{(2)}(x)\sin\beta x],m=\max(l,n)</script></p><p><strong>f(x)的特征方程的根中有几个和$\alpha+i\beta$相等，a就是几，没有相等的话a就是0，多项式$R_m(x)$的次数m与l和n中的最大值相同</strong></p><p><strong>将$y_0(x)$代入方程中，解得多项式的系数，即可找到非齐次特解，加上齐次通解可得到非齐次通</strong></p><p><strong>例二：</strong><script type="math/tex">求微分方程y''- 3y'+2y=x\cos x的通解.\\解:\lambda^2-3\lambda+2=0\Rightarrow\lambda_1=1,\lambda_2=2\\令y_0(x)=x^0e^{0x}[(ax+b)\cos x+(cx+d)\sin x]\\代入原方程,......</script></p><h3 id="第九节-欧拉方程"><a href="#第九节-欧拉方程" class="headerlink" title="第九节 欧拉方程"></a>第九节 欧拉方程</h3><p>形如<script type="math/tex">x^ny^{(n)}+p_1x^{n-1}y^{(n-1)}+...+p_{n-1}xy'+p_ny=f(x)的方程（其中p_1,p_2,...为常数）</script>叫做<strong>欧拉方程</strong></p><p>做变换$x=e^t或t=\ln x$，</p><p>得<script type="math/tex">\frac{dy}{dx}=\frac{dy}{dt}\frac{dt}{dx}=\frac{dy}{dt}\frac{1}{x}\\\frac{d^2y}{dt^2}=\frac{1}{x^2}(\frac{d^2y}{dt^2}-\frac{dy}{dt})\\\frac{d^3y}{dt^3}=\frac{1}{x^3}(\frac{d^3y}{dt^3}-3\frac{d^2y}{dt^2}+2\frac{dy}{dt})</script></p><p>用算符D表示$\frac{d}{dt}$，</p><p>则<script type="math/tex">xy'=x\frac{1}{x}\frac{d}{dt}y=Dy\\x^2y''=\frac{d^2y}{dt^2}-\frac{dy}{dt}=(\frac{d^2}{dt^2}-\frac{d}{dt})y=(D^2-D)y=D(D-1)y\\x^3y'''=...=D(D-1)(D-2)y</script></p><p>一般地，有$x^ky^{(k)}=D(D-1)…(D-k-1)y$</p><p>将其代入欧拉方程，便得到一个<strong>以t为自变量的常系数线性微分方程</strong>，解完后把x代回即得到原方程的解</p><p><strong>例一：</strong><script type="math/tex">求欧拉方程x^3y'''+x^2y''-4xy'=3x^2的解\\解：令x=e^t,t=\ln x，得\\D(D-1)(D-2)y+D(D-1)y-4Dy=3e^{2t}\\D^3y-2D^2y-3Dy=3e^{2t}\\特征方程:\lambda^3-2\lambda^2-3\lambda=0\Rightarrow\lambda_1=0,\lambda_2=-1,\lambda_3=3\\所以齐次的通解为y=C_1+C_2e^{-t}+C_3e^{3t}=C_1+C_2\frac{1}{x}+C_3x^3\\设非齐次特解y_0为ae^{2t},代入后解得a=-\frac{1}{2}\\所以齐次特解为y_0=-\frac{1}{2}e^{2t}=-\frac{1}{2}x^2\\所以原方程的通解为y=C_1+C_2\frac{1}{x}+C_3x^3-\frac{1}{2}x^2</script></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同济高数第七版（1-4章）</title>
      <link href="2021/04/15/tongji-calculus-1-4/"/>
      <url>2021/04/15/tongji-calculus-1-4/</url>
      
        <content type="html"><![CDATA[<p>基本概念：<span style="color:red;font-size:20px">定义</span></p><p>基本理论：<span style="color:blue;font-size:20px">定理、</span><span style="color:sienna;font-size:20px">性质、</span><span style="color:green;font-size:20px">推论</span></p><p>基本方法：<span style="color:purple;font-size:20px">法则</span></p><center><span style="color:blue;font-size:15px">2021/4/15</span></center><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p><strong>0.微积分：</strong></p><p>微：取小范围近似值-&gt;极限化</p><p>积：分-&gt;匀-&gt;合-&gt;精</p><p><strong>1.微积分研究的主要对象：</strong></p><p>微：变化率</p><p>积：该变量</p><p><strong>2.微积分研究的思想方法：</strong></p><p>利用已知研究未知</p><p>借助均匀变化解决非均匀变化</p><p>局部均压化求<strong>近似</strong>，利用<strong>极限</strong>得精确</p><p><strong>3.导数与积分的本质：</strong></p><p><strong>导数</strong>和<strong>积分</strong>分别是处理均匀量的<strong>商</strong>（变化率）和<strong>积</strong>（改变量）在处理非均匀量中的发展。</p><p><strong>4.微积分发展的关键</strong></p><p>极限思想——微积分的基础</p><h2 id="第一章-函数与极限"><a href="#第一章-函数与极限" class="headerlink" title="第一章 函数与极限"></a>第一章 函数与极限</h2><p>函数：微积分研究的主要对象<br>极限：研究函数的主要工具</p><h3 id="第一节-映射和函数"><a href="#第一节-映射和函数" class="headerlink" title="第一节 映射和函数"></a>第一节 映射和函数</h3><p>映射无重点</p><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a><span style="color:red;font-size:20px">函数定义</span></h4><p>如果对于每个数x∈D，变量y按照一定的法则总有一个确定的y和它对应，则称x是y的函数，记为y=f(x)。常称x为自变量，y为因变量, D为定义域。</p><p>[注]函数概念有两个基本要素：定义域、对应法则.（两要素相同函数就相同）</p><h4 id="函数的几种特性"><a href="#函数的几种特性" class="headerlink" title="函数的几种特性"></a><span style="color:sienna;font-size:20px">函数的几种特性</span></h4><ul><li>有界性：有界$\Leftrightarrow$有上下界</li><li>单调性</li><li>奇偶性</li><li>周期性</li></ul><center><span style="color:blue;font-size:15px">2021/4/16</span></center><h4 id="反函数定义"><a href="#反函数定义" class="headerlink" title="反函数定义"></a><span style="color:red;font-size:20px">反函数定义</span></h4><p>设函数$y= f(x)$的定义域为D，值域为$R_y$。若对任意$y∈R_y$， 有唯一确定的$x∈D$，使得$y= f(x)$，则记为$x=f^{-1}(y)$，称其为函数$y= f(x)$的反函数.</p><h4 id="复合函数定义"><a href="#复合函数定义" class="headerlink" title="复合函数定义"></a><span style="color:red;font-size:20px">复合函数定义</span></h4><p>设$y= f(u)$的定义域为$D_f$，$u=g(x)$的定义域为$D_g$，值域为$R_g$，若$D_f\cap R_g≠\phi$，则称函数$y= f[g(x)]$为函数$y= f(u)$与$u= g(x)$的复合函数。它的定义域为$\{x|x\in D_g,g(x)\in D_f\}$</p><h4 id="初等函数定义"><a href="#初等函数定义" class="headerlink" title="初等函数定义"></a><span style="color:red;font-size:20px">初等函数定义</span></h4><p>由常数和基本初等函数经过有限次的加、减、乘、除和复合所得到且能用一个解析式表示的函数，称为初等函数。</p><p>基本初等函数：</p><ul><li>幂函数：$y=x^u$</li><li>指数函数：$y=a^x$</li><li>对数函数：$y=\log_ax$</li><li>三角函数</li><li>反三角函数</li></ul><h3 id="第二节-数列极限"><a href="#第二节-数列极限" class="headerlink" title="第二节 数列极限"></a>第二节 数列极限</h3><h4 id="数列极限的定义"><a href="#数列极限的定义" class="headerlink" title="数列极限的定义"></a><span style="color:red;font-size:20px">数列极限的定义</span></h4><p>$(\varepsilon-N)$ ： $\forall\varepsilon&gt;0$，$\exists N$，当$ n&gt;N$时，有$|x_n-a|&lt;\varepsilon$</p><p>该定义不能用来求极限，但是可以验证数列是不是以a为极限</p><center><span style="color:blue;font-size:15px">2021/4/23</span></center><h4 id="收敛数列的性质"><a href="#收敛数列的性质" class="headerlink" title="收敛数列的性质"></a><span style="color:sienna;font-size:20px">收敛数列的性质</span></h4><ul><li>唯一性：收敛数列的极限是唯一的</li><li>有界性：收敛数列必有界</li><li>保号性：若$\displaystyle\lim_{x\to\infty}X_n=a$，且$a&gt;0$（或$a&lt;0$），则$\exists N$，当$n&gt;N$时，都有$x_n&gt;0$（或$x_n&lt;0$） </li><li>如果数列收敛于a，那么它的任一子数列也收敛，且极限也是a</li></ul><h3 id="第三节-函数极限"><a href="#第三节-函数极限" class="headerlink" title="第三节 函数极限"></a>第三节 函数极限</h3><h4 id="函数极限的定义"><a href="#函数极限的定义" class="headerlink" title="函数极限的定义"></a><span style="color:red;font-size:20px">函数极限的定义</span></h4><p><strong>1.自变量趋向于有限值时函数的极限：</strong></p><p>$(\varepsilon-\delta)$：设函数$f(x)$在点$x_0$的某个去心领域有定义，若$\forall\varepsilon&gt;0$，$\exists\delta&gt;0$，当$0&lt;|x-x_0|&lt;\delta$时，</p><p>恒有$|f(x)-A|&lt;\varepsilon$，则称A为$x\to x_0$时$f(x)$的极限。</p><p>函数极限研究的是临近点的变化趋势，与该点值无关。$x\to x_0$，但$x\not=x_0$</p><p><img src="/images/tongji-calculus-1-4/image-20210423213834371.png" alt=""></p><p><strong>2.自变量趋向于无穷大时函数的极限</strong></p><p><img src="/images/tongji-calculus-1-4/image-20210423214929882.png" alt=""></p><p><img src="/images/tongji-calculus-1-4/image-20210423223437636.png" alt=""></p><h4 id="函数极限的性质"><a href="#函数极限的性质" class="headerlink" title="函数极限的性质"></a><span style="color:sienna;font-size:20px">函数极限的性质</span></h4><ul><li>唯一性：函数有极限必唯一</li><li>局部有界：<br><img src="/images/tongji-calculus-1-4/image-20210423220733170.png" alt=""></li><li>保号性：<br><img src="/images/tongji-calculus-1-4/image-20210423221001457.png" alt=""></li></ul><center><span style="color:blue;font-size:15px">2021/4/26</span></center><h3 id="第四节-无穷小与无穷大"><a href="#第四节-无穷小与无穷大" class="headerlink" title="第四节 无穷小与无穷大"></a>第四节 无穷小与无穷大</h3><h4 id="无穷小"><a href="#无穷小" class="headerlink" title="无穷小"></a>无穷小</h4><p><span style="color:red;font-size:20px">定义1：</span>$如果函数f(x)当x\to x_0(或x\to \infty)时的极限为零，则称f(x)为x\to x_0(或x\to \infty)时的无穷小量$</p><ul><li>无穷小是<strong>变量</strong>，不能与很小的数混淆</li><li>0是无穷小，但是无穷小不一定是0（0是可以作为无穷小的唯一的数）</li><li>f(x)是否为无穷小与自变量x的趋向有关</li></ul><p><span style="color:blue;font-size:20px">定理1(极限与无穷小的关系)：</span>$\lim f(x)=A\Leftrightarrow f(x)=A +a(x),其中\lim a(x)= 0$</p><h4 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h4><p><span style="color:red;font-size:20px">定义2：</span>$若\displaystyle\lim_{x\to x_0}f(x)=\infty，则称f(x)是x\to x_0时的无穷大量$</p><p>即：$若对任意给定的M&gt;0，总存在δ&gt;0，当0&lt;|x-x_0|&lt;δ时，恒有|f(x)|&gt;M$</p><p><span style="color:blue;font-size:20px">定理2：</span>$在同一极限过程中，如果f(x)是无穷大，则\frac{1}{f(x)}是无穷小；反之，如果f(x)是无穷小，且f(x)≠0,则\frac{1}{f(x)}是无穷大$</p><h3 id="第五节-极限的运算法则"><a href="#第五节-极限的运算法则" class="headerlink" title="第五节 极限的运算法则"></a>第五节 极限的运算法则</h3><h4 id="无穷小运算法则"><a href="#无穷小运算法则" class="headerlink" title="无穷小运算法则"></a><span style="color:purple;font-size:20px">无穷小运算法则</span></h4><p><span style="color:blue;font-size:20px">定理1：</span>两个无穷小的和是无穷小（推广：<strong>有限个</strong>无穷小的和是无穷小）</p><p>证明：<script type="math/tex">设\alpha和\beta是当x\to x_0时的两个无穷小，\gamma=\alpha+\beta,           \forall\varepsilon>0，\\\exists\delta_1>0,当0<|x-x_0|<\delta_1时，|\alpha|<\varepsilon\\\exists\delta_2>0,当0<|x-x_0|<\delta_2时，|\beta|<\varepsilon\\取\delta=\min\{\delta_1,\delta_2\},当0<|x-x_0|<\delta时，|\gamma|\leq|\alpha|+|\beta|=2\varepsilon</script></p><p><span style="color:blue;font-size:20px">定理2：</span>有界函数与无穷小的乘积是无穷小</p><p>证明：<script type="math/tex">设函数\alpha(x)在x_0的某一去心邻域(x_0,\delta_1)内是有界的，\alpha(x)\leq M\\\forall\varepsilon>0，\exists\delta_2>0,当0<|x-x_0|<\delta_2时，|\beta|<\varepsilon\\取\delta=\min\{\delta_1,\delta_2\},当0<|x-x_0|<\delta时，|\alpha(x)\beta(x)|<\varepsilon M</script></p><p><span style="color:green;font-size:20px">推论1：</span>常数与无穷小的乘积是无穷小</p><p><span style="color:green;font-size:20px">推论2：</span>有限个无穷小的积仍是无穷小</p><h4 id="极限的有理运算法则"><a href="#极限的有理运算法则" class="headerlink" title="极限的有理运算法则"></a><span style="color:purple;font-size:20px">极限的有理运算法则</span></h4><p><span style="color:blue;font-size:20px">定理3：</span><script type="math/tex">\begin{aligned}若&\lim f(x)=A,\lim g(x)=B,（两个函数极限都存在）那么:（和差积商的极限都存在）\\&\lim((f(x)\pm g(x))=\lim f(x)\pm\lim g(x)\\&\lim((f(x)*g(x))=\lim f(x)*\lim g(x)\\&\lim \frac{f(x)}{g(x)}=\frac{\lim f(x)}{\lim g(x)}(B≠0)\end{aligned}</script><br><span style="color:green;font-size:20px">推论1：</span>$如果\lim f(x)存在,而c为常数,那么\lim[cf(x)]= c\lim f(x)$</p><p><span style="color:green;font-size:20px">推论2：</span>$如果\lim f(x)存在,而n是正整数,那么\lim[f(x)]^n = [lim f(x)]^n$</p><p><img src="/images/tongji-calculus-1-4/image-20210426172940420.png" alt=""></p><p><span style="color:blue;font-size:20px">定理5：</span>$如果φ(x)≥ψ(x),而\lim φ(x)= A, \lim ψ(x)= B,那么A≥B$</p><h4 id="复合函数的极限运算法则"><a href="#复合函数的极限运算法则" class="headerlink" title="复合函数的极限运算法则"></a><span style="color:purple;font-size:20px">复合函数的极限运算法则</span></h4><p><img src="/images/tongji-calculus-1-4/image-20210426201553110.png" alt=""></p><p><strong>note：注意使用条件！极限四则运算法则的条件是f和g的极限都存在，计算商的时候分母极限不能等于0。复合使用的条件是内外层都有极限，内层趋向于u0但不等于u0</strong></p><h3 id="第六节-极限存在准则-两个重要极限"><a href="#第六节-极限存在准则-两个重要极限" class="headerlink" title="第六节 极限存在准则 两个重要极限"></a>第六节 极限存在准则 两个重要极限</h3><h4 id="存在准则1：夹逼准则"><a href="#存在准则1：夹逼准则" class="headerlink" title="存在准则1：夹逼准则"></a><span style="color:blue;font-size:20px">存在准则1：夹逼准则</span></h4><p><span style="color:blue;font-size:20px">（数列型）</span><script type="math/tex">如果数列 \{x_n\},\{y_n\} 及\{z_n\} 满足下列条件:\\(1) 存在N，当n>N时,x_n≤y_n≤z_n;\\(2)\displaystyle\lim_{n\to\infty}x_n=\lim_{n\to \infty}z_n=a,\\则\displaystyle\lim_{n\to \infty}y_n=a</script></p><p><span style="color:blue;font-size:20px">（函数型）</span><img src="/images/tongji-calculus-1-4/image-20210426215057630.png" alt=""></p><h4 id="重要极限1：-displaystyle-lim-x-to-0-frac-sin-x-x-1"><a href="#重要极限1：-displaystyle-lim-x-to-0-frac-sin-x-x-1" class="headerlink" title="重要极限1：$\displaystyle\lim_{x\to 0}\frac{\sin x}{x}=1$"></a><span style="color:blue;font-size:20px">重要极限1：$\displaystyle\lim_{x\to 0}\frac{\sin x}{x}=1$</span></h4><p>中间得到$\sin x&lt;x&lt;\tan x\quad x\in(0,\frac{\pi}{2})$</p><p><strong>重要：</strong>根据夹逼准则证明，证明过程看书和笔记</p><h4 id="存在准则2：单调有界准则"><a href="#存在准则2：单调有界准则" class="headerlink" title="存在准则2：单调有界准则"></a><span style="color:blue;font-size:20px">存在准则2：单调有界准则</span></h4><p><span style="color:blue;font-size:20px">（数列型）</span>单调有界数列必有极限</p><p><span style="color:blue;font-size:20px">（函数型）</span>使用较少，不探讨</p><h4 id="重要极限2：-displaystyle-lim-n-to-infty-1-frac-1-n-n-e"><a href="#重要极限2：-displaystyle-lim-n-to-infty-1-frac-1-n-n-e" class="headerlink" title="重要极限2：$\displaystyle\lim_{n\to \infty}(1+\frac{1}{n})^n=e$"></a><span style="color:blue;font-size:20px">重要极限2：$\displaystyle\lim_{n\to \infty}(1+\frac{1}{n})^n=e$</span></h4><h4 id="displaystyle-lim-x-to-infty-1-frac-1-x-x-e"><a href="#displaystyle-lim-x-to-infty-1-frac-1-x-x-e" class="headerlink" title="$\displaystyle\lim_{x\to \infty}(1+\frac{1}{x})^x=e$"></a><span style="color:blue;font-size:20px">$\displaystyle\lim_{x\to \infty}(1+\frac{1}{x})^x=e$</span></h4><p>证明存在：证明单调增，证明上有界</p><center><span style="color:blue;font-size:15px">2021/4/27</span></center><h3 id="第七节-无穷小的比较"><a href="#第七节-无穷小的比较" class="headerlink" title="第七节 无穷小的比较"></a>第七节 无穷小的比较</h3><h4 id="无穷小的比较"><a href="#无穷小的比较" class="headerlink" title="无穷小的比较"></a>无穷小的比较</h4><p><span style="color:red;font-size:20px">定义1(无穷小量）：</span>$若\displaystyle\lim_{x\to x_0}f(x)=0,则称f(x)为x\to x_0时的无穷小量$</p><p><span style="color:red;font-size:20px">定义2(无穷小的比较）：</span></p><p><img src="/images/tongji-calculus-1-4/image-20210427134245916.png" alt=""></p><p><span style="color:blue;font-size:20px">定理1：</span>$\alpha(x) \sim β(x) 的充要条件是\alpha(x)=β(x)+ o(\beta(x))$</p><p>例：$\sin x在x\to0时可以近似看做函数x加一个无穷小量o(x)$</p><h4 id="等价无穷小代换"><a href="#等价无穷小代换" class="headerlink" title="等价无穷小代换"></a>等价无穷小代换</h4><p><span style="color:blue;font-size:20px">定理2（等价无穷小代换）：</span></p><p><img src="/images/tongji-calculus-1-4/image-20210427140815402.png" alt=""></p><p>定理2表明，求两个无穷小<strong>之比</strong>（乘除关系）的极限时，分子和分母都可用等价无穷小来代替。因此，如果用来代替的无穷小选得恰当的话，就可以使计算简化。</p><h4 id="常用的等价无穷小"><a href="#常用的等价无穷小" class="headerlink" title="常用的等价无穷小"></a>常用的等价无穷小</h4><p>$x\sim\sin x\sim\tan x\sim\arcsin x\sim\arctan x$</p><p>$(1+x)^a-1\sim ax$</p><p>$\sqrt[n]{1+x}-1\sim \frac{1}{n}x$</p><p>$1-\cos x\sim\frac{1}{2}x^2$</p><p>$\sec x-1\sim\frac{1}{2}x^2$</p><p>$\ln(1+x)\sim x$</p><p>$e^x-1 \sim x$</p><p>$a^x-1\sim x\ln a$</p><h3 id="第八节-函数的连续性和间断点"><a href="#第八节-函数的连续性和间断点" class="headerlink" title="第八节 函数的连续性和间断点"></a>第八节 函数的连续性和间断点</h3><h4 id="函数的连续性"><a href="#函数的连续性" class="headerlink" title="函数的连续性"></a>函数的连续性</h4><p><span style="color:red;font-size:20px">定义(连续）：</span><script type="math/tex">若\displaystyle\lim_{\triangle x\to 0}\triangle y=0, 或\lim_{x\to x_0}f(x)=f(x_0),则称f(x)在x_0处连续.</script></p><p><strong>f(x)在x0处连续：</strong><script type="math/tex">(1)f(x)在x_0有定义\\(2)\displaystyle\lim_{x\to x_0}f(x)存在\\(3)\displaystyle\lim_{x\to x_0}f(x)= f(x_0)(极限值等于函数值)</script></p><h4 id="函数的间断点"><a href="#函数的间断点" class="headerlink" title="函数的间断点"></a>函数的间断点</h4><p>只要上面连续的3个条件有一个不满足，就是间断</p><p><strong>f(x)在x0处间断：</strong><script type="math/tex">(1)f(x)在x_0没有定义\\(2)虽在x=x_0有定义，但\displaystyle\lim_{x\to x_0}f(x)不存在\\(3)虽在x=x_0有定义，且\displaystyle\lim_{x\to x_0}f(x)存在，但\lim_{x\to x_0}f(x)\not= f(x_0)</script></p><p><strong>间断点分类：</strong></p><ul><li>第一类间断点（左右极限都存在）<ul><li>可去间断点：$f(x_0-0)=f(x_0+0)$</li><li>跳跃间断点：$f(x_0-0)\not=f(x_0+0)$</li></ul></li><li>第二类间断点（左右极限至少有一个不存在）<ul><li>无穷间断点</li><li>震荡间断点</li></ul></li></ul><h3 id="第九节-连续函数的运算和初等函数的连续性"><a href="#第九节-连续函数的运算和初等函数的连续性" class="headerlink" title="第九节 连续函数的运算和初等函数的连续性"></a>第九节 连续函数的运算和初等函数的连续性</h3><p><strong>基本初等函数：</strong></p><ul><li>幂函数：$y=x^u$</li><li>指数函数：$y=a^x$</li><li>对数函数：$y=\log_ax$</li><li>三角函数</li><li>反三角函数</li></ul><p><strong>初等函数：</strong>由常数和基本初等函数经过有限次的<strong>四则运算</strong>，以及有限次的<strong>复合</strong>步骤所构成的并且可以由一个式子所表示的函数。 </p><p>前面已经通过定义证明了三角函数（sinx、cosx）的连续性，指数函数也是连续的，幂函数可以写成指数函数的形式，对数函数是指数函数的反函数，<strong>所以只需要证明基本初等函数的反函数、四则、复合的连续性，就可以得到初等函数的连续性</strong>。</p><h4 id="一、连续函数的和、差、积、商的连续性"><a href="#一、连续函数的和、差、积、商的连续性" class="headerlink" title="一、连续函数的和、差、积、商的连续性"></a>一、连续函数的和、差、积、商的连续性</h4><p><span style="color:blue;font-size:20px">定理1：</span>$设函数f(x),g(x)在x_0连续，则f(x)\pm g(x)、f(x)*g(x)、\frac{f(x)}{g(x)}(g(x_0\not=0))都在x_0连续$</p><h4 id="二、反函数与复合函数的连续性"><a href="#二、反函数与复合函数的连续性" class="headerlink" title="二、反函数与复合函数的连续性"></a>二、反函数与复合函数的连续性</h4><p><span style="color:blue;font-size:20px">定理2：（反函数的连续性）</span></p><p>$如果函数y=f(x)在区间I_X上单调增加（或减少）且连续，\\那么它的反函数x=f^{-1}(y)也在对应的区间I_y\{y|y=f(x),x\in I_x\}上单调增加（或减少）且连续。$</p><p><span style="color:blue;font-size:20px">定理3 ：（复合函数的连续性）</span></p><p>:<script type="math/tex">设y= f(g(x))是由y=f(u)与u=g(x)复合而成，\\若g(x)在x_0处连续，f(u)在u_0连续，u_0=g(x_0)，则f(g(x))在X_0处连续。\\\displaystyle\lim_{x\to x_0}f[g(x)]=\lim_{u\to u_0}f(u)=f(u_0)</script></p><p><strong>note：由上可知，复合函数中如果内层函数的极限存在（u0)，并且外层函数在u=u0处连续，那么函数符号可以与极限符号交换次序。</strong></p><h4 id="三、初等函数的连续性"><a href="#三、初等函数的连续性" class="headerlink" title="三、初等函数的连续性"></a>三、初等函数的连续性</h4><p><span style="color:blue;font-size:20px">定理4：</span>基本初等函数在其定义域内是连续的；</p><p><span style="color:blue;font-size:20px">定理5：</span>初等函数在其定义区间内是连续的；</p><h3 id="第十节-闭区间上连续函数性质"><a href="#第十节-闭区间上连续函数性质" class="headerlink" title="第十节 闭区间上连续函数性质"></a>第十节 闭区间上连续函数性质</h3><h4 id="一、有界性与最大值最小值定理"><a href="#一、有界性与最大值最小值定理" class="headerlink" title="一、有界性与最大值最小值定理"></a>一、有界性与最大值最小值定理</h4><p><span style="color:blue;font-size:20px">定理1（最大最小值定理）：</span>设函数f(x)在<strong>闭区间</strong>[a,b]上连续，则f(x)在[a,b]上必有最大值和最小值。</p><p><span style="color:blue;font-size:20px">定理2（有界性定理）：</span>设函数f(x)在<strong>闭区间</strong>[a,b]上连续，则f[x)在[a,b]上必有界. </p><h4 id="二、零点定理与介值定理"><a href="#二、零点定理与介值定理" class="headerlink" title="二、零点定理与介值定理"></a>二、零点定理与介值定理</h4><p><span style="color:blue;font-size:20px">定理3（零点定理）：</span>$设函数f(x)在闭区间[a,b]上连续，且f(a)f(b)&lt;0，则\existsξ∈(a,b)使f(ξ)=0.$</p><p><span style="color:blue;font-size:20px">定理4（介值定理）：</span><script type="math/tex">设函数f(x)在区间|a,b|上连续,且f(a)\not=f(b),\\\mu为介于f(a)与f(b)之间的任何值,则至少存在一个ξ∈(a,b) 使f(\xi)=μ</script></p><p><span style="color:blue;font-size:20px">推论：</span>设函数f(x)在闭区间[a,b]上连续，则f(x) 在[a,b]上能取得介于它的最大值M与最小值m之间的任何值</p><p><strong>note：零点定理是介值定理的特例，但是零点定理用的更多。</strong></p><center><span style="color:blue;font-size:15px">2021/4/28</span></center><h2 id="第二章-导数与微分"><a href="#第二章-导数与微分" class="headerlink" title="第二章 导数与微分"></a>第二章 导数与微分</h2><p>微分学是微积分的重要组成部分，它的基本概念是导数和微分<br>在本章中，主要讨论导数和微分的概念以及它们的计算方法</p><h3 id="第一节-导数概念"><a href="#第一节-导数概念" class="headerlink" title="第一节 导数概念"></a>第一节 导数概念</h3><h4 id="一、引例"><a href="#一、引例" class="headerlink" title="一、引例"></a>一、引例</h4><p>1.变速直线运动瞬间速度</p><p>2.曲线的切线</p><p><strong>导数的实质：增量比的极限（导数就是一个特殊的极限）</strong></p><h4 id="二、导数的定义"><a href="#二、导数的定义" class="headerlink" title="二、导数的定义"></a>二、导数的定义</h4><p><span style="color:red;font-size:20px">定义：</span><script type="math/tex">若\displaystyle\lim_{\triangle x\to 0}\frac{f(x_0+\triangle x)-f(x_0)}{\triangle x}=\lim_{x \to x_0}\frac{f(x)-f(x_0)}{x-x_0}=\lim_{\triangle x\to 0}\frac{\triangle y}{\triangle x}存在，则称f(x)在x_0点可导\\记作f'(x_0)\quad或y'|_{x=x_0}\quad或\frac{dy}{dx}|_{x=x_0}\\若以上极限不存在，则称f(x)在x_0处不可导</script></p><p><strong>因为上面的极限存在，所以x的变化量趋于0时y的变化量也一定趋于0，根据连续的定义可得这点一定连续</strong></p><p><strong>由导数的定义可得：</strong><script type="math/tex">(x^a)'=a(x^{a-1})\\(a^x)'=a^x\ln a\\(\log_a x)'=\frac{1}{x\ln a}(a>0,a\not=1)\\(\sin x)'=\cos x\\(\cos x)'=-\sin x</script></p><h4 id="三、可导和连续的关系"><a href="#三、可导和连续的关系" class="headerlink" title="三、可导和连续的关系"></a>三、可导和连续的关系</h4><p>可导一定连续，连续不一定可导</p><h3 id="第二节-函数的求导法则"><a href="#第二节-函数的求导法则" class="headerlink" title="第二节 函数的求导法则"></a>第二节 函数的求导法则</h3><p>本节将解决初等函数的求导（基本初等函数（5）（或2+反函数）+四则+复合）</p><h4 id="一、函数的和、差、积、商的求导法则"><a href="#一、函数的和、差、积、商的求导法则" class="headerlink" title="一、函数的和、差、积、商的求导法则"></a><span style="color:purple;font-size:20px">一、函数的和、差、积、商的求导法则</span></h4><p><img src="/images/tongji-calculus-1-4/image-20210428113111535.png" alt=""></p><p>推论：$(uvw)’=u’vw+vu’w+uvw’$</p><p><strong>由四则的求导法则可得</strong>：<script type="math/tex">(\tan x)'=\sec^2 x\\(\cot x)'=-\csc^2 x\\(\sec x)'=\sec x\tan x\\(\csc x)'=-\csc x\cot x</script></p><h4 id="二、反函数的求导法则"><a href="#二、反函数的求导法则" class="headerlink" title="二、反函数的求导法则"></a><span style="color:purple;font-size:20px">二、反函数的求导法则</span></h4><p><img src="/images/tongji-calculus-1-4/image-20210428114535953.png" alt=""></p><p>例：$求y=\arcsin x(x\in[-1,1])的导数$</p><p>解：<script type="math/tex">y=\arcsin x\Longleftrightarrow x=\sin y\\\frac{dy}{dx}=(\arcsin x)'=\frac{1}{\cos y}=\frac{1}{\sqrt{1-\sin^2y}}=\frac{1}{\sqrt{1-x^2}}</script></p><p><strong>由反函数的求导法则可得：</strong><script type="math/tex">(\arcsin x)'=\frac{1}{\sqrt{1-x^2}}\\(\arccos x)'=-\frac{1}{\sqrt{1-x^2}}\\(\arctan x)'=\frac{1}{1+x^2}\\(arc\cot x)'=-\frac{1}{1+x^2}</script></p><h4 id="三、复合函数的求导法则"><a href="#三、复合函数的求导法则" class="headerlink" title="三、复合函数的求导法则"></a><span style="color:purple;font-size:20px">三、复合函数的求导法则</span></h4><p><span style="color:blue;font-size:20px">定理3（链式法则）：</span><script type="math/tex">设u=g(x)在x可导，y= f(u)在对应u处可导，\\则y=f[g(x)]在x处可导，且\frac{dy}{dx}=f'(u)g'(x)\quad \frac{dy}{dx}=\frac{dy}{du}*\frac{du}{dx}</script></p><h4 id="四、基本求导法则与导数公式"><a href="#四、基本求导法则与导数公式" class="headerlink" title="四、基本求导法则与导数公式"></a><span style="color:purple;font-size:20px">四、基本求导法则与导数公式</span></h4><h5 id="基本初等函数的导数公式"><a href="#基本初等函数的导数公式" class="headerlink" title="基本初等函数的导数公式"></a>基本初等函数的导数公式</h5><p><img src="/images/tongji-calculus-1-4/image-20210428135707145.png" alt=""></p><h3 id="第三节-高阶导数"><a href="#第三节-高阶导数" class="headerlink" title="第三节 高阶导数"></a>第三节 高阶导数</h3><p>二阶及二阶以上的导数统称高阶导数</p><p><img src="/images/tongji-calculus-1-4/image-20210428151010886.png" alt=""></p><p><img src="/images/tongji-calculus-1-4/image-20210428153636553.png" alt=""></p><h3 id="第四节-隐函数及由参数方程确定的函数求导"><a href="#第四节-隐函数及由参数方程确定的函数求导" class="headerlink" title="第四节 隐函数及由参数方程确定的函数求导"></a>第四节 隐函数及由参数方程确定的函数求导</h3><h4 id="一、隐函数求导"><a href="#一、隐函数求导" class="headerlink" title="一、隐函数求导"></a>一、隐函数求导</h4><p><strong>显函数：y=f(x)</strong></p><p><strong>隐函数：F(x,y)=0</strong></p><p>将隐函数变为显函数的过程称为隐函数的显式化，但是不是所有的隐函数都能显式化。</p><p><strong>隐函数求导方法：方程整体对x求导，求$\frac{dy}{dx}$时，y看成f(x)</strong></p><p><strong>幂指函数（$y=x^x$)不是初等函数，适合用对数求导法</strong></p><p><strong>导数的乘除公式复杂，和差公式复杂，所以在遇到像这样的连乘连除时，也可利用对数可以将乘除法变成加减法的性质，将显函数化为隐函数再求导。</strong></p><p><img src="/images/tongji-calculus-1-4/image-20210428163206454.png" alt=""></p><p>解：<script type="math/tex">\displaystyle\ln|y|=\frac{1}{3}[\ln|x+\ln(x^2+1)-2\ln|x^2-1|]\\\displaystyle\frac{y'}{y}=\frac{1}{3}[\frac{1}{x}+\frac{2x}{x^2+1}-\frac{4x}{x^2-1}]\\y'=...</script></p><h4 id="二、由参数方程所确定的函数的导数"><a href="#二、由参数方程所确定的函数的导数" class="headerlink" title="二、由参数方程所确定的函数的导数"></a>二、由参数方程所确定的函数的导数</h4><p><strong>参数方程：$由x=\varphi(t),y=\psi(t)确定x和y间的函数关系$</strong></p><p><span style="color:blue;font-size:20px">定理：</span><script type="math/tex">设x=\varphi(t),y=\psi(t)在(\alpha,\beta)上可导，\varphi'(t)≠0,则\\\displaystyle\frac{dy}{dx}=\frac{\frac{dy}{dt}}{\frac{dx}{dt}}=\frac{\psi'(t)}{\varphi'(t)}\\若\varphi(t),\psi(t)二阶可导，则\\\displaystyle\frac{d^2y}{dx^2}=\frac{d}{dt}(\frac{\psi'(t)}{\varphi'(t)})\frac{dt}{dx}=\frac{\psi''(t)\varphi'(t)-\varphi''(t)\psi'(t)}{\varphi'^3(t)}</script></p><p><strong>note：极坐标方程求导可以转化为参数方程求导法来解</strong></p><h4 id="三、相关变化率"><a href="#三、相关变化率" class="headerlink" title="三、相关变化率"></a>三、相关变化率</h4><p>1.建立两个相关量之间的关系</p><p>2.代入其中之一变化率，求另一变化率</p><h3 id="第五节-函数的微分"><a href="#第五节-函数的微分" class="headerlink" title="第五节 函数的微分"></a>第五节 函数的微分</h3><h4 id="一、微分的定义"><a href="#一、微分的定义" class="headerlink" title="一、微分的定义"></a>一、微分的定义</h4><p><img src="/images/tongji-calculus-1-4/image-20210428195222432.png" alt=""></p><p><span style="color:red;font-size:20px">定义：</span><script type="math/tex">若f(x_0+\triangle x)- f(x_0)=A\triangle x+o(\triangle x),则称f(x)在x_0点可微，A\triangle x称为f(x)在x_0点的微分\\记为\qquad dy=A\triangle x\\dy是\triangle y的线性主部</script></p><p><strong>在微小的局部，用均匀（主要部分）代替非均匀（主要部分+高阶无穷小）就是微积分的核心思想。</strong></p><p><strong>讲的简单点，微分是函该变量的近似值</strong></p><p><span style="color:blue;font-size:20px">定理：</span><script type="math/tex">函数y=f(x)在点x_0处可微的充分必要条件是f(x)在点x_0处可导，且有\\dy=f'(x_0)\triangle x=f'(x_0)dx</script></p><p>$可微\Longleftrightarrow 可导$</p><h4 id="二、微分的几何意义"><a href="#二、微分的几何意义" class="headerlink" title="二、微分的几何意义"></a>二、微分的几何意义</h4><p><img src="/images/tongji-calculus-1-4/image-20210428200118788.png" alt=""></p><p><img src="/images/tongji-calculus-1-4/image-20210428202817555.png" alt=""></p><h4 id="三、基本初等函数的微分公式与微分运算法则"><a href="#三、基本初等函数的微分公式与微分运算法则" class="headerlink" title="三、基本初等函数的微分公式与微分运算法则"></a>三、基本初等函数的微分公式与微分运算法则</h4><p><strong>基本初等函数的微分公式：</strong></p><p>$dy=df(x)=f’(x)dx$</p><p><strong>四则运算法则：</strong>设u和v都可微，则</p><p><img src="/images/tongji-calculus-1-4/image-20210428203416042.png" alt=""></p><p><strong>复合函数微分法则(微分形式不变性)：</strong></p><p><img src="/images/tongji-calculus-1-4/image-20210428203932209.png" alt=""></p><p>例：$y=\ln(1+x^2)$</p><p>$dy=\frac{2x}{1+x^2}dx\qquad dy=\frac{1}{1+x^2}d(1+x^2)$</p><center><span style="color:blue;font-size:15px">2021/4/29</span></center><h2 id="第三章-微分中值定理与导数应用"><a href="#第三章-微分中值定理与导数应用" class="headerlink" title="第三章 微分中值定理与导数应用"></a>第三章 微分中值定理与导数应用</h2><p>在第二章里，学习了导数和微分的概念和求导、求微分的基本方法</p><p>自然有问题：导数的作用是什么呢？</p><p>这一章主要以<strong>导数</strong>作为工具，进一步研究<strong>函数</strong>的一些基本形态。</p><p>微分中值定理就是建立导数和函数联系的一座桥梁。</p><h3 id="第一节-微分中值定理"><a href="#第一节-微分中值定理" class="headerlink" title="第一节 微分中值定理"></a>第一节 微分中值定理</h3><p>本节建立函数值和一阶导数之间的关系</p><h4 id="一、罗尔定理"><a href="#一、罗尔定理" class="headerlink" title="一、罗尔定理"></a>一、罗尔定理</h4><p><span style="color:red;font-size:20px">定义（极值）：</span><script type="math/tex">若\existsδ>0，使得\\\forall x∈U(x_0,\delta)恒有f(x)≥f(x_0)，则称f(x)在x_0取极小值.\\\forall x∈U(x_0,\delta)恒有f(x)\leq f(x_0)，则称f(x)在x_0取极大值.</script></p><p><span style="color:blue;font-size:20px">费马引理：</span>$若f(x)在x_0处取得极值,且f(x)在x_0处可导,则f’(x_0)=0$</p><p><span style="color:blue;font-size:20px">罗尔定理：</span><script type="math/tex">若\\(1)f在[a,b]上连续\\(2)f在(a,b)内可导\\(3)f(a)=f(b)\\则\exists\xi\in(a,b),使f'(\xi)=0</script></p><p><img src="/images/tongji-calculus-1-4/image-20210429135954616.png" alt=""></p><p>证：$由于f(x)在[a,b]连续，则存在最小值m，最大值M（最大最小值定理）\\ (1)若m=M\Rightarrow f(x)=m\\ (2)若m&lt;M,则m和M至少有一个在(a,b)取到,设\exists \xi\in(a,b),使f(\xi)=M\\ \quad\Rightarrow f’(\xi)=0(费马定理)$</p><h4 id="二、拉格朗日中值定理"><a href="#二、拉格朗日中值定理" class="headerlink" title="二、拉格朗日中值定理"></a>二、拉格朗日中值定理</h4><p><span style="color:blue;font-size:20px">拉格朗日中值定理：</span><script type="math/tex">若\\(1)f在[a,b]上连续\\(2)f在(a,b)内可导\\则\exists\xi\in(a,b),使f(b)-f(a)=f'(\xi)(b-a)\\\displaystyle或写成\frac{f(b)-f(a)}{b-a}=f'(\xi)</script></p><p><img src="/images/tongji-calculus-1-4/image-20210429135740646.png" alt=""></p><p>证：<script type="math/tex">改写为f'(\xi)-\frac{f(b)-f(a)}{b-a}=0（用来构造辅助函数）\\使上式=F'(\xi)\\令F(x)=f(x)-x\frac{f(b)-f(a)}{b-a}\\易得\\(1)F在[a,b]上连续\\(2)F在(a,b)内可导\\(3)F(a)=F(b)\\\Rightarrow \exists\xi\in(a,b),使F'(\xi)=0</script></p><p><strong>例题：</strong>证明：<script type="math/tex">当x>0时，\frac{x}{1+x}<\ln(1+x)<x\\解：\ln(1+x)\\\quad=\ln(1+x)-\ln1\\\quad=\frac{1}{\xi}*x(1<\xi<1+x)</script></p><p><strong>拉格朗日中值定理用来解决函数值和导数的联系的问题（不等式）（出现同一函数在两点时的差），看书和笔记的例题</strong></p><p><strong>note:</strong><script type="math/tex">(1)罗尔定理是拉格朗日中值定理的特殊情况（当f(a)=f(b))\\(2)拉格朗日中值定理的等价形式：\\\quad f(b)-f(a)=f'[a+\theta(b-a)]*(b-a)\qquad(0<\theta<1)</script></p><p><span style="color:blue;font-size:20px">推论：</span>$设f(x)在区间I上连续，在I内可导，则在I上f(x)=C\Leftrightarrow f’(x)= 0$</p><h4 id="三、柯西中值定理"><a href="#三、柯西中值定理" class="headerlink" title="三、柯西中值定理"></a>三、柯西中值定理</h4><p><span style="color:blue;font-size:20px">柯西中值定理：</span><script type="math/tex">若\\(1)f,F在[a,b]上连续;\\(2)f,F在(a,b)内可导，且\forall x∈(a,b), F'(x)≠0\\\displaystyle则\exists\xi\in(a,b),使\frac{f(b)-f(a)}{F(b)-F(a)}=\frac{f'(\xi)}{F'(\xi)}</script></p><p>证：<script type="math/tex">改写为[f(b)-f(a)]*F'(\xi)-[F(b)-F(a)]*f'(\xi)=0（用来构造辅助函数）\\使上式=\varphi'(\xi)\\令\varphi(x)=[f(b)-f(a)]*F(x)-[F(b)-F(a)]*f(x)\\易得\\(1)\varphi在[a,b]上连续\\(2)\varphi在(a,b)内可导\\(3)\varphi(a)=\varphi(b)\\\Rightarrow \exists\xi\in(a,b),使\varphi'(\xi)=0</script></p><p><strong>note:</strong>$柯西定理是最一般的结论，拉格朗日中值定理是柯西中值定理的特殊情况（当F(x)=x)$</p><h4 id="内容小结："><a href="#内容小结：" class="headerlink" title="内容小结："></a>内容小结：</h4><p><strong>中值定理的意义：</strong></p><ul><li>建立局部和整体的关系：导数是局部形态，反应一点的变化率，而函数的变量和自变量的改变是一个区间上的整体形态（平均速度和某个时刻的瞬时速度）</li><li>建立了函数值和导数值的关系，给用导数研究函数奠定了理论基础</li></ul><p><strong>三个中值定理的关系：</strong></p><ul><li>柯西定理是最一般的结论，拉格朗日中值定理是柯西中值定理的特例，罗尔定理是拉格朗日中值定理的特例</li><li>拉格朗日中值定理和柯西中值定理都是由罗尔定理证明，罗尔定理在微分中值定理证明中一个核心的思想就是像证明其他两个定理一样，就是构造辅助函数，满足罗尔定理。</li><li>在三个定理中，用的更多的是罗尔定理和拉格朗日定理。</li></ul><p><strong>中值定理的应用：</strong></p><ul><li>证明恒等式（拉格朗日中值定理的推论）</li><li>证明不等式（出现同一函数在两点函数值相减的时候）</li><li>证明有关中值定理的结论（证明拉格朗日中值定理和柯西中值定理的思想）（关键是构造辅助函数）</li></ul><h3 id="第二节-洛必达法则"><a href="#第二节-洛必达法则" class="headerlink" title="第二节 洛必达法则"></a>第二节 洛必达法则</h3><p>导数本身就是个0比0型的极限，本节尝试借助导数研究0比0型的极限</p><p><span style="color:purple;font-size:20px">洛必达法则</span></p><p><img src="/images/tongji-calculus-1-4/RD2B%60%5D3ZPLY%25FUX_HLDMCF.png" alt=""></p><p>若<script type="math/tex">\displaystyle\lim_{x\to x_0}\frac{f'(x)}{g'(x)}不存在，只能说明洛必达法则不适用，不能说\lim_{x\to x_0}\frac{f(x)}{g(x)}不存在</script></p><script type="math/tex; mode=display">\displaystyle\lim_{x\to\infty}\frac{\log_ax}{x^b}=0\quad(a>1,b>0)\\\displaystyle\lim_{x\to\infty}\frac{x^b}{a^x}=0\quad(a>1,b>0)</script><p><strong>上面的式子表示在x趋于正无穷时，指数函数趋向无穷的速度远远大于幂函数远远大于指数函数</strong></p><center><span style="color:blue;font-size:15px">2021/4/30</span></center><h3 id="第三节-泰勒公式"><a href="#第三节-泰勒公式" class="headerlink" title="第三节 泰勒公式"></a>第三节 泰勒公式</h3><p>本节建立函数值和高阶导数的关系：</p><p>若<script type="math/tex">f(x)在x_0处可微，则\triangle y\approx dy\\f(x)≈f(x_0)+ f'(x_0)(x-x_0)</script></p><p><strong>上式表示在用一次多项式（切线）代替原式（曲线）</strong></p><p>$f(x)=f(x_0)+ f’(x_0)(x-x_0)+o(x-x_0)$</p><p><strong>两者精确值的误差是$o(x-x_0)$</strong></p><p><strong>问题：</strong><script type="math/tex">若f(x)在x_0处n阶可导,是否存在n次多项式\\P_n(x)=a_0+a_1(x-x_0)+a_2(x- x_0)^2+...+a_n(x-x_0)^n\\使f(x)= P_n(x)+o((x-x_0)^n)</script></p><p><strong>代表多项式的函数值，一阶导数值，二阶导数值……n阶导数值都和f(x)相等</strong></p><p><strong>推论：</strong><script type="math/tex">\displaystyle a_0=f(x_0)\quad a_k=\frac{f^{(k)}(x_0)}{k!}\quad k=1,2,...,n</script></p><h4 id="带佩亚诺余项的泰勒公式"><a href="#带佩亚诺余项的泰勒公式" class="headerlink" title="带佩亚诺余项的泰勒公式"></a>带佩亚诺余项的泰勒公式</h4><p><span style="color:blue;font-size:20px">定理1（Taylor定理）：</span><script type="math/tex">设f(x)在x_0处n阶可导，则\\\displaystyle f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{n}(x_0)}{n!}(x-x_0)^n+o((x-x_0)^n)\\上式称为带Peano余项的Taylor公式\\\displaystyle p_n(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{n}(x_0)}{n!}(x-x_0)^n\\上式称为f(x)在x_0处的n次Taylor多项式\\R_n(x)=o((x-x_0)^n)\qquad f(x)的Peano余项</script></p><p><strong>缺点：</strong></p><ul><li>只给出余项的定性描述，不能进行定量分析</li><li>适用范围小（只有充分靠近x0，误差才比较小）</li></ul><h4 id="带拉格朗日余项的泰勒公式"><a href="#带拉格朗日余项的泰勒公式" class="headerlink" title="带拉格朗日余项的泰勒公式"></a>带拉格朗日余项的泰勒公式</h4><p><span style="color:blue;font-size:20px">定理2（Taylor定理）：</span><script type="math/tex">设f(x)区间I中n+1阶可导，x_0\in I,则\forall x\in I,\exists\xi\in I(\xi在x_0与x之间)，使\\\displaystyle f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{n}(x_0)}{n!}(x-x_0)^n+\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}\\上式称为带Lagrange余项的Taylor公式\\\displaystyle R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}\qquad f(x)的Lagrange余项\\或者写成\displaystyle R_n(x)=\frac{f^{(n+1)}[x_0+\theta(x-x_0)]}{(n+1)!}(x-x_0)^{n+1}\qquad\theta\in(0,1)</script></p><p>若<script type="math/tex">x_0=0，则\\\displaystyle f(x)=f(0)+f'(0)x+\frac{f''(0)}{2!}x^2+...+\frac{f^{n}(0)}{n!}x^n+\frac{f^{n+1}(\theta x)}{(n+1)!}x^{n+1}</script></p><p><strong>上式称为f(x)的麦克劳林公式</strong></p><h4 id="几个初等函数的麦克劳林公式"><a href="#几个初等函数的麦克劳林公式" class="headerlink" title="几个初等函数的麦克劳林公式"></a>几个初等函数的麦克劳林公式</h4><p><img src="/images/tongji-calculus-1-4/image-20210430155914656.png" alt=""></p><h4 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h4><p><strong>两个泰勒公式的本质：</strong></p><ul><li>用<strong>多项式</strong>逼近f(x)</li><li>用已知点的信息表示未知点</li></ul><p><strong>两个泰勒公式的区别：</strong></p><ul><li>Peano：定性，<strong>局部</strong>（在x趋向x0的时候）（<strong>用来研究极限、极值时使用</strong>）</li><li>Lagrange：定量，<strong>整体</strong>（给出了误差的表达式，即使在大范围内用，只要n足够大，误差也能控制的较小）（<strong>用来研究最值，不等式时候用</strong>）</li></ul><p><strong>四大中值定理：</strong></p><ul><li>前三个建立f(x)与一阶导数的关系</li><li>拉格朗日中值定理是带有拉格朗日余项的泰勒公式在n=0时的特例，<strong>带有拉格朗日余项的泰勒公式也称为泰勒中值定理</strong></li><li>泰勒中值定理建立f(x)与高阶导数之间的关系</li></ul><h3 id="第四节-函数的单调性与曲线的凹凸性"><a href="#第四节-函数的单调性与曲线的凹凸性" class="headerlink" title="第四节 函数的单调性与曲线的凹凸性"></a>第四节 函数的单调性与曲线的凹凸性</h3><h4 id="一、函数单调性的判别方法"><a href="#一、函数单调性的判别方法" class="headerlink" title="一、函数单调性的判别方法"></a>一、函数单调性的判别方法</h4><p><img src="/images/tongji-calculus-1-4/image-20210430203100846.png" alt=""></p><h4 id="二、曲线的凹凸性与拐点"><a href="#二、曲线的凹凸性与拐点" class="headerlink" title="二、曲线的凹凸性与拐点"></a>二、曲线的凹凸性与拐点</h4><p><img src="/images/tongji-calculus-1-4/image-20210430204415094.png" alt=""></p><p><span style="color:blue;font-size:20px">定理2：</span><script type="math/tex">设函数f(x)在区间[a,b]上连续,在(a,b)内二阶可导，\\(1)若在(a,b)内f''(x)>0,则f(x)在[a,b] 上的图形是凹的;\\(2)若在(a,b)内f''(x)<0,则f(x)在[a,b]上的图形是凸的.</script></p><p>驻点：$f’(x)=0$</p><p>拐点：使函数凹凸性改变的点（$f’’(x)=0或者不存在只是必要条件$）</p><center><span style="color:blue;font-size:15px">2021/5/2</span></center><h3 id="第五节-函数的极值与最值"><a href="#第五节-函数的极值与最值" class="headerlink" title="第五节 函数的极值与最值"></a>第五节 函数的极值与最值</h3><h4 id="一、函数的极值及其求法"><a href="#一、函数的极值及其求法" class="headerlink" title="一、函数的极值及其求法"></a>一、函数的极值及其求法</h4><p><img src="/images/tongji-calculus-1-4/image-20210502100507736.png" alt=""></p><p>驻点$\nrightarrow$极值点</p><p>极值点$\nrightarrow$驻点</p><p><strong>可能的极值点：</strong></p><ul><li>驻点</li><li>导数不存在的点</li></ul><h4 id="二、最大值最小值问题"><a href="#二、最大值最小值问题" class="headerlink" title="二、最大值最小值问题"></a>二、最大值最小值问题</h4><h3 id="第六节-函数图形的描绘"><a href="#第六节-函数图形的描绘" class="headerlink" title="第六节 函数图形的描绘"></a>第六节 函数图形的描绘</h3><h4 id="曲线的渐近线"><a href="#曲线的渐近线" class="headerlink" title="曲线的渐近线"></a>曲线的渐近线</h4><p><img src="/images/tongji-calculus-1-4/image-20210502172746146.png" alt="="></p><p>函数图形的描绘</p><ul><li>求定义域，确定奇偶性，周期性</li><li>求一阶导数，确定单调区间，极值点</li><li>求二阶导数，确定拐点和凹凸性</li><li>求渐近线</li><li>画图</li></ul><center><span style="color:blue;font-size:15px">2021/5/3</span></center><h3 id="第七节-曲率"><a href="#第七节-曲率" class="headerlink" title="第七节 曲率"></a>第七节 曲率</h3><h4 id="一、弧微分（考研不作要求）"><a href="#一、弧微分（考研不作要求）" class="headerlink" title="一、弧微分（考研不作要求）"></a>一、弧微分（考研不作要求）</h4><p><strong>case1:</strong>$L:y=f(x)$</p><p>$\displaystyle ds=\sqrt{(dx)^2+(dy)^2}=\sqrt{1+(\frac{dy}{dx})^2}dx=\sqrt{1+f’^2(x)}dx$</p><p><strong>case2:</strong>$L:\begin{cases}x=\varphi(t)\\y=\psi(t)\end{cases}$</p><p>$\displaystyle ds=\sqrt{(dx)^2+(dy)^2}=\sqrt{(\frac{dx}{dt})^2+(\frac{dy}{dt})^2}dt=\sqrt{\varphi’^2(t)+\psi’^2(t)}dt$</p><h4 id="二、曲率"><a href="#二、曲率" class="headerlink" title="二、曲率"></a>二、曲率</h4><p>曲率：$\displaystyle k=\frac{|y’’|}{(1+y’^2)^{\frac{3}{2}}}$</p><p>曲率半径：$\rho=\frac{1}{k}$</p><center><span style="color:blue;font-size:15px">2021/5/4</span></center><h2 id="第四章-不定积分"><a href="#第四章-不定积分" class="headerlink" title="第四章 不定积分"></a>第四章 不定积分</h2><p>由于求不定积分是求导的逆运算</p><p>所以导数的基本公式倒过来就是积分的基本公式</p><p>导数的运算法则（四则，复合，隐函数，参数）也可以倒过来，其中的核心是有理运算（四则）和复合</p><p>乘法倒过来就是分部积分法，除法不好用，不考虑</p><p>复合函数倒过来就是换元积分法</p><h3 id="第一节-不定积分的概念和性质"><a href="#第一节-不定积分的概念和性质" class="headerlink" title="第一节 不定积分的概念和性质"></a>第一节 不定积分的概念和性质</h3><h4 id="一、原函数与不定积分的概念"><a href="#一、原函数与不定积分的概念" class="headerlink" title="一、原函数与不定积分的概念"></a>一、原函数与不定积分的概念</h4><p><span style="color:red;font-size:20px">定义1：</span><script type="math/tex">如果在区间I上，可导函数F(x)的导函数为f(x)，即对任一x\in I.都有\\F'(x)=f(x)或dF(x)=f(x)dx\\那么函数F(x)就称为f(x)(或f(x)dx)在区间I上的一个原函数</script></p><p><span style="color:blue;font-size:20px">原函数存在定理：</span>连续函数一定有原函数</p><p><strong>notes：</strong></p><ul><li>一个函数若有原函数，则一定有无数个原函数</li><li>一个函数任两个原函数之间相差常数</li><li>设F(x)为f(x)的一个原函数，则F(x)+c为f(x)的一切原函数</li></ul><p><span style="color:red;font-size:20px">定义2：</span><script type="math/tex">在区间I上，函数f(x)的带有任意常数项的原函数称为f(x)(或f(x)dx)在区级I上的不定积分，记作\\\int f(x)dx\quad即\int f(x)dx=F(x)+c\\其中记号\int 称为积分号，f(x)称为被积函数，f(x)dx称为被积表达式，x称为积分变量</script></p><h4 id="二、不定积分性质"><a href="#二、不定积分性质" class="headerlink" title="二、不定积分性质"></a>二、不定积分性质</h4><p>1.$\int [f(x)\pm f(x)]dx=\int f(x)dx\pm \int g(x)dx$</p><p>2.$\int af(x)dx=a\int f(x)dx$</p><p><strong>notes:</strong></p><ul><li>$\int f’(x)dx=f(x)+c$</li><li>$(\int f(x)dx)’=f(x)$</li></ul><h3 id="第二节-换元积分法"><a href="#第二节-换元积分法" class="headerlink" title="第二节 换元积分法"></a>第二节 换元积分法</h3><h4 id="一、第一类换元法（凑微分法）"><a href="#一、第一类换元法（凑微分法）" class="headerlink" title="一、第一类换元法（凑微分法）"></a>一、第一类换元法（凑微分法）</h4><p><img src="/images/tongji-calculus-1-4/image-20210504153757910.png" alt=""></p><p>例1：<script type="math/tex">\displaystyle\int\tan x dx=\int\frac{\sin x}{\cos x}dx=-\int\frac{1}{\cos x}d(\cos x)=-\ln|\cos x|+c</script></p><p>例2：<script type="math/tex">\displaystyle\int\frac{1}{\sin x}dx=\int\csc x dx=\int\frac{\csc x(\csc x+\cot x)}{\csc x +\cot x}dx\\\displaystyle=-\int\frac{d(\cot x+\csc x)}{\csc x+\cot x}=-\ln|\csc x+\cot x|+c</script></p><p><strong>note：</strong><script type="math/tex">一般地，\\(1)对于\sin^{2k+1}x\cos^nx或\sin^nx\cos^{2k+1}x(其中k\in N)型函数的积分，\\总可依次作变换\sin^2x=1-\cos^2或\cos^2x=1-\sin^2x，求得结果。\\(2)对于\sin^{2k}x\cos^{2l}x(k,l\in N)型函数的积分，总可利用三角恒等式\\\sin^2x=\frac{1}{2}(1-\cos 2x),\cos^2x=\frac{1}{2}(1+\cos 2x)化成\cos 2x的多项式，然后用下例的方法求得结果。\\</script></p><p>例：<script type="math/tex">\begin{aligned}\int\sin^2x\cos^4xdx&=\frac{1}{8}\int(1-\cos2x)(1+\cos2x)^2dx\\&=\frac{1}{8}\int(1+\cos2x-\cos^22x-\cos^32x)dx\\&=\frac{1}{8}\int(\cos2x-\cos^32x)dx+\frac{1}{8}\int(1-\cos^22x)dx\\&=\frac{1}{8}\sin^22x*\frac{1}{2}d(\sin2x)+\frac{1}{8}\int\frac{1}{2}(1-\cos4x)dx\\&=\frac{1}{48}\sin^32x+\frac{x}{16}-\frac{1}{64}\sin 4x+C \end{aligned}</script></p><h4 id="二、第二类换元法"><a href="#二、第二类换元法" class="headerlink" title="二、第二类换元法"></a>二、第二类换元法</h4><p><img src="/images/tongji-calculus-1-4/image-20210504162026244.png" alt=""></p><p><strong>case1：无理数（有根号但无法用第一类换元积分法求解的）</strong></p><p>例：<script type="math/tex">\displaystyle\int\frac{1}{1+\sqrt x}dx\\\displaystyle令x=t^2,原式=2\int\frac{t}{1+t}dt=2\int(1-\frac{1}{1+t})dt\\=2[t-\ln|1+t|]+c=2\sqrt x-2\ln(1+\sqrt x)+c</script></p><p><strong>case2：平方和差</strong></p><h4 id="三、公式总结"><a href="#三、公式总结" class="headerlink" title="三、公式总结"></a>三、公式总结</h4><p>(1)$\int k dx=kx+C$<br>(2)$\int x^\mu dx=\frac{x^{\mu+1}}{\mu+1}+C$<br>(3)$\int \frac{dx}{x}=ln|x|+C$<br>(4)$\int \frac{dx}{1+x^2}=\arctan x+C$<br>(5)$\int\frac{dx}{\sqrt{1-x^2}}=\arcsin x+C$<br>(6)$\int \cos x dx=\sin x +C$<br>(7)$\int\sin x dx=-\cos x+C$<br>(8)$\int\frac{dx}{\cos^2x}=\sec^2xdx=\tan x+C$<br>(9)$\int\frac{dx}{\sin^2x}=\csc^2xdx=-\cot x+C$<br>(10)$\int\sec x \tan x dx=\sec x+C$<br>(11)$\int\csc x \cot x dx=-\csc x+C$<br>(12)$\int e^x dx=e^x+C$<br>(13)$\int a^x dx=\frac{a^x}{\ln a}+C$</p><p><img src="/images/tongji-calculus-1-4/GMOUH2ANJE1N%5BWS%60YMZI@P0.png" alt=""></p><center><span style="color:blue;font-size:15px">2021/5/6</span></center><h3 id="第三节-分部积分法"><a href="#第三节-分部积分法" class="headerlink" title="第三节 分部积分法"></a>第三节 分部积分法</h3><p>设$u(x),v(x)有连续一阶导数，则\\\displaystyle\int udv=uv-\int vdu$</p><p>选取原则是vdu要好做</p><p>case1：<script type="math/tex">(幂函数*指数函数)指数函数到后面，降低幂函数的次数\\\displaystyle\int xe^xdx=\int xd(e^x)=xe^x-\int e^x dx</script></p><p>case2：(幂函数*三角函数)三角函数到后面，降低幂函数的次数​</p><p>case3：<script type="math/tex">(幂函数*对数函数)幂函数到后面，对对数函数求导\\\displaystyle\int x^2\ln xdx=\int\ln xd(\frac{1}{3}x^3)=\frac{1}{3}x^3\ln x-\int\frac{1}{3}x^3d(\ln x)</script></p><p>case4：(幂函数*反三角函数)幂函数到后面，对反三角函数求导</p><p>case5：(指数函数*sinx/cosx)都可以到后面去，进行两次分部积分后还原</p><p>case6：$(\sec^nx/\csc^n x)$（n为奇数）进行两次分部积分后还原，偶数次用换元法就能解</p><h4 id="内容小结-1"><a href="#内容小结-1" class="headerlink" title="内容小结"></a>内容小结</h4><p><img src="/images/tongji-calculus-1-4/image-20210506111708176.png" alt=""></p><h3 id="第四节-有理函数的不定积分"><a href="#第四节-有理函数的不定积分" class="headerlink" title="第四节 有理函数的不定积分"></a>第四节 有理函数的不定积分</h3><h4 id="一、有理函数的积分"><a href="#一、有理函数的积分" class="headerlink" title="一、有理函数的积分"></a>一、有理函数的积分</h4><p>两个多项式的商称为<strong>有理函数</strong>，当分子多项式的次数小于分母多项式的次数，称为<strong>真分式</strong>，否则称为<strong>假分式</strong></p><p>利用<strong>多项式的除法</strong>，总可以将一个假分式化成一个多项式与一个真分式之和的形式</p><p>对于能够因式分解的真分式，分子不变，分母因式分解，拆成部分和</p><p>因式分解例：<script type="math/tex">\displaystyle case1:R(x)=\frac{2x+3}{(x-2)(2x+1)}=\frac{A}{x-2}+\frac{B}{2x+1}\\\displaystyle case2:R(x)=\frac{x^2-3x+1}{(x-1)^2(2x+1)}=\frac{A}{x-1}+\frac{B}{(x-1)^2}+\frac{C}{2x+1}\\\qquad (*)A(x-1)(2x+1)+B(2x+1)+C(x-1)^2=x^2-3x+1\\\displaystyle case3:R(x)=\frac{3x+2}{x^2(x^2+2x+3)}=\frac{A}{x}+\frac{B}{x^2}+\frac{Cx+D}{x^2+2x+3}</script></p><h4 id="二、可化为有理函数的积分"><a href="#二、可化为有理函数的积分" class="headerlink" title="二、可化为有理函数的积分"></a>二、可化为有理函数的积分</h4><p>含sin和cos函数的有理化：<script type="math/tex">\sin x和\cos x都可以用\tan \frac{x}{2}的有理式表示\\如果作变换u=\tan\frac{x}{2}(-\pi<x<\pi)，那么\\\sin x=\frac{2u}{1+u^2}，\cos x=\frac{1-u^2}{1+u^2}，而x=2\arctan u，从而 dx=\frac{2}{1+u^2}du</script></p><p>如果被积函数中含有简单根式$\displaystyle\sqrt[n]{ax+b}或\sqrt[n]{\frac{ax+b}{cx+d}}$，可以令这个简单根式为u，由于这样的变换具有反函数，且反函数是u的有理函数，因此原积分即可化为有理函数的积分</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数</title>
      <link href="2021/04/12/calculus/"/>
      <url>2021/04/12/calculus/</url>
      
        <content type="html"><![CDATA[<h2 id="高等数学常用基础知识"><a href="#高等数学常用基础知识" class="headerlink" title="高等数学常用基础知识"></a>高等数学常用基础知识</h2><h3 id="基本基础知识"><a href="#基本基础知识" class="headerlink" title="基本基础知识"></a>基本基础知识</h3><ul><li>$(a+b)^n=\displaystyle\sum_{k=0}^nC_n^ka^kb^{n-k}$</li><li>$a^3+b^3=(a+b)(a^2-ab+b^2)$</li><li>$a^3-b^3=(a-b)(a^2+ab+b^2)$</li><li>$\displaystyle(a-1)(b-1)=ab-a-b+1\qquad例：e^3-e^2-e+1=(e^2-1)(e-1)$</li><li>$\displaystyle\log_ae=\frac{\ln e}{\ln a}(对数换底公式）$</li><li>$\displaystyle(a+b)^x=a^x(1+\frac{b}{a})^x$</li><li>$\displaystyle\arcsin x+\ arccos x=\frac{\pi}{2}$</li><li><script type="math/tex; mode=display">\displaystyle \arctan x+\arctan\frac{1}{x}=\begin{cases}+\frac{\pi}{2}\quad,x>0\\-\frac{\pi}{2}\quad,x<0\end{cases}</script></li><li>$\displaystyle \frac{1}{x^2-1}=\frac{1}{(x+1)(x-1)}=\frac{(x+1)-(x-1)}{2(x+1)(x-1)}=\frac{1}{2}[\frac{1}{x-1}-\frac{1}{x+1}]$</li><li>裂项公式：$\displaystyle \frac{1}{(ax+b)(cx+d)}=\frac{1}{ad-bc}[\frac{a}{ax+b}-\frac{c}{cx+d}]$</li><li>$\displaystyle\tan x=\csc 2x-\cot 2x=\frac{1-\cos 2x}{\sin 2x}=\frac{\sin 2x}{1+\cos 2x}=\frac{1}{\csc 2x+\cot 2x}$</li><li>$\displaystyle1+\sin x=(\sin\frac{x}{2}+cos\frac{x}{2})^2$</li><li>$\displaystyle\sin x+\cos x=\sqrt2\sin (\frac{\pi}{4}+x)=\sqrt2\cos (\frac{\pi}{4}-x)$</li><li>$\displaystyle a^2+b^2\geq2ab$</li><li>$\sqrt {x^2}=|x|$</li><li>$||a|-|b||\leq|a-b|$</li><li><p>万能公式：把所有三角函数都化成只有$\tan\frac a2$的多项式<br>$\sin a=\frac{2\tan\frac a2}{1+\tan^2\frac a2}$<br>$\cos a=\frac{1-\tan^2\frac a2}{1+\tan^2\frac a2}$<br>$\tan a=\frac{2\tan\frac a2}{1-\tan^2\frac a2}$</p></li><li><p>一元三次方程的求解：</p><p>例：$x^3-x^2-x-2=0$</p><p>（1）代入0，$\pm 1$，$\pm 2$，$\pm 3$求出一个解，本题为2</p><p>（2）$(x-2)(x^2+x+1)=x^3-x^2-x-2=0$（从前往后填，缺哪个补哪个）</p></li></ul><h3 id="基本初等函数"><a href="#基本初等函数" class="headerlink" title="基本初等函数"></a>基本初等函数</h3><ul><li>幂函数：$y=x^u$</li><li>指数函数：$y=a^x$</li><li>对数函数：$y=\log_ax$</li><li>三角函数</li><li>反三角函数</li></ul><p>由常数和基本初等函数经过有限次的四则运算，以及有限次的复合步骤所构成的并且可以由一个式子所表示的函数称为初等函数。</p><h4 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h4><ul><li>等差数列<ul><li>通项公式：$a_n=a_1+(n-1)d$</li><li>前n项的和：$na_1+\frac{n(n-1)d}{2}=\frac{n}{2}(a_1+a_n)$</li></ul></li><li>等比数列<ul><li>通项公式：$a_n=a_1*r^{n-1}$</li><li>前n项的和：$\frac{a_1(1-r^n)}{1-r}$</li></ul></li></ul><h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><p>sin 正弦 对比斜</p><p>cos 余弦 斜比邻</p><p>tan 正切  对比邻</p><p>$\csc\alpha=\frac{1}{\sin\alpha}$ 余割 </p><p>$\sec\alpha=\frac{1}{\cos\alpha}$ 正割</p><p>$\cot\alpha=\frac{1}{\tan\alpha}$ 余切 </p><p><img src="/images/calculus/image-20210412213745351.png" alt="几何意义（1）"></p><h4 id="三角函数公式"><a href="#三角函数公式" class="headerlink" title="三角函数公式"></a>三角函数公式</h4><p>$\sec^2\alpha-\tan^2\alpha=1$</p><p>$\csc^2\alpha-\cot^2\alpha=1$</p><p>$三角函数(x)=co三角函数(\frac{\pi}{2}-x)$</p><h5 id="和差公式："><a href="#和差公式：" class="headerlink" title="和差公式："></a>和差公式：</h5><p>$\sin(\alpha\pm\beta)=\sin\alpha\cos\beta\pm\cos\alpha\sin\beta$</p><p>$\cos(\alpha\pm\beta)=\cos\alpha\cos\beta\mp\sin\alpha\sin\beta$</p><p>$\tan(\alpha\pm\beta)=\frac{\tan\alpha\pm\tan\beta}{1\mp\tan\alpha\tan\beta}$</p><h5 id="倍角公式："><a href="#倍角公式：" class="headerlink" title="倍角公式："></a>倍角公式：</h5><p>$\sin(2\alpha)=2\sin\alpha\cos\alpha$</p><p>$\begin{aligned}\cos(2\alpha)&amp;=\cos^2\alpha-\sin^2\alpha\\&amp;=2\cos^2\alpha-1\\&amp;=1-2\sin^2\alpha\end{aligned}$</p><p>$\tan(2\alpha)=\frac{2\tan\alpha}{1-\tan^2\alpha}$</p><h5 id="半角公式："><a href="#半角公式：" class="headerlink" title="半角公式："></a>半角公式：</h5><p>$\sin^2\frac{\alpha}{2}=\frac{1-\cos\alpha}{2}$</p><p>$\cos^2\frac{\alpha}{2}=\frac{1+\cos\alpha}{2}$</p><h5 id="和差化积公式："><a href="#和差化积公式：" class="headerlink" title="和差化积公式："></a>和差化积公式：</h5><p>$\sin\alpha+\sin\beta=2\sin\frac{\alpha+\beta}{2}\cos\frac{\alpha-\beta}{2}$</p><p>$\sin\alpha-\sin\beta=2\sin\frac{\alpha-\beta}{2}\cos\frac{\alpha+\beta}{2}$</p><p>$\cos\alpha+\cos\beta=2\cos\frac{\alpha+\beta}{2}\cos\frac{\alpha-\beta}{2}$</p><p>$\cos\alpha-\cos\beta=-2\sin\frac{\alpha+\beta}{2}\sin\frac{\alpha-\beta}{2}$</p><h5 id="积化和差公式："><a href="#积化和差公式：" class="headerlink" title="积化和差公式："></a>积化和差公式：</h5><p>$\sin\alpha\cos\beta=\frac{\sin(\alpha-\beta)+\sin(\alpha+\beta)}{2}$</p><p>$\sin\alpha\sin\beta=\frac{\cos(\alpha-\beta)-\cos(\alpha+\beta)}{2}$</p><p>$\cos\alpha\cos\beta=\frac{\cos(\alpha-\beta)+\cos(\alpha+\beta)}{2}$</p><center><span style="color:blue;font-size:15px">2021/6/11</span></center><h2 id="考研高等数学框架"><a href="#考研高等数学框架" class="headerlink" title="考研高等数学框架"></a>考研高等数学框架</h2><p><img src="/images/calculus/image-20210611105455028.png" alt=""></p><p><strong>整个考研数学中，一元微积分是重点和难点，后面画圈划线的是难点，是强化阶段的任务</strong></p><h2 id="第一章-函数-极限-连续"><a href="#第一章-函数-极限-连续" class="headerlink" title="第一章 函数 极限 连续"></a>第一章 函数 极限 连续</h2><p>极限是第一章的重点和难点</p><h3 id="第一节-函数"><a href="#第一节-函数" class="headerlink" title="第一节 函数"></a>第一节 函数</h3><h3 id="一、考试内容概要："><a href="#一、考试内容概要：" class="headerlink" title="一、考试内容概要："></a>一、考试内容概要：</h3><h4 id="一-函数的概念及常见函数"><a href="#一-函数的概念及常见函数" class="headerlink" title="(一)函数的概念及常见函数"></a>(一)函数的概念及常见函数</h4><ol><li><p>函数概念（两要素：定义域，对应规则）</p></li><li><p>复合函数（不是任意两个函数都可以符合，要求内层函数的值域和外层函数的定义域交集不为空</p></li><li><p>反函数</p><p>存在反函数的充要条件：$\forall x_1\not=x_2\in D,有f(x_1)\not=f(x_2)$</p></li><li><p>初等函数</p><p>由5个基本初等函数（幂、指、对、三角、反三角）经过有限次的四则和复合构成的可以用一个式子表示的函数</p></li></ol><h4 id="二-函数的性质"><a href="#二-函数的性质" class="headerlink" title="(二)函数的性质"></a>(二)函数的性质</h4><ol><li><p>单调性</p></li><li><p>奇偶性</p><p>前提：定义域关于原点对称</p><p>常见的奇函数：$\ln\frac{1-x}{1+x}$，$\ln(x+\sqrt{1+x^2})$，$\frac{e^x-1}{e^x+1}$，$f(x)-f(-x)$</p><p>常见的偶函数：$f(x)+f(-x)$</p></li><li><p>周期性</p></li><li><p>有界性</p></li></ol><h3 id="二、常考题型与典型例题"><a href="#二、常考题型与典型例题" class="headerlink" title="二、常考题型与典型例题"></a>二、常考题型与典型例题</h3><h4 id="题型一、函数有界性、单调性、周期性及奇偶性的判定"><a href="#题型一、函数有界性、单调性、周期性及奇偶性的判定" class="headerlink" title="题型一、函数有界性、单调性、周期性及奇偶性的判定"></a>题型一、函数有界性、单调性、周期性及奇偶性的判定</h4><h4 id="题型二、复合函数"><a href="#题型二、复合函数" class="headerlink" title="题型二、复合函数"></a>题型二、复合函数</h4><h3 id="第二节-极限"><a href="#第二节-极限" class="headerlink" title="第二节 极限"></a>第二节 极限</h3><h3 id="一、考试内容概要"><a href="#一、考试内容概要" class="headerlink" title="一、考试内容概要"></a>一、考试内容概要</h3><h4 id="一-极限的概念"><a href="#一-极限的概念" class="headerlink" title="(一)极限的概念"></a>(一)极限的概念</h4><ol><li><p>数列的极限</p><p>$(\varepsilon-N)$ ：$\forall\varepsilon&gt;0，\exists N，当 n&gt;N时，有|x_n-a|&lt;\varepsilon$</p></li><li><p>函数的极限</p><p>自变量趋于无穷大时函数的极限：</p><p>和数列极限类似，有三个（正无穷，负无穷，无穷）</p><p>自变量趋于有限值时函数的极限：</p><p>$(\varepsilon-\delta)$ ：$若\forall\varepsilon&gt;0，\exists\delta&gt;0，当0&lt;|x-x_0|&lt;\delta时，恒有|f(x)-A|&lt;\varepsilon，则称A为x\to x_0时f(x)的极限$。</p></li></ol><h4 id="二-极限的性质（数列和函数对比）"><a href="#二-极限的性质（数列和函数对比）" class="headerlink" title="(二)极限的性质（数列和函数对比）"></a>(二)极限的性质（数列和函数对比）</h4><ol><li><p>有界性（收敛数列必有界；函数极限存在则局部有界）</p></li><li><p>保号性（极限值保函数值；函数值保极限值）</p></li><li><p>极限值与无穷小之间的关系</p><p>$\lim f(x)=A\Leftrightarrow f(x)=A +a(x),其中\lim a(x)= 0$</p></li></ol><h4 id="三-极限存在准则（一般考数列极限）"><a href="#三-极限存在准则（一般考数列极限）" class="headerlink" title="(三)极限存在准则（一般考数列极限）"></a>(三)极限存在准则（一般考数列极限）</h4><ol><li>夹逼准则</li><li>单调有界准则</li></ol><h4 id="四-无穷小"><a href="#四-无穷小" class="headerlink" title="(四)无穷小"></a>(四)无穷小</h4><ol><li>无穷小量的概念（极限为0的<strong>变量</strong>）</li><li>无穷小的比较（阶）</li><li>无穷小的性质（有限个无穷小的和、积是无穷小；无穷小与有界量的乘积是无穷小）</li></ol><h4 id="五-无穷大"><a href="#五-无穷大" class="headerlink" title="(五)无穷大"></a>(五)无穷大</h4><ol><li><p>无穷大量的概念（无穷大包含正无穷和负无穷）</p><p>$\forall M&gt;0,\exists\delta&gt;0,当0&lt;|x-x_0|&lt;\delta时，恒有|f(x)|&gt;M,称f(x)为x\to x_0时的无穷大量$</p></li><li><p>常用的一些无穷大量的比较（对&lt;幂&lt;指&lt;阶乘&lt;幂指）</p></li><li><p>无穷大量的性质（有限个无穷大的积是无穷大（和不一定）；（无穷大与有界变量的积不一定是无穷大）；无穷大量与有界变量的和是无穷大）</p></li><li><p>无穷大量与无界变量的关系（无穷大量必为无界变量，而无界变量不一定是无穷大量）</p></li><li><p>无穷大量与无穷小量的关系（在同一极限过程中）</p></li></ol><center><span style="color:blue;font-size:15px">2021/6/13</span></center><h3 id="二、常考题型与典型例题-1"><a href="#二、常考题型与典型例题-1" class="headerlink" title="二、常考题型与典型例题"></a>二、常考题型与典型例题</h3><h4 id="题型一、极限的概念性质及存在准则"><a href="#题型一、极限的概念性质及存在准则" class="headerlink" title="题型一、极限的概念性质及存在准则"></a>题型一、极限的概念性质及存在准则</h4><h4 id="题型二、求极限"><a href="#题型二、求极限" class="headerlink" title="题型二、求极限"></a>题型二、求极限</h4><p>方法1：利用基本极限求极限<br>方法2：利用等价无穷小代换求极限<br>方法3：利用有理运算法则求极限<br>方法4：利用洛必达法则求极限<br>方法5：利用泰勒公式求极限<br>方法6：利用夹逼原理求极限<br>方法7：利用单调有界准则求极限<br>方法8：利用定积分定义求极限(见第五章)</p><h4 id="题型三、无穷小量阶的比较"><a href="#题型三、无穷小量阶的比较" class="headerlink" title="题型三、无穷小量阶的比较"></a>题型三、无穷小量阶的比较</h4><center><span style="color:blue;font-size:15px">2021/6/14</span></center><h3 id="第三节-函数的连续性"><a href="#第三节-函数的连续性" class="headerlink" title="第三节 函数的连续性"></a>第三节 函数的连续性</h3><h3 id="一、考试内容概要-1"><a href="#一、考试内容概要-1" class="headerlink" title="一、考试内容概要"></a>一、考试内容概要</h3><h4 id="一-连续性的概念"><a href="#一-连续性的概念" class="headerlink" title="(一)连续性的概念"></a>(一)连续性的概念</h4><p>在某点极限值等于函数值；开区间连续；闭区间连续</p><h4 id="二-间断点及其分类"><a href="#二-间断点及其分类" class="headerlink" title="(二)间断点及其分类"></a>(二)间断点及其分类</h4><p>间断点的定义：f(x)在某点去心领域有定义，但在该点不连续</p><p>间断点的分类：左右极限都存在（第一类：可去、跳跃）至少有一个不存在（第二类：无穷、振荡）</p><h4 id="三-连续性的运算与性质"><a href="#三-连续性的运算与性质" class="headerlink" title="(三)连续性的运算与性质"></a>(三)连续性的运算与性质</h4><p>连续函数的四则（商的时候分母不等于0）、复合仍为连续函数</p><p>基本初等函数在其定义域内连续，初等函数在其定义区间内连续</p><h4 id="四-闭区间上连续函数的性质"><a href="#四-闭区间上连续函数的性质" class="headerlink" title="(四)闭区间上连续函数的性质"></a>(四)闭区间上连续函数的性质</h4><p> 有界性定理、最大值最小值定理、介值定理（和推论）、零点定理（用的多）</p><h3 id="二、常考题型与典型例题-2"><a href="#二、常考题型与典型例题-2" class="headerlink" title="二、常考题型与典型例题"></a>二、常考题型与典型例题</h3><h4 id="题型一、讨论函数连续性及间断点的类型（重点，基础）（目前不熟练）"><a href="#题型一、讨论函数连续性及间断点的类型（重点，基础）（目前不熟练）" class="headerlink" title="题型一、讨论函数连续性及间断点的类型（重点，基础）（目前不熟练）"></a>题型一、讨论函数连续性及间断点的类型（重点，基础）（目前不熟练）</h4><h4 id="题型二、有关闭区间上连续函数性质的证明题（难点）"><a href="#题型二、有关闭区间上连续函数性质的证明题（难点）" class="headerlink" title="题型二、有关闭区间上连续函数性质的证明题（难点）"></a>题型二、有关闭区间上连续函数性质的证明题（难点）</h4><center><span style="color:blue;font-size:15px">2021/6/17</span></center><h2 id="第二章-导数与微分"><a href="#第二章-导数与微分" class="headerlink" title="第二章 导数与微分"></a>第二章 导数与微分</h2><h3 id="一、考试内容概要：-1"><a href="#一、考试内容概要：-1" class="headerlink" title="一、考试内容概要："></a>一、考试内容概要：</h3><h4 id="一-导数与微分的概念"><a href="#一-导数与微分的概念" class="headerlink" title="(一)导数与微分的概念"></a>(一)导数与微分的概念</h4><ol><li><p>导数的概念：（左右导数；区间上可导（开，闭）及导函数）导数反映了函数在一点的变化率</p><p>若<script type="math/tex">\displaystyle\lim_{\triangle x\to 0}\frac{f(x_0+\triangle x)-f(x_0)}{\triangle x}=\lim_{x \to x_0}\frac{f(x)-f(x_0)}{x-x_0}=\lim_{\triangle x\to 0}\frac{\triangle y}{\triangle x}存在，则称f(x)在x_0点可导</script></p><p>记作<script type="math/tex">f'(x_0)\quad或y'|_{x=x_0}\quad或\frac{dy}{dx}|_{x=x_0}</script></p></li><li><p>微分的概念：微分反映了函数的改变量（或微分是函数改变量的线性主部）</p><p>如果<script type="math/tex">\triangle y=f(x_0+\triangle x)- f(x_0)=A\triangle x+o(\triangle x)(\triangle x\to 0)</script></p><p>那么<script type="math/tex">A\triangle x称为f(x)在x_0点的微分，记为dy=A\triangle x，dy是\triangle y的线性主部</script></p></li><li><p>导数和微分的几何意义：（导数代表切线的斜率；切线、法线方程；微分代表切线上的增量）</p><p><img src="/images/calculus/image-20210617204300947.png" alt=""></p></li><li><p>连续，可导，可微之间的关系：（可微$\Leftrightarrow$可导；可导$\Rightarrow$连续；连续$\not\Rightarrow$可导）</p><p><strong>（重要）</strong>f(x)在$x_0$点可导$\not\Rightarrow$f(x)在$x_0$点连续；f(x)在$x_0$点可导$\not\Rightarrow$f(x)在$x_0$点存在</p><p>例子：<script type="math/tex">\displaystyle f(x)=\begin{cases}x^2\sin\frac 1 x,x\not=0\\0\qquad \quad,x=0\end{cases}</script>在0点导数等于0（定义算）但是在0点导数无极限</p></li></ol><h4 id="二-导数公式与求导法则"><a href="#二-导数公式与求导法则" class="headerlink" title="(二)导数公式与求导法则"></a>(二)导数公式与求导法则</h4><ol><li>基本初等函数的导数公式</li><li>求导法则（有理运算；复合函数；隐函数；反函数；参数方程；对数求导法）</li></ol><h4 id="三-高阶导数"><a href="#三-高阶导数" class="headerlink" title="(三)高阶导数"></a>(三)高阶导数</h4><ol><li>高阶导数的定义</li><li>常用的高阶导数公式</li></ol><center><span style="color:blue;font-size:15px">2021/6/18</span></center><h3 id="二、常考题型与典型例题："><a href="#二、常考题型与典型例题：" class="headerlink" title="二、常考题型与典型例题："></a>二、常考题型与典型例题：</h3><h4 id="题型一、导数定义"><a href="#题型一、导数定义" class="headerlink" title="题型一、导数定义"></a>题型一、导数定义</h4><h4 id="题型二、复合函数、隐函数、参数方程求导"><a href="#题型二、复合函数、隐函数、参数方程求导" class="headerlink" title="题型二、复合函数、隐函数、参数方程求导"></a>题型二、复合函数、隐函数、参数方程求导</h4><h4 id="题型三、高阶导数"><a href="#题型三、高阶导数" class="headerlink" title="题型三、高阶导数"></a>题型三、高阶导数</h4><ol><li>公式法</li><li>y’、y’’、···归纳法</li><li>泰勒</li></ol><h4 id="题型四、导数应用"><a href="#题型四、导数应用" class="headerlink" title="题型四、导数应用"></a>题型四、导数应用</h4><ol><li>导数的几何意义（直角坐标、参数方程、极坐标的切线、法线）</li><li>相关变化率</li></ol><center><span style="color:blue;font-size:15px">2021/6/20</span></center><h2 id="第三章-微分中值定理及导数应用"><a href="#第三章-微分中值定理及导数应用" class="headerlink" title="第三章 微分中值定理及导数应用"></a>第三章 微分中值定理及导数应用</h2><h3 id="一、考试内容概要-2"><a href="#一、考试内容概要-2" class="headerlink" title="一、考试内容概要"></a>一、考试内容概要</h3><h4 id="一-微分中值定理"><a href="#一-微分中值定理" class="headerlink" title="(一)微分中值定理"></a>(一)微分中值定理</h4><ol><li><p>费马引理、罗尔定理、拉格朗日中值定理、柯西中值定理</p><p><strong>中值定理的本质：</strong></p><p>（1）建立<strong>一阶导数</strong>和函数之间的关系</p><p>（2）罗-拉-柯（左边的是右边的特例，右边的是左边的推广）（拉和柯都是有罗证得）（罗和拉使用较多）</p></li><li><p>泰勒公式（皮亚诺型余项；拉格朗日型余项）</p><p><strong>泰勒公式的本质：</strong></p><p>（1）建立<strong>高阶导数</strong>和函数之间的关系</p><p>（2）用多项式逼近函数</p><p><strong>两种带余项的泰勒公式的不同：</strong></p><p>（1）条件不同，皮要求在点$x_0$有直至n阶的导数；拉要求在含有$x_0$的开区间（a,b)内有n+1阶的导数</p><p>（2）<script type="math/tex">\begin{cases}皮:R_n(x)=o(x-x_n)^n（定性）——局部泰勒公式\begin{cases}极限\\极值\end{cases}\\拉:R_n(x)=\displaystyle\frac{f^{n+1}(\xi)}{(n+1)!}(x-x_0)^{n+1}（定量）——整体泰勒公式\begin{cases}最值\\不等式\end{cases}\end{cases}</script></p><p><strong>四大中值定理：</strong>（罗尔、拉格朗日、柯西中值定理；带拉格朗日余项的泰勒公式）</p></li></ol><center><span style="color:blue;font-size:15px">2021/6/21</span></center><h4 id="二-导数的应用"><a href="#二-导数的应用" class="headerlink" title="(二)导数的应用"></a>(二)导数的应用</h4><ol><li>导数的单调性  </li><li>函数的极值（驻点，不可导点）</li><li>函数的最大值与最小值（驻点，不可导点，端点）（唯一极值点也是最值点）</li><li>曲线的凹凸性（拐点，一必要两充分和驻点类似）</li><li>曲线的渐近线（水平、垂直、斜）</li><li>函数的作图（单调性、极值、曲线的凹凸性、拐点和渐近线）</li><li>曲线的弧微分和曲率（$K=\frac{|y’’|}{(1+y’^2)^{\frac{3}{2}}}$）</li></ol><h3 id="二、常考题型与典型例题-3"><a href="#二、常考题型与典型例题-3" class="headerlink" title="二、常考题型与典型例题"></a>二、常考题型与典型例题</h3><p>前两类是基本题，后三类是难题，最后一类最难</p><h4 id="题型一、函数的极值和最值，曲线的凹向与拐点"><a href="#题型一、函数的极值和最值，曲线的凹向与拐点" class="headerlink" title="题型一、函数的极值和最值，曲线的凹向与拐点"></a>题型一、函数的极值和最值，曲线的凹向与拐点</h4><h4 id="题型二、曲线的渐近线"><a href="#题型二、曲线的渐近线" class="headerlink" title="题型二、曲线的渐近线"></a>题型二、曲线的渐近线</h4><h4 id="题型三、方程的根"><a href="#题型三、方程的根" class="headerlink" title="题型三、方程的根"></a>题型三、方程的根</h4><p>（1）存在性：零点定理，罗尔定理（2）个数：单调性</p><h4 id="题型四、不等式的证明-（薄弱）"><a href="#题型四、不等式的证明-（薄弱）" class="headerlink" title="题型四、不等式的证明 （薄弱）"></a>题型四、不等式的证明 （薄弱）</h4><p>（1）单调性（2）拉格朗日中值定理（3）最大最小值</p><h4 id="题型五、中值定理的证明题"><a href="#题型五、中值定理的证明题" class="headerlink" title="题型五、中值定理的证明题"></a>题型五、中值定理的证明题</h4><center><span style="color:blue;font-size:15px">2021/6/25</span></center><h2 id="第四章-不定积分"><a href="#第四章-不定积分" class="headerlink" title="第四章 不定积分"></a>第四章 不定积分</h2><h3 id="一、考试内容概要-3"><a href="#一、考试内容概要-3" class="headerlink" title="一、考试内容概要"></a>一、考试内容概要</h3><h4 id="一-不定积分的概念与性质"><a href="#一-不定积分的概念与性质" class="headerlink" title="(一)不定积分的概念与性质"></a>(一)不定积分的概念与性质</h4><ol><li><p>原函数（F’(x)=f(x)；F(x)是f(x)的一个原函数）</p></li><li><p>不定积分（原函数的全体（一个函数族））</p></li><li><p>不定积分的几何意义（平面上的曲线（连续且光滑，因为可导））</p></li><li><p>原函数存在定理 （连续函数一定有原函数；若有第一类间断点，则没有原函数；振荡可能有原函数）</p><p>有第一类间断点会让其积分曲线不光滑，导致某些点不可导。</p></li><li><p>不定积分的性质</p></li></ol><h4 id="二-不定积分基本公式"><a href="#二-不定积分基本公式" class="headerlink" title="(二)不定积分基本公式"></a>(二)不定积分基本公式</h4><h4 id="三-三种主要积分法"><a href="#三-三种主要积分法" class="headerlink" title="(三)三种主要积分法"></a>(三)三种主要积分法</h4><ol><li>第一类换元法（凑微分法）</li><li>第二类换元法（基本都是用来去根号）</li><li>分部积分法</li></ol><h4 id="四-三类常见可积函数的积分"><a href="#四-三类常见可积函数的积分" class="headerlink" title="(四)三类常见可积函数的积分"></a>(四)三类常见可积函数的积分</h4><p>三类的基础都是有理函数积分</p><ol><li>有理函数积分（$\int R(x)dx$）（一般加项减项拆，凑微分降幂）</li><li>三角有理式积分（$\int R(\sin x,\cos x)dx$）（一般三角变形，换元，分部）</li><li>简单无理式积分（$\int R(x,\sqrt[n]{\frac{ax+b}{cx+d}})dx$）（一般直接让根式等于t换元）</li></ol><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><strong>2+3+3</strong>（<strong>两个概念</strong>（原函数，不定积分）<strong>三种方法</strong>（两种换元，分部积分）<strong>三类积分</strong>（有理函数积分，三角有理式的积分，带有简单无理式的积分）)<br><strong>重点：</strong>三种方法<br><strong>尺度：</strong>考研不会考特殊方法的积分，把基本方法练会就可以</p><h3 id="二、常考题型与典型例题-4"><a href="#二、常考题型与典型例题-4" class="headerlink" title="二、常考题型与典型例题"></a>二、常考题型与典型例题</h3><h4 id="求不定积分-换元、分部"><a href="#求不定积分-换元、分部" class="headerlink" title="求不定积分(换元、分部)"></a>求不定积分(换元、分部)</h4><center><span style="color:blue;font-size:15px">2021/6/26</span></center><h2 id="第五章-定积分与反常积分"><a href="#第五章-定积分与反常积分" class="headerlink" title="第五章 定积分与反常积分"></a>第五章 定积分与反常积分</h2><h3 id="第一节-定积分"><a href="#第一节-定积分" class="headerlink" title="第一节 定积分"></a>第一节 定积分</h3><h3 id="一、考试内容概要-4"><a href="#一、考试内容概要-4" class="headerlink" title="一、考试内容概要"></a>一、考试内容概要</h3><h4 id="一-定积分概念"><a href="#一-定积分概念" class="headerlink" title="(一)定积分概念"></a>(一)定积分概念</h4><ol><li><p>定积分的定义：（定积分是一个<strong>常数</strong>，一个和数的极限，仅与积分区间和被积函数有关，与积分变量无关）</p><p>（分割、求和、取极限）<script type="math/tex">\displaystyle\lim_{\lambda\to 0}\sum^n_{i=1}f(\xi_i)\triangle x_i=\int^b_af(x)dx</script></p><p>若极限存在，则与$\xi_i$的<strong>取法</strong>和区间[a,b]的<strong>分法</strong>无关</p><p>因此，如果积分$\int^1_0f(x)dx$存在，可以将区间n等分，此时$\triangle x_i=\frac{1}{n}$，取右端点$\xi_i=\frac i n$，由定积分的定义得</p><p>:<script type="math/tex">\displaystyle \int ^1_0f(x)dx=\lim_{\lambda\to 0}\sum^n_{i=1}f(\xi_i)\triangle x_i=\lim_{n\to\infty}\frac 1 n \sum^n_{i=1}f(\frac i n)</script></p></li><li><p>定积分存在的充分条件（函数连续必存在；有界且有有限个间断点必存在；有有限个第一类间断点必存在）</p></li><li><p>定积分的几何意义（x轴上方的面积减去下方的面积）</p></li></ol><h4 id="二-定积分的性质"><a href="#二-定积分的性质" class="headerlink" title="(二)定积分的性质"></a>(二)定积分的性质</h4><ol><li><p>不等式性质</p><p>(1) 若 $f(x) \leq g(x)$，则 <script type="math/tex">\int_{a}^{b} f(x)dx \leq \int_{a}^{b} g(x)dx</script></p><p>(2) 若 $f(x)$ 在 $[a, b]$ 上连续，则$m(b-a) \leq \int_{a}^{b} f(x)dx \leq M(b-a)$（定积分的估值性）</p><p>(3)<script type="math/tex">|\int_{a}^{b} f(x)dx| \leq \int_{a}^{b}|f(x)|dx</script>（和的绝对值不超过绝对值的和）</p></li><li><p>积分中值定理</p><p>(1) 若 $f(x)$ 在 $[a, b]$ 上连续, 则$\int_{a}^{b} f(x)dx=f(\xi)(b-a) \quad (a&lt;\xi&lt;b)$</p><p>(2) 若 $f(x), g(x)$ 在 $[a, b]$ 上连续， $g(x)$不变号，则<script type="math/tex">\int_{a}^{b} f(x) g(x)dx=f(\xi) \int_{a}^{b} g(x)dx, \quad (a \leq \xi \leq b)</script></p></li></ol><h4 id="三-积分上限的函数"><a href="#三-积分上限的函数" class="headerlink" title="(三)积分上限的函数"></a>(三)积分上限的函数</h4><p>变上限的积分$\displaystyle \int ^x_a f(t)dt$是其上限x的函数，称之为<strong>积分上限函数</strong></p><p>若f(x)为奇函数，那么$\displaystyle \int^x_0f(t)dt$必为偶函数；若f(x)为偶函数，那么$\displaystyle \int^x_0f(t)dt$必为奇函数</p><h4 id="四-定积分的计算"><a href="#四-定积分的计算" class="headerlink" title="(四)定积分的计算"></a>(四)定积分的计算</h4><ol><li>牛顿-莱布尼兹公式（$\displaystyle\int^b_af(x)dx=F(b)-F(a)$）</li><li>换元积分法</li><li>分部积分法</li><li>利用奇偶性和周期性（在对称区间上奇函数的积分为0，偶函数为2倍正区间的积分）</li><li>利用已有公式（华里士公式；$\int^\pi_0xf(\sin x)dx=\frac \pi 2\int^\pi_0f(\sin x)dx$；）</li></ol><h3 id="二、常考题型与典型例题-5"><a href="#二、常考题型与典型例题-5" class="headerlink" title="二、常考题型与典型例题"></a>二、常考题型与典型例题</h3><h4 id="题型一、定积分的概念、性质及几何意义"><a href="#题型一、定积分的概念、性质及几何意义" class="headerlink" title="题型一、定积分的概念、性质及几何意义"></a>题型一、定积分的概念、性质及几何意义</h4><h4 id="题型二、定积分计算"><a href="#题型二、定积分计算" class="headerlink" title="题型二、定积分计算"></a>题型二、定积分计算</h4><h4 id="题型三、变上限定积分"><a href="#题型三、变上限定积分" class="headerlink" title="题型三、变上限定积分"></a>题型三、变上限定积分</h4><center><span style="color:blue;font-size:15px">2021/6/29</span></center><h3 id="第二节-反常积分"><a href="#第二节-反常积分" class="headerlink" title="第二节 反常积分"></a>第二节 反常积分</h3><p>反常积分的本质是”变限积分的极限值”，并非积分本身。</p><h3 id="一、考试内容概要-5"><a href="#一、考试内容概要-5" class="headerlink" title="一、考试内容概要"></a>一、考试内容概要</h3><h4 id="一-无穷区间上的反常积分"><a href="#一-无穷区间上的反常积分" class="headerlink" title="(一)无穷区间上的反常积分"></a>(一)无穷区间上的反常积分</h4><ol><li><p>定义：</p><p>（1）<script type="math/tex">\displaystyle \int^{+\infty}_af(x)dx=\lim_{t\to+\infty}\int^t_af(x)dx</script>；若此极限存在，称反常积分<strong>收敛</strong>，若不存在，称其反常积分<strong>发散</strong></p><p>（2）<script type="math/tex">\displaystyle \int^b_{-\infty}dx=\lim_{t\to-\infty}\int^b_tf(x)dx</script></p><p>（3）若<script type="math/tex">\displaystyle \int^{+\infty}_0f(x)dx和\int^0_{-\infty}f(x)dx</script><strong>都收敛</strong>，则称<script type="math/tex">\displaystyle \int^{+\infty}_{-\infty}f(x)dx</script>收敛</p></li><li><p>p积分：<script type="math/tex">\displaystyle\int^{+\infty}_a\frac{dx}{x^p};\begin{cases}P>1\quad收敛\\P\leq1\quad 发散\end{cases}(a>0)</script></p></li></ol><h4 id="二-无界函数的反常积分"><a href="#二-无界函数的反常积分" class="headerlink" title="(二)无界函数的反常积分"></a>(二)无界函数的反常积分</h4><ol><li><p>定义：</p><p>设a为f(x)的无界点，<script type="math/tex">\displaystyle \int^b_af(x)dx=\lim_{t\to a^+}\int^b_tf(x)dx</script>，其他与无穷区间的定义类似</p></li><li><p>p积分：<script type="math/tex">a是间断点时，\displaystyle\int^b_a\frac{dx}{(x-a)^p}=\begin{cases}p<1\quad收敛\\p\geq1\quad发散\end{cases}\\b是间断点时，\displaystyle\int^b_a\frac{dx}{(b-a)^p}=\begin{cases}p<1\quad收敛\\p\geq1\quad发散\end{cases}</script></p></li></ol><h3 id="二、常考题型与典型例题-6"><a href="#二、常考题型与典型例题-6" class="headerlink" title="二、常考题型与典型例题"></a>二、常考题型与典型例题</h3><h4 id="题型一、反常积分的敛散性"><a href="#题型一、反常积分的敛散性" class="headerlink" title="题型一、反常积分的敛散性"></a>题型一、反常积分的敛散性</h4><h4 id="题型二、反常积分的计算"><a href="#题型二、反常积分的计算" class="headerlink" title="题型二、反常积分的计算"></a>题型二、反常积分的计算</h4><center><span style="color:blue;font-size:15px">2021/7/1</span></center><h2 id="第六章-定积分的应用"><a href="#第六章-定积分的应用" class="headerlink" title="第六章 定积分的应用"></a>第六章 定积分的应用</h2><h3 id="一-、几何应用"><a href="#一-、几何应用" class="headerlink" title="(一)、几何应用"></a>(一)、几何应用</h3><ol><li>平面图形的面积（直角坐标；极坐标（$dS=\frac 1 2r^2d\theta$））（用二重积分的思想）</li><li>旋转体体积（用二重积分的思想做）（$dv=2\pi r(x,y)d\sigma$）</li><li>曲线弧长（直角坐标；参数方程；极坐标）</li><li>旋转体侧面积</li></ol><h3 id="二-、物理应用"><a href="#二-、物理应用" class="headerlink" title="(二)、物理应用"></a>(二)、物理应用</h3><ol><li>压力</li><li>变力做功</li><li>引力</li></ol><h3 id="常考题型"><a href="#常考题型" class="headerlink" title="常考题型"></a>常考题型</h3><p>平面域面积和旋转体体积的计算</p><center><span style="color:blue;font-size:15px">2021/7/2</span></center><h2 id="第七章-常微分方程"><a href="#第七章-常微分方程" class="headerlink" title="第七章 常微分方程"></a>第七章 常微分方程</h2><p>不同种类的微分方程解法是完全不同的</p><h3 id="一、考试内容概要-6"><a href="#一、考试内容概要-6" class="headerlink" title="一、考试内容概要"></a>一、考试内容概要</h3><h4 id="一-常微分方程的基本概念"><a href="#一-常微分方程的基本概念" class="headerlink" title="(一)常微分方程的基本概念"></a>(一)常微分方程的基本概念</h4><ol><li>微分方程（含有未知函数的导数或微分的方程）</li><li>微分方程的阶（方程中出现的未知函数导数的最高阶数）</li><li>微分方程的解（满足微分方程的函数）</li><li>微分方程的通解（微分方程的解中含有任意常数，且<strong>独立任意常数的个</strong>数与<strong>微分方程的阶数</strong>相同）</li><li>微分方程的特解（微分方程的不含任意常数的解）</li><li>初始条件（确定特解的一组常数）</li><li>积分曲线（方程的一个解的曲线）</li></ol><h4 id="二-一阶微分方程"><a href="#二-一阶微分方程" class="headerlink" title="(二)一阶微分方程"></a>(二)一阶微分方程</h4><p>前3种是重点</p><ol><li><p>可分离变量的方程（$y’=f(x)g(y)$）（$\frac{dy}{dx}=f(x)g(y)$）（求解两端积分）</p></li><li><p>齐次方程（$\frac{dy}{dx}=\varphi(\frac y x)$）$\displaystyle\left(f(ax,ay)=\varphi(\frac{ay}{ax})=a^0\varphi(\frac{y}{x})\right)$</p><p>令$\frac y x=u\Rightarrow y’=\varphi(u)=u+xu’\Rightarrow$可分离变量</p></li><li><p>线性方程（线性针对y，y’，y’’,···）</p><p>形如$y’+P(x)y=Q(x)$的方程称为一阶线性微分方程</p><p>$\displaystyle \frac{dy}{dx}+P(x)y=Q(x)的通解为\\\displaystyle y=\left(\int Q(x)e^{\int p(x)dx}dx+C\right)e^{-\int p(x)dx}$</p></li><li><p>伯努利方程</p><p>$y’+P(x)y=Q(x)y^\alpha(a\neq 1)$</p><p>两边同除$y^\alpha$，令$u=y^{1-\alpha}$，可转化为一阶线性微分方程</p></li><li><p>全微分方程（后面）</p></li></ol><h4 id="三-可降阶的高阶方程"><a href="#三-可降阶的高阶方程" class="headerlink" title="(三)可降阶的高阶方程"></a>(三)可降阶的高阶方程</h4><ol><li><p>$y^{(n)}=f(x)$（直接积分）</p></li><li><p>$f(x,y’,y’’)=0$（缺y）</p><p>令$y’=p,则y’’=\frac{dp}{dx}$，代入得$f(x,p,\frac{dp}{dx})=0$，降为一阶方程</p></li><li><p>$f(y,y’,y’’)=0$（缺x）</p><p>令$y’=p,则y’’=\frac{dp}{dx}=\frac{dp}{dy}\frac{dy}{dx}=\frac{dp}{dy}p$，代入得$f(y,p,\frac{dp}{dy}p)$，降为一阶方程</p></li></ol><center><span style="color:blue;font-size:15px">2021/7/4</span></center><h4 id="四-高阶线性微分方程"><a href="#四-高阶线性微分方程" class="headerlink" title="(四)高阶线性微分方程"></a>(四)高阶线性微分方程</h4><ol><li><p>线性微分方程的解的结构</p><p>齐次方程：$y’’+p(x)y’+q(x)y=0$</p><p>非齐次方程：$y’’+p(x)y’+q(x)y=f(x)$</p><p>齐次通解=两个线性无关的齐次特解的线性组合（<script type="math/tex">y=C_1y_1(x)+C_2y_2(x)</script>）</p><p>非齐通解=齐次通解+一个非齐特解 （<script type="math/tex">y=C_1y_1(x)+C_2y_2(x)+y^*(x)</script>）</p><p>非齐特解-非齐特解=齐次的解；非齐的解对于非齐次项具有叠加性</p></li><li><p>常系数齐次线性微分方程</p><p>常系数齐次线性微分方程：$y’’+py’+qy=0$（二阶）</p><p>特征方程：$r^2+pr+q=0$</p></li></ol><div class="table-container"><table><thead><tr><th></th><th>$p^2-4q$</th><th>二阶常系数线性微分方程的通解</th></tr></thead><tbody><tr><td>不等实根</td><td>$\triangle&gt;0$</td><td>$y=C_1e^{\lambda_1x}+C_2e^{\lambda_2x}$</td></tr><tr><td>相等实根</td><td>$\triangle=0$</td><td>$y=(C_1+xC_2)e^{\lambda_1x}$</td></tr><tr><td>共轭复根</td><td>$\triangle&lt;0$</td><td><script type="math/tex">y=e^{\alpha x}(C_1\cos(\beta x)+C_2\sin(\beta x))\qquad(\lambda_{1,2}=\alpha\pm i\beta)</script></td></tr></tbody></table></div><p>   高阶常系数齐次线性微分方程有几个特征根，就把他们对应的解用加法联系起来</p><ol><li><p>常系数非齐次线性微分方程</p><p> 常系数非齐次线性微分方程：$y’’+py’+qy=f(x)$</p><p>求出一个特解，再加上非齐次方程对应的齐次方程的通解，即可求出通解</p></li></ol><div class="table-container"><table><thead><tr><th>$f(x)=e^{\lambda x}P_m(x)$</th><th>令$y^*=x^kQ_m(x)e^{\lambda x}$</th></tr></thead><tbody><tr><td>$f(x)=e^{\alpha x}[P_l^{(1)}(x)\cos\beta x+P_n^{(2)}(x)\sin\beta x]$</td><td>令$y^*=x^ke^{\alpha x}[R_m^{(1)}(x)\cos\beta x+R_m^{(2)}(x)\sin\beta x]\quad m=\max(l,n)$</td></tr></tbody></table></div><p>   上面λ是非齐次方程对应的齐次方程的特征方程的几重根，k就等于几</p><p>   下面$\alpha+i\beta$是非齐次方程对应的齐次方程的特征方程的几重根，k就等于几</p><ol><li><p>欧拉方程</p><p>欧拉方程：<script type="math/tex">x^ny^{(n)}+a_1x^{n-1}y^{(n-1)}+...+a_{n-1}xy'+a_ny=f(x)</script></p><p>令$x=e^t$，用算符D表示$\frac d{dt}$，则$x^ky^{(k)}=D(D-1)\cdots(D-k+1)y$</p></li></ol><h3 id="二、常考题型与典型例题-7"><a href="#二、常考题型与典型例题-7" class="headerlink" title="二、常考题型与典型例题"></a>二、常考题型与典型例题</h3><h4 id="题型一、微分方程求解"><a href="#题型一、微分方程求解" class="headerlink" title="题型一、微分方程求解"></a>题型一、微分方程求解</h4><h4 id="题型二、综合题"><a href="#题型二、综合题" class="headerlink" title="题型二、综合题"></a>题型二、综合题</h4><h4 id="题型三、应用题"><a href="#题型三、应用题" class="headerlink" title="题型三、应用题"></a>题型三、应用题</h4><center><span style="color:blue;font-size:15px">2021/7/6</span></center><h2 id="第八章-多元函数微分学"><a href="#第八章-多元函数微分学" class="headerlink" title="第八章 多元函数微分学"></a>第八章 多元函数微分学</h2><h3 id="第一节-多元函数的基本概念（重极限、连续、偏导数、全微分）"><a href="#第一节-多元函数的基本概念（重极限、连续、偏导数、全微分）" class="headerlink" title="第一节 多元函数的基本概念（重极限、连续、偏导数、全微分）"></a>第一节 多元函数的基本概念（重极限、连续、偏导数、全微分）</h3><h3 id="一、考试内容纲要"><a href="#一、考试内容纲要" class="headerlink" title="一、考试内容纲要"></a>一、考试内容纲要</h3><h4 id="一-二元函数"><a href="#一-二元函数" class="headerlink" title="(一)二元函数"></a>(一)二元函数</h4><h4 id="二-二元函数的极限"><a href="#二-二元函数的极限" class="headerlink" title="(二)二元函数的极限"></a>(二)二元函数的极限</h4><p>note：以”任意方式”趋近；</p><h4 id="三-多元函数的连续性"><a href="#三-多元函数的连续性" class="headerlink" title="(三)多元函数的连续性"></a>(三)多元函数的连续性</h4><ol><li>连续的概念（函数值等于极限值）</li><li>连续函数的性质</li></ol><h4 id="四-偏导数"><a href="#四-偏导数" class="headerlink" title="(四)偏导数"></a>(四)偏导数</h4><ol><li>偏导数的定义</li><li>偏导数的几何意义</li><li>高阶偏导数（若两个混合偏导数在某点（区域内）连续，则在该点（区域内）两个混合偏导数必相等</li></ol><h4 id="五-全微分"><a href="#五-全微分" class="headerlink" title="(五)全微分"></a>(五)全微分</h4><ol><li><p>可微（$\triangle z=A\triangle x+B\triangle y+o(\rho)\quad(\rho=\sqrt{(\triangle x)^2+(\triangle y)^2})$）</p><p>（定义法判定可微：$\displaystyle \frac{\triangle z-(f_x(x_0,y_0)\triangle x+f_y(x_0,y_0)\triangle y)}{\rho}=0?$）</p></li><li><p>可微$\Rightarrow$偏导数存在；一阶偏导数存在且连续$\Rightarrow$可微；</p></li></ol><h4 id="六-连续、可导、可微的关系"><a href="#六-连续、可导、可微的关系" class="headerlink" title="(六)连续、可导、可微的关系"></a>(六)连续、可导、可微的关系</h4><h3 id="二、常考题型与典型例题-8"><a href="#二、常考题型与典型例题-8" class="headerlink" title="二、常考题型与典型例题"></a>二、常考题型与典型例题</h3><h4 id="讨论连续性、可导性、可微性"><a href="#讨论连续性、可导性、可微性" class="headerlink" title="讨论连续性、可导性、可微性"></a>讨论连续性、可导性、可微性</h4><h3 id="第二节-多元函数微分法"><a href="#第二节-多元函数微分法" class="headerlink" title="第二节 多元函数微分法"></a>第二节 多元函数微分法</h3><h3 id="一、考试内容概要-7"><a href="#一、考试内容概要-7" class="headerlink" title="一、考试内容概要"></a>一、考试内容概要</h3><h4 id="一-复合函数微分法"><a href="#一-复合函数微分法" class="headerlink" title="(一)复合函数微分法"></a>(一)复合函数微分法</h4><p>树形图；全微分形式的不变性</p><h4 id="二-隐函数微分法"><a href="#二-隐函数微分法" class="headerlink" title="(二)隐函数微分法"></a>(二)隐函数微分法</h4><p>$\displaystyle\frac{\partial z}{\partial x}=-\frac{F’_x}{F’_z};\frac{\partial z}{\partial y}=-\frac{F’_y}{F’_z}$</p><h3 id="二、常考题型与典型例题-9"><a href="#二、常考题型与典型例题-9" class="headerlink" title="二、常考题型与典型例题"></a>二、常考题型与典型例题</h3><h4 id="题型一、复合函数的偏导数与全微分"><a href="#题型一、复合函数的偏导数与全微分" class="headerlink" title="题型一、复合函数的偏导数与全微分"></a>题型一、复合函数的偏导数与全微分</h4><h4 id="题型二、隐函数的偏导数与全微分"><a href="#题型二、隐函数的偏导数与全微分" class="headerlink" title="题型二、隐函数的偏导数与全微分"></a>题型二、隐函数的偏导数与全微分</h4><center><span style="color:blue;font-size:15px">2021/7/7</span></center><h3 id="第三节-多元函数的极值与最值"><a href="#第三节-多元函数的极值与最值" class="headerlink" title="第三节 多元函数的极值与最值"></a>第三节 多元函数的极值与最值</h3><h3 id="一、考试内容概要-8"><a href="#一、考试内容概要-8" class="headerlink" title="一、考试内容概要"></a>一、考试内容概要</h3><h4 id="一-无约束极值"><a href="#一-无约束极值" class="headerlink" title="(一)无约束极值"></a>(一)无约束极值</h4><ol><li><p>极值的必要条件：若在某点存在偏导数，且该点为f(x,y)的极值点，则该点偏导为0</p></li><li><p>极值的充分条件：若在某点的领域内有二阶连续偏导数，且该点偏导为零，记对x的二阶导为A，混合偏导数为B，对y的二阶导为C，则有下列结论</p><p>（1）若$AC-B^2&gt;0$，则该点为极值点（A&lt;0极大值；A&gt;0极小值）</p><p>（2）若$AC-B^2&lt;0$，该点不是极值点</p><p>（3）若$AC-B^2=0$，都有可能（此时一般用定义法判定）</p></li></ol><h4 id="二-条件极值与拉格朗日乘数法"><a href="#二-条件极值与拉格朗日乘数法" class="headerlink" title="(二)条件极值与拉格朗日乘数法"></a>(二)条件极值与拉格朗日乘数法</h4><ol><li><p>函数f(x,y)在条件$\varphi(x,y)=0$条件下的极值</p><p>令<script type="math/tex">F(x,y,\lambda)=f(x,y)+\lambda\varphi(x,y)\\\begin{cases}F_x=f_x+\lambda\varphi_x=0\\F_y=f_y+\lambda\varphi_y=0\\F_{\lambda}=\varphi(x,y)=0\end{cases}</script></p><p>即可解出若干组x，y为可能极值点</p></li><li><p>类似，三个自变量，两个约束条件，作辅助函数，使五个偏导等于0，解出x,y,z</p></li></ol><h4 id="三-最大最小值"><a href="#三-最大最小值" class="headerlink" title="(三)最大最小值"></a>(三)最大最小值</h4><ol><li>求连续函数在闭区域上的最大最小值（(1)求内部可能的极值点(2)求边界上的最大最小值(条件最值)(3)比较）</li><li>应用题（建立目标函数，然后按1的三步曲求解）</li></ol><h3 id="二、常考题型方法与技巧"><a href="#二、常考题型方法与技巧" class="headerlink" title="二、常考题型方法与技巧"></a>二、常考题型方法与技巧</h3><h4 id="题型一、求极值-无条件"><a href="#题型一、求极值-无条件" class="headerlink" title="题型一、求极值(无条件)"></a>题型一、求极值(无条件)</h4><h4 id="题型二、求最大最小值"><a href="#题型二、求最大最小值" class="headerlink" title="题型二、求最大最小值"></a>题型二、求最大最小值</h4><h4 id="题型三、最大最小值应用题"><a href="#题型三、最大最小值应用题" class="headerlink" title="题型三、最大最小值应用题"></a>题型三、最大最小值应用题</h4><center><span style="color:blue;font-size:15px">2021/7/8</span></center><h2 id="第九章-二重积分"><a href="#第九章-二重积分" class="headerlink" title="第九章 二重积分"></a>第九章 二重积分</h2><h3 id="一、考试内容概要-9"><a href="#一、考试内容概要-9" class="headerlink" title="一、考试内容概要"></a>一、考试内容概要</h3><h4 id="一-二重积分的概念与性质"><a href="#一-二重积分的概念与性质" class="headerlink" title="(一)二重积分的概念与性质"></a>(一)二重积分的概念与性质</h4><ol><li>二重积分的概念</li><li>二重积分的性质（不等式性质(3)；积分中值定理）</li></ol><h4 id="二-二重积分计算"><a href="#二-二重积分计算" class="headerlink" title="(二)二重积分计算"></a>(二)二重积分计算</h4><ol><li>利用直角坐标计算</li><li>利用极坐标计算</li><li>利用函数的奇偶性计算</li><li>利用变量的轮换对称性计算</li></ol><h3 id="二、常考题型方法与技巧-1"><a href="#二、常考题型方法与技巧-1" class="headerlink" title="二、常考题型方法与技巧"></a>二、常考题型方法与技巧</h3><h4 id="题型一、累次积分交换次序及计算"><a href="#题型一、累次积分交换次序及计算" class="headerlink" title="题型一、累次积分交换次序及计算"></a>题型一、累次积分交换次序及计算</h4><h4 id="题型二、二重积分计算"><a href="#题型二、二重积分计算" class="headerlink" title="题型二、二重积分计算"></a>题型二、二重积分计算</h4><center><span style="color:blue;font-size:15px">2021/7/9</span></center><h2 id="第十章-无穷级数"><a href="#第十章-无穷级数" class="headerlink" title="第十章 无穷级数"></a>第十章 无穷级数</h2><h3 id="第一节-常数项级数"><a href="#第一节-常数项级数" class="headerlink" title="第一节 常数项级数"></a>第一节 常数项级数</h3><h3 id="一、考试内容概要-10"><a href="#一、考试内容概要-10" class="headerlink" title="一、考试内容概要"></a>一、考试内容概要</h3><h4 id="一-级数的概念与性质"><a href="#一-级数的概念与性质" class="headerlink" title="(一)级数的概念与性质"></a>(一)级数的概念与性质</h4><ol><li>级数的概念（数列部分和$S_n$的极限）；等比级数</li><li>级数的性质<ol><li>两收敛级数相加仍收敛；</li><li>收敛级数每项数乘仍收敛；</li><li>在级数中添加，减少，修改有限项，不会改变级数的敛散性； </li><li>在级数中添加括号收敛性不降低（有可能会提高）；</li><li>（级数收敛的<strong>必要</strong>条件）<script type="math/tex">若级数\displaystyle \sum^\infty_{n=1}u_n收敛，则\lim_{n\to\infty}u_n=0</script></li></ol></li></ol><h4 id="二-级数的审敛准则"><a href="#二-级数的审敛准则" class="headerlink" title="(二)级数的审敛准则"></a>(二)级数的审敛准则</h4><ol><li><p>正项级数（<script type="math/tex">\displaystyle \sum^\infty_{n=1}u_n,u_n\geq0</script>）</p><p>基本定理（充要条件）：收敛⇔部分和数列上有界</p><p>两个常用级数（p级数；等比级数）</p><p>（1）比较判别法（大收敛小收敛；小发散大发散）</p><p>（2）比较法的极限形式</p><p>（3）比值法</p><p>（4）根值法</p></li><li><p>交错级数（<script type="math/tex">\displaystyle\sum^\infty_{n=1}(-1)^{n-1}u_n,u_n>0</script>）</p><p>莱布尼兹准则（<strong>充分</strong>条件）（若$u_n$单调减且极限趋于0则收敛）</p></li><li><p>任意项级数（<script type="math/tex">\displaystyle \sum^\infty_{n=1}u_n,u_n</script>为任意实数） </p><p>绝对收敛与条件收敛（加绝对值提高发散性）</p><p>绝对收敛的级数一定收敛；条件收敛的级数的所有正（或负项）构成的级数一定发散；</p></li></ol><h3 id="二、常考题型与典型例题-10"><a href="#二、常考题型与典型例题-10" class="headerlink" title="二、常考题型与典型例题"></a>二、常考题型与典型例题</h3><h4 id="常数项级数敛散性的判定"><a href="#常数项级数敛散性的判定" class="headerlink" title="常数项级数敛散性的判定"></a>常数项级数敛散性的判定</h4><h3 id="第二节-幂级数"><a href="#第二节-幂级数" class="headerlink" title="第二节 幂级数"></a>第二节 幂级数</h3><h3 id="一、考试内容概要-11"><a href="#一、考试内容概要-11" class="headerlink" title="一、考试内容概要"></a>一、考试内容概要</h3><h4 id="一-收敛半径收敛区间收敛域"><a href="#一-收敛半径收敛区间收敛域" class="headerlink" title="(一)收敛半径收敛区间收敛域"></a>(一)收敛半径收敛区间收敛域</h4><ol><li><p>定义：每一项都是x的正整数幂，并且按升幂排列的函数项级数</p></li><li><p>阿贝尔定理（若幂级数在x0收敛，则当|x|&lt;|x0|时，幂级数绝对收敛；若在x0发散，则当则当|x|&gt;|x0|时，幂级数发散）</p><p>根据阿贝尔定理，幂级数的收敛性只有三种可能（全体区间都收敛；仅在0处收敛；|x|<r时绝对收敛，|x|>R时发散）</r时绝对收敛，|x|></p><p>R称为幂级数的<strong>收敛半径</strong>；开区间(-R,R)称为它的<strong>收敛区间</strong>；加上$\pm R$点的收敛性后称为<strong>收敛域</strong></p><p><strong>note：</strong>若幂级数在某点条件收敛，则该点必为一个端点</p></li><li><p>若<script type="math/tex">\displaystyle\lim_{n\to\infty}\left|\frac{a_{n+1}}{a_n}\right|=\rho,则R=\frac{1}{\rho}</script></p><p>若<script type="math/tex">\displaystyle\lim_{n\to\infty}\sqrt[n]{|a_n|}=\rho,则R=\frac{1}{\rho}</script></p></li></ol><h4 id="二-幂级数的性质"><a href="#二-幂级数的性质" class="headerlink" title="(二)幂级数的性质"></a>(二)幂级数的性质</h4><ol><li>有理运算性质 （四则）</li><li>分析性质（和函数在收敛区间上连续；逐项可导性；逐项可积性）</li></ol><h4 id="三-函数的幂级数展开"><a href="#三-函数的幂级数展开" class="headerlink" title="(三)函数的幂级数展开"></a>(三)函数的幂级数展开</h4><ol><li><p>几个常用的展开式</p></li><li><p>函数展开为幂级数的两种方法</p><p>（1）直接展开法（求各阶导数写泰勒级数）（考试应该不会用到）</p><p>（2）间接展开法（基本展开式：四则，逐项求导，逐项求积分，变量代换）（重点）</p></li></ol><h3 id="二、常考题型与典型例题-11"><a href="#二、常考题型与典型例题-11" class="headerlink" title="二、常考题型与典型例题"></a>二、常考题型与典型例题</h3><h4 id="题型一、求收敛半径、收敛区间及收敛域（两公式；端点代）"><a href="#题型一、求收敛半径、收敛区间及收敛域（两公式；端点代）" class="headerlink" title="题型一、求收敛半径、收敛区间及收敛域（两公式；端点代）"></a>题型一、求收敛半径、收敛区间及收敛域（两公式；端点代）</h4><h4 id="题型二、将函数展开为幂级数（把函数写成基本幂级数的形式后展开；逐项可导；逐项可积）"><a href="#题型二、将函数展开为幂级数（把函数写成基本幂级数的形式后展开；逐项可导；逐项可积）" class="headerlink" title="题型二、将函数展开为幂级数（把函数写成基本幂级数的形式后展开；逐项可导；逐项可积）"></a>题型二、将函数展开为幂级数（把函数写成基本幂级数的形式后展开；逐项可导；逐项可积）</h4><h4 id="题型三、求幂级数的和函数-重点难点"><a href="#题型三、求幂级数的和函数-重点难点" class="headerlink" title="题型三、求幂级数的和函数(重点难点)"></a>题型三、求幂级数的和函数(重点难点)</h4><center><span style="color:blue;font-size:15px">2021/7/10</span></center><h3 id="第三节-傅里叶级数"><a href="#第三节-傅里叶级数" class="headerlink" title="第三节 傅里叶级数"></a>第三节 傅里叶级数</h3><h3 id="一、考试内容概要-12"><a href="#一、考试内容概要-12" class="headerlink" title="一、考试内容概要"></a>一、考试内容概要</h3><h4 id="一-傅里叶系数与傅里叶级数"><a href="#一-傅里叶系数与傅里叶级数" class="headerlink" title="(一)傅里叶系数与傅里叶级数"></a>(一)傅里叶系数与傅里叶级数</h4><p>傅里叶系数：<script type="math/tex">\displaystyle a_n=\frac1\pi\int^\pi_{-\pi}f(x)\cos nxdx\qquad(n=0,1,2,3,···)\\\displaystyle b_n=\frac1\pi\int^\pi_{-\pi}f(x)\sin nxdx\qquad(n=1,2,3,···)\\</script></p><p>傅里叶级数：<script type="math/tex">f(x)\sim\displaystyle \frac{a_{0}}{2}+\sum_{n=1}^{\infty}\left(a_{n} \cos n x+b_{n} \sin n x\right)</script></p><h4 id="二-收敛定理-狄利克雷"><a href="#二-收敛定理-狄利克雷" class="headerlink" title="(二)收敛定理(狄利克雷)"></a>(二)收敛定理(狄利克雷)</h4><script type="math/tex; mode=display">设f(x) 是周期为2π的周期函数,如果它满足:\\(1)在一个周期([-π,π])内连续或只有有限个第一类间断点，\\(2)在一个周期([-π,π])内至多只有有限个极值点，\\那么f(x)的傅里叶级数在[-π,π]上处处收敛\\\displaystyle a_0=\frac1\pi\int^\pi_{-\pi}f(x)dx\\\displaystyle a_n=\frac1\pi\int^\pi_{-\pi}f(x)\cos nxdx\qquad(n=1,2,3,···)\\\displaystyle b_n=\frac1\pi\int^\pi_{-\pi}f(x)\sin nxdx\qquad(n=1,2,3,···)\\当x是f(x)的连续点时，级数S(x)收敛于f(x)；\\\displaystyle当x是f(x)的间断点时，级数S(x)收敛于\frac1 2[f(x^-)+f(x^+)]\\</script><center><span style="color:blue;font-size:15px">2021/7/11</span></center><h4 id="三-函数展开为傅里叶级数"><a href="#三-函数展开为傅里叶级数" class="headerlink" title="(三)函数展开为傅里叶级数"></a>(三)函数展开为傅里叶级数</h4><ol><li>[-π,π]上展开</li><li>[-π,π]上奇偶函数的展开</li><li>在[0,π]上展开为正弦或展开成余弦（周期延拓）</li></ol><h4 id="四-周期为2l的函数的展开"><a href="#四-周期为2l的函数的展开" class="headerlink" title="(四)周期为2l的函数的展开"></a>(四)周期为2l的函数的展开</h4><ol><li>[-l,l]上展开</li><li>[-l,l]上奇偶函数的展开</li><li>在[0,l]上展开为正弦或展开成余弦</li></ol><h3 id="二、常考题型方法与技巧-2"><a href="#二、常考题型方法与技巧-2" class="headerlink" title="二、常考题型方法与技巧"></a>二、常考题型方法与技巧</h3><h4 id="题型一、狄利克雷收敛定理"><a href="#题型一、狄利克雷收敛定理" class="headerlink" title="题型一、狄利克雷收敛定理"></a>题型一、狄利克雷收敛定理</h4><h4 id="题型二、将函数展开为傅里叶级数"><a href="#题型二、将函数展开为傅里叶级数" class="headerlink" title="题型二、将函数展开为傅里叶级数"></a>题型二、将函数展开为傅里叶级数</h4><center><span style="color:blue;font-size:15px">2021/7/12</span></center><h2 id="第十一章-向量代数与空间解析几何及多元微分学在几何上的应用"><a href="#第十一章-向量代数与空间解析几何及多元微分学在几何上的应用" class="headerlink" title="第十一章 向量代数与空间解析几何及多元微分学在几何上的应用"></a>第十一章 向量代数与空间解析几何及多元微分学在几何上的应用</h2><h3 id="第一节-向量代数"><a href="#第一节-向量代数" class="headerlink" title="第一节 向量代数"></a>第一节 向量代数</h3><h4 id="一、数量积（数）"><a href="#一、数量积（数）" class="headerlink" title="一、数量积（数）"></a>一、数量积（数）</h4><ol><li>几何表示（$\vec a·\vec b=|\vec a||\vec b|\cos\theta$）</li><li>代数表示（$\vec a·\vec b=a_xb_x+a_yb_y+a_zb_z$）</li><li>运算规律（交换律、分配率）</li><li>几何应用（求模、求夹角、判断两向量垂直）</li></ol><h4 id="二、向量积（向量）"><a href="#二、向量积（向量）" class="headerlink" title="二、向量积（向量）"></a>二、向量积（向量）</h4><ol><li>几何表示（模：$|\vec a\times\vec b|=|\vec a||\vec b|\sin\theta$；方向：右手法则）</li><li>代数表示（<script type="math/tex">\vec a\times\vec b=\begin{vmatrix}\vec i&\vec j&\vec k\\a_x&a_y&a_z\\b_x&b_y&b_z\end{vmatrix}</script>）</li><li>运算规律（反交换律、分配率）</li><li>几何应用（求同时垂直于a,b的向量、求以a,b为邻边的平行四边形的面积、判定两向量平行）</li></ol><h4 id="三、混合积（数）"><a href="#三、混合积（数）" class="headerlink" title="三、混合积（数）"></a>三、混合积（数）</h4><ol><li>几何表示（$(\vec a\vec b\vec c)=(\vec a\times\vec b)·\vec c$）</li><li>代数表示（<script type="math/tex">(\vec a\vec b\vec c)=(\vec a\times\vec b)·\vec c=\begin{vmatrix}a_x&a_y&a_z\\b_x&b_y&b_z\\c_x&c_y&c_z\end{vmatrix}</script>）</li><li>运算规律（轮换对称性、交换变号）</li><li>几何应用（平行六面体体积、判断三向量共面）</li></ol><h3 id="第二节-空间平面与直线"><a href="#第二节-空间平面与直线" class="headerlink" title="第二节 空间平面与直线"></a>第二节 空间平面与直线</h3><h4 id="一、平面方程"><a href="#一、平面方程" class="headerlink" title="一、平面方程"></a>一、平面方程</h4><p>一般式、点法式、截距式</p><h4 id="二、直线方程"><a href="#二、直线方程" class="headerlink" title="二、直线方程"></a>二、直线方程</h4><p>一般式、对称式（点向式）、参数式</p><h4 id="三、平面与直线的位置关系"><a href="#三、平面与直线的位置关系" class="headerlink" title="三、平面与直线的位置关系"></a>三、平面与直线的位置关系</h4><h4 id="四、点到面的距离"><a href="#四、点到面的距离" class="headerlink" title="四、点到面的距离"></a>四、点到面的距离</h4><h4 id="五、点到直线的距离"><a href="#五、点到直线的距离" class="headerlink" title="五、点到直线的距离"></a>五、点到直线的距离</h4><h3 id="第三节-曲面与空间曲线"><a href="#第三节-曲面与空间曲线" class="headerlink" title="第三节 曲面与空间曲线"></a>第三节 曲面与空间曲线</h3><h4 id="一、曲面方程"><a href="#一、曲面方程" class="headerlink" title="一、曲面方程"></a>一、曲面方程</h4><p>一般式（F(x,y,z)=0或z=f(x,y)）</p><h4 id="二、空间曲线"><a href="#二、空间曲线" class="headerlink" title="二、空间曲线"></a>二、空间曲线</h4><p>参数式（螺线）、一般式</p><h4 id="三、常见曲面"><a href="#三、常见曲面" class="headerlink" title="三、常见曲面"></a>三、常见曲面</h4><p>旋转面、柱面、二次曲面、空间曲线投影</p><h3 id="第四节-多元微分学在几何上的应用"><a href="#第四节-多元微分学在几何上的应用" class="headerlink" title="第四节 多元微分学在几何上的应用"></a>第四节 多元微分学在几何上的应用</h3><h4 id="一、曲面的切平面和法线"><a href="#一、曲面的切平面和法线" class="headerlink" title="一、曲面的切平面和法线"></a>一、曲面的切平面和法线</h4><p>F(x,y,z)=0；z=f(x,y)</p><h4 id="二、曲线的切线与法平面"><a href="#二、曲线的切线与法平面" class="headerlink" title="二、曲线的切线与法平面"></a>二、曲线的切线与法平面</h4><p>参数式；一般式</p><h2 id="第十二章-多元积分学及其应用"><a href="#第十二章-多元积分学及其应用" class="headerlink" title="第十二章 多元积分学及其应用"></a>第十二章 多元积分学及其应用</h2><h3 id="第一节-三重积分"><a href="#第一节-三重积分" class="headerlink" title="第一节 三重积分"></a>第一节 三重积分</h3><ol><li><p>定义（和二重类似）</p></li><li><p>性质（和二重类似）</p></li><li><p>计算</p><p>直角坐标：</p><p>（1）先一后二（先单后重）（铅直投影法）（有上下曲面方程时）</p><p>（2）先二后一（先重后单）（切片法）（截面积好算时）</p><p>柱坐标、球坐标、利用奇偶性、利用变量的轮换对称性</p></li></ol><h3 id="第二节-曲线积分"><a href="#第二节-曲线积分" class="headerlink" title="第二节 曲线积分"></a>第二节 曲线积分</h3><h4 id="一、对弧长的线积分（第一类线积分）"><a href="#一、对弧长的线积分（第一类线积分）" class="headerlink" title="一、对弧长的线积分（第一类线积分）"></a>一、对弧长的线积分（第一类线积分）</h4><ol><li><p>定义：<script type="math/tex">\displaystyle\int_Lf(x,y)ds=\lim_{\lambda\to 0}\sum^n_{i=1}f(\xi_i,\eta_i)\triangle s_i</script></p></li><li><p>性质：第一类线积分与积分路径方向无关</p></li><li><p>计算方法（平面）</p><p>直接法：（参数方程， 直角坐标，弧坐标）</p><p>利用奇偶性、利用对称性</p></li></ol><h4 id="二、对坐标的线积分（第二类线积分）"><a href="#二、对坐标的线积分（第二类线积分）" class="headerlink" title="二、对坐标的线积分（第二类线积分）"></a>二、对坐标的线积分（第二类线积分）</h4><ol><li><p>定义：<script type="math/tex">\displaystyle\int_LP(x,y)dx+Q(x,y)dy=\lim_{\lambda\to 0}\sum^n_{i=1}[P(\xi_i,\eta_i)\triangle x_i+Q(\xi_i.\eta_i)\triangle y_i]</script></p></li><li><p>性质：第一类线积分与积分路径方向有关</p></li><li><p>计算方法（平面）</p><p>直接法、格林公式（$\displaystyle\iint\limits_D\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right)dxdy=\oint_LPdx+Qdy$）、补线用格林公式、</p><p>利用线积分与路径无关：</p><p>（1）判定：$\displaystyle \frac{\partial Q}{\partial x}=\frac{\partial P}{\partial y}$（区域D单连通）</p><p>（2）计算（1）改换路径计算（2）利用原函数计算</p></li><li><p>两类线积分的联系</p><p>$\displaystyle\int_LPdx+Qdy=\int_L(P\cos\alpha+Q\cos\beta)ds$</p></li><li><p>计算方法（空间）</p><p>（1）直接法（参数方程）</p><p>（2）斯托克斯公式（曲面方向右手法则）</p><p><script type="math/tex">\displaystyle\oint_\Gamma Pdx+Qdy+Rdz==\iint\limits_\Sigma\begin{vmatrix}\cos\alpha&\cos\beta&\cos\gamma\\\frac{\partial }{\partial x}&\frac{\partial }{\partial y}&\frac{\partial }{\partial z}\\P&Q&R \end{vmatrix}dS</script>，($\Sigma$是<strong>外侧</strong>曲面)</p></li></ol><center><span style="color:blue;font-size:15px">2021/7/21</span></center><h3 id="第三节-曲面积分"><a href="#第三节-曲面积分" class="headerlink" title="第三节 曲面积分"></a>第三节 曲面积分</h3><h3 id="第四节-多元积分应用"><a href="#第四节-多元积分应用" class="headerlink" title="第四节 多元积分应用"></a>第四节 多元积分应用</h3><h3 id="第五节-场论初步"><a href="#第五节-场论初步" class="headerlink" title="第五节 场论初步"></a>第五节 场论初步</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="2021/04/11/data-structure/"/>
      <url>2021/04/11/data-structure/</url>
      
        <content type="html"><![CDATA[<p>使用的教材：</p><p>数据结构（C语言版） 严蔚敏</p><p>王道数据结构考研复习指导（2022）</p><center><span style="color:blue;font-size:15px">2021/4/11</span></center><h2 id="考研大纲（408）"><a href="#考研大纲（408）" class="headerlink" title="考研大纲（408）"></a>考研大纲（408）</h2><p>【408考查目标】</p><ol><li>掌握数据结构的基本概念、基本原理和基本方法。</li><li>掌握数据的逻辑结构、存储结构及基本操作的实现，能够对算法进行基本的时间复杂度与空间复杂度的分析。</li><li>能够运用数据结构基本原理和方法进行问题的分析与求解，具备采用 C 或 C++语言设计与实现算法的能力。</li></ol><h3 id="一、线性表"><a href="#一、线性表" class="headerlink" title="一、线性表"></a>一、线性表</h3><p> (一)线性表的基本概念<br> (二)线性表的实现（顺序存储、链式存储）<br> (三).线性表的应用</p><h3 id="二、栈、队列和数组"><a href="#二、栈、队列和数组" class="headerlink" title="二、栈、队列和数组"></a>二、栈、队列和数组</h3><p> (一)栈和队列的基本概念<br> (二)栈和队列的顺序存储结构<br> (三)栈和队列的链式存储结构<br> (四)多维数组的存储<br> (五)特殊矩阵的压缩存储<br> (六)栈、队列和数组的应用</p><h3 id="三、树与二叉树"><a href="#三、树与二叉树" class="headerlink" title="三、树与二叉树"></a>三、树与二叉树</h3><p>(一)树的基本概念</p><p>(二)二叉树<br> 1.二叉树的定义及其主要特征<br> 2.二叉树的顺序存储结构和链式存储结构<br> 3.二叉树的遍历<br> 4.线索二叉树的基本概念和构造</p><p>(三)树、森林<br> 1.树的存储结构<br> 2.森林与二叉树的转换<br> 3.树和森林的遍历</p><p>(四)树与二叉树的应用<br> 1.二叉搜索树<br> 2.平衡二叉树<br> 3.哈夫曼(Huffman)树和哈夫曼编码</p><h3 id="四、图"><a href="#四、图" class="headerlink" title="四、图"></a>四、图</h3><p> (一)图的基本概念<br> (二)图的存储及基本操作<br> 1.邻接矩阵法<br> 2.邻接表法<br> 3.邻接多重表、十字链表<br> (三)图的遍历<br> 1.深度优先搜索<br> 2.广度优先搜索<br> (四)图的基本应用<br> 1.最小(代价)生成树<br> 2.最短路径<br> 3.拓扑排序<br> 4.关键路径</p><h3 id="五、查找"><a href="#五、查找" class="headerlink" title="五、查找"></a>五、查找</h3><p> (一)查找的基本概念<br> (二)顺序查找法<br> (三)分块查找法<br> (四)折半查找法<br> (五)B 树及其基本操作、B+树的基本概念<br> (六)散列(Hash)表<br> (七)字符串模式匹配<br> (八)查找算法的分析及应用</p><h3 id="六、排序"><a href="#六、排序" class="headerlink" title="六、排序"></a>六、排序</h3><p> (一)排序的基本概念<br> (二)插入排序<br> 1.直接插入排序<br> 2.折半插入排序<br> (三)起泡排序(bubble sort)<br> (四)简单选择排序<br> (五)希尔排序(shell sort)<br> (六)快速排序<br> (七)堆排序<br> (八)二路归并排序(merge sort)<br> (九)基数排序<br> (十)外部排序<br> (十一)各种内部排序算法的比较<br> (十二)排序算法的应用</p><h2 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h2><p>本章的内容是数据结构概述，不在考研大纲中，但是分析算法的时间复杂度和空间复杂度是本章的重点，属于必考内容，一定要熟练掌握。</p><h3 id="1-1-数据结构的基本概念"><a href="#1-1-数据结构的基本概念" class="headerlink" title="1.1 数据结构的基本概念"></a>1.1 数据结构的基本概念</h3><h4 id="1-1-1-基本概念和术语"><a href="#1-1-1-基本概念和术语" class="headerlink" title="1.1.1 基本概念和术语"></a>1.1.1 基本概念和术语</h4><ul><li>数据：信息的载体，是对客观事物的符号表示</li><li>数据元素：数据的<strong>基本单位</strong>，一个数据元素可由若干个数据项组成。如：一个学生记录（学号、姓名、…）数据项是构成数据元素的不可分割的<strong>最小单位</strong></li><li>数据对象：具有相同性质的数据元素的集合，是数据的一个子集。</li><li>数据结构：是相互存在一种或多种特定<strong>关系</strong>的数据元素的集合；数据结构包括三方面的内容：<strong>逻辑结构</strong>，<strong>存储结构</strong>和<strong>数据的运算</strong></li><li>数据类型：原子类型、结构类型、抽象数据类型</li><li>抽象数据类型：指一个数学模型以及定义在该模型上的一组操作<ul><li>通常用（数据对象，数据关系，基本操作集）这样的三元组来表示抽象数据类型。</li><li>ADT 抽象数据类型名{<br>数据对象:&lt;数据对象的定义&gt;<br>数据关系:&lt;数据关系的定义&gt;<br>基本操作:&lt;基本操作的定义&gt;<br>}ADT 抽象数据类型名</li></ul></li></ul><h4 id="1-1-2-数据结构三要素"><a href="#1-1-2-数据结构三要素" class="headerlink" title="1.1.2 数据结构三要素"></a>1.1.2 数据结构三要素</h4><h5 id="1-数据的逻辑结构"><a href="#1-数据的逻辑结构" class="headerlink" title="1.数据的逻辑结构"></a>1.数据的逻辑结构</h5><p>线性结构：一对一<br>树形结构：一对多<br>图结构：多对多<br>集合</p><h5 id="2-数据的存储结构"><a href="#2-数据的存储结构" class="headerlink" title="2.数据的存储结构"></a>2.数据的存储结构</h5><p>顺序存储<br>链式存储<br>索引存储<br>散列存储</p><p>绪论部分只需要理解三点:<br>1.若采用<strong>顺序存储</strong>，则各个数据元素在<strong>物理上必须是连续的</strong>；若采用<strong>非顺序存储</strong>，则各个数据元素在物理上可以是<strong>离散的</strong>。<br>2.数据的<strong>存储结构</strong>会影响<strong>存储空间分配的方便程度</strong>。<br>3.数据的<strong>存储结构</strong>会影响对<strong>数据运算的速度</strong>。</p><h5 id="3-数据的运算"><a href="#3-数据的运算" class="headerlink" title="3.数据的运算"></a>3.数据的运算</h5><p>施加在数据上的运算包括运算的定义和实现。<strong>运算的定义</strong>是<strong>针对逻辑结构</strong>的，指出运算的功能；<strong>运算的实现</strong>是<strong>针对存储结构</strong>的，指出运算的具体操作步骤。</p><h3 id="1-2-算法和算法分析"><a href="#1-2-算法和算法分析" class="headerlink" title="1.2 算法和算法分析"></a>1.2 算法和算法分析</h3><h4 id="1-2-2-算法效率的度量"><a href="#1-2-2-算法效率的度量" class="headerlink" title="1.2.2 算法效率的度量"></a>1.2.2 算法效率的度量</h4><p><strong>1.时间复杂度</strong></p><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的<strong>某个函数</strong>f(n)，算法的时间量度记作</p><script type="math/tex; mode=display">T(n)=O(f(n))</script><p>它表示随问题规模n的增大，算法执行时间的<strong>增长率</strong>和f(n)的增长率相同，称作算法的<strong>渐进时间复杂度</strong>，简称时<strong>间复杂度</strong>。</p><p>常见的渐进时间复杂度为</p><p>$O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$</p><p><strong>2.空间复杂度</strong></p><p>算法的空间复杂度作为算法所需存储空间的量度，记作</p><script type="math/tex; mode=display">S(n)=O(f(n))</script><center><span style="color:blue;font-size:15px">2021/4/12</span></center><h2 id="第2章-线性表"><a href="#第2章-线性表" class="headerlink" title="第2章 线性表"></a>第2章 线性表</h2><p>线性表是考研的重点，实现起来比较容易而且代码量较少，但却要求具有最优的性能才能获得满分。</p><h3 id="408大纲"><a href="#408大纲" class="headerlink" title="408大纲"></a>408大纲</h3><p> (一)线性表的基本概念<br> (二)线性表的实现（顺序存储、链式存储）<br> (三).线性表的应用</p><h3 id="2-1-线性表的定义和基本操作"><a href="#2-1-线性表的定义和基本操作" class="headerlink" title="2.1 线性表的定义和基本操作"></a>2.1 线性表的定义和基本操作</h3><h4 id="2-1-1-线性表的定义"><a href="#2-1-1-线性表的定义" class="headerlink" title="2.1.1 线性表的定义"></a>2.1.1 线性表的定义</h4><p>线性表是具有<strong>相同数据类型</strong>的n个数据元素的<strong>有限序列</strong>，其中n为表长，当n=0时，是一个空表。<br>若将线性表记为</p><script type="math/tex; mode=display">L=(a_1,a_2,...,a_n)</script><p>除第一个元素外，每一个元素有且仅有一个直接前驱，每个元素有且仅有一个直接后继。</p><p><strong>注意：</strong>线性表是一种逻辑结构，顺序表和链表是指存储结构。</p><h4 id="2-1-2-线性表的基本操作"><a href="#2-1-2-线性表的基本操作" class="headerlink" title="2.1.2 线性表的基本操作"></a>2.1.2 线性表的基本操作</h4><p>InitList(&amp;L)：初始化表。构造一个空的线性表。<br>Length(L)：求表长。返回线性表I的长度，即L中数据元素的个数。<br>LocateElem(L,e)：按值查找操作。在表L中查找具有给定 关键字值的元素。<br>GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。<br>ListInsert(&amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e.<br>ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值<br>PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。<br>Empty(L)：判空操作。若L为空表，则返回true,否则返回false.<br>DestroyList(&amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</p><h3 id="2-2-线性表的顺序表示"><a href="#2-2-线性表的顺序表示" class="headerlink" title="2.2 线性表的顺序表示"></a>2.2 线性表的顺序表示</h3><h4 id="2-2-1-顺序表的定义"><a href="#2-2-1-顺序表的定义" class="headerlink" title="2.2.1 顺序表的定义"></a>2.2.1 顺序表的定义</h4><p>顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。因此，<strong>顺序表的特点是表中元素的逻辑地址与其物理顺序相同。</strong></p><p><img src="/images/Data-Structure/image-20210412091209532.png" alt=""></p><p><strong>注意：</strong>线性表中元素的位序是从1开始的，而数组中元素的下标是从0开始的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">InitSize <span class="token number">100</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    Elemtype <span class="token operator">*</span>data<span class="token punctuation">;</span>    <span class="token keyword">int</span> maxSize<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span> <span class="token comment">//在进行增删操作后记得更改length</span><span class="token punctuation">}</span>Sqlist<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//动态增加动态数组的长度</span><span class="token keyword">void</span> <span class="token function">IncreaseSize</span><span class="token punctuation">(</span>SeqList <span class="token operator">&amp;</span>L，<span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>data<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>MaxSize<span class="token operator">+</span>len<span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    L<span class="token punctuation">.</span>MaxSize<span class="token operator">=</span>L<span class="token punctuation">.</span>MaxSize<span class="token operator">+</span>len<span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顺序表最主要的特点是<strong>随机访问</strong>，即通过首地址和元素序号可在时间O(1)内找到指定的元素。<br>顺序表的存储密度高，每个结点只存储数据元素。<br>顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。</p><h4 id="2-2-2-顺序表上基本操作的实现"><a href="#2-2-2-顺序表上基本操作的实现" class="headerlink" title="2.2.2 顺序表上基本操作的实现"></a>2.2.2 顺序表上基本操作的实现</h4><p>略</p><center><span style="color:blue;font-size:15px">2021/4/13</span></center><h3 id="2-3-线性表的链式表示"><a href="#2-3-线性表的链式表示" class="headerlink" title="2.3 线性表的链式表示"></a>2.3 线性表的链式表示</h3><p>链式存储线性表时，不要求逻辑上相邻的两个元素在物理位置上也相邻，因此对线性表的插入、删除不需要移动元素，只需要修改指针。</p><h4 id="2-3-1-单链表的定义"><a href="#2-3-1-单链表的定义" class="headerlink" title="2.3.1 单链表的定义"></a>2.3.1 单链表的定义</h4><p>线性表的链式存储又称单链表，它是指通过一组任意的存储单 元来存储线性表中的数据元素。对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。</p><p>单链表中结点类型的描述如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">{</span>ElemType data<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>LNode<span class="token punctuation">,</span><span class="token operator">*</span>LinkList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>利用单链表可以解决顺序表需要大量连续存储空间的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。单链表是<strong>非随机存取</strong>的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要<strong>从表头开始遍历，依次查找</strong>。通常用<strong>头指针</strong>来标识一个单链表，如单链表L，头指针为NULL时表示一个空表。 此外，为了操作上的方便，在单链表第一个结点之前附加一个结点，称为<strong>头结点</strong>。头结点的数据域可以不设任何信息，也可以记录表长等相关信息。头结点的指针域指向线性表的第一个元素结点。</p><p><img src="/images/Data-Structure/image-20210413111617026.png" alt=""></p><p>可入头结点后，可以带来两个优点:<br>①在链表的第一个位置上的操作和在表的其他位置上的操作一致， 无须进行特殊处理。<br>②无论链表是否为空，其头指针都指向头结点的非空指针(空表中头结点的指针域为空，因此空表和非空表的处理也就得到了统一。</p><h4 id="2-3-2-单链表上基本操作的实现"><a href="#2-3-2-单链表上基本操作的实现" class="headerlink" title="2.3.2 单链表上基本操作的实现"></a>2.3.2 单链表上基本操作的实现</h4><p>只写全一个例子</p><p><strong>1.采用头插法建立单链表</strong></p><p><img src="/images/Data-Structure/image-20210413113850093.png" alt=""></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LinkList <span class="token function">List_HeadInsert</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>LNode <span class="token operator">*</span>s<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">;</span>L<span class="token operator">=</span><span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建头结点</span>L<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token number">9999</span><span class="token punctuation">)</span><span class="token punctuation">{</span>s<span class="token operator">=</span><span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token operator">-&gt;</span>data<span class="token operator">=</span>x<span class="token punctuation">;</span>s<span class="token operator">-&gt;</span>next<span class="token operator">=</span>L<span class="token operator">-&gt;</span>nextL<span class="token operator">-&gt;</span>next<span class="token operator">=</span>s<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单链表在插入元素时，在给定的结点后插入，时间复杂度仅为O(1)，但在前面插入时，如果从头开始寻找第前置元素，时间复杂度为O(n)，我们可以通过另一种方法转化为后插操作（后插+换数据）使得时间复杂度为O(1)。</p><p>删除元素同理。</p><h4 id="2-3-3-双链表"><a href="#2-3-3-双链表" class="headerlink" title="2.3.3 双链表"></a>2.3.3 双链表</h4><p>双链表结点中有两个指针prior和next，分别指向其前驱结点和后驱结点。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">DNode</span><span class="token punctuation">{</span>ElemType data<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">DNode</span> <span class="token operator">*</span>prior<span class="token punctuation">,</span><span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>DNode<span class="token punctuation">,</span><span class="token operator">*</span>DLinkList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/Data-Structure/image-20210413220828493.png" alt=""></p><p>双链表可以很方便地找到其前驱结点，因此，插入，删除操作的时间复杂度仅为O(1)。</p><h4 id="2-3-4-循环链表"><a href="#2-3-4-循环链表" class="headerlink" title="2.3.4 循环链表"></a>2.3.4 循环链表</h4><p>1.循环单链表</p><p>在循环单链表中，表尾结点*r的next域指向L，故表中没有指针域为NULL的结点，因此，循环单链表的判空条件是头结点的指针是否等于头指针。</p><p>2.循环双链表</p><h4 id="2-3-5-静态链表"><a href="#2-3-5-静态链表" class="headerlink" title="2.3.5 静态链表"></a>2.3.5 静态链表</h4><p><img src="/images/Data-Structure/image-20210413223005264.png" alt=""></p><center><span style="color:blue;font-size:15px">2021/4/14</span></center><h4 id="2-3-6-顺序表和链表的比较"><a href="#2-3-6-顺序表和链表的比较" class="headerlink" title="2.3.6 顺序表和链表的比较"></a>2.3.6 顺序表和链表的比较</h4><p><strong>1.存取(读写)方式</strong><br>顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序依次存取元素。</p><p><strong>2.逻辑结构与物理结构</strong><br>采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。</p><p><strong>3.查找、插入和删除操作</strong><br>对于按值查找，顺序表无序时，两者的时间复杂度均为O(n)；顺序表有序时，可采用折半查找，此时的时间复杂度为O($\log_2n$)。<br>对于按序号查找，顺序表支持随机访问，时间复杂度仅为0(1)；而链表的平均时间复杂度为O(n)。<br>顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。由于链表的每个结点都带有指针域，故而存储密度不够大。</p><p><strong>4.空间分配</strong><br>顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。<br>链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。</p><p><strong>在实际中存储结构的选择</strong></p><p><strong>1.基于存储的考虑</strong><br>难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低。</p><p><strong>2.基于运算的考虑</strong><br>若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。<br>进行插入、删除操作时，显然后者优于前者。</p><p>总之，两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。通常较稳定的线性表选择顺序存储，而频繁进行插入，删除操作的线性表（动态性较强）宜选择链式存储。</p><center><span style="color:blue;font-size:15px">2021/4/16</span></center><h2 id="第3章-栈和队列"><a href="#第3章-栈和队列" class="headerlink" title="第3章 栈和队列"></a>第3章 栈和队列</h2><p>本章通常以选择题的形式考查，题目不算难，但命题的形式比较灵活，其中栈(出入栈的过程、出栈序列的合法性)和队列的操作及其特征是重点。由于它们均是线性表的应用和推广，因此也容易出现在算法设计题中。此外，栈和队列的顺序存储、链式存储及其特点、双端队列的特点、栈和队列的常见应用，以及数组和特殊矩阵的压缩存储都是必须掌握的内容。</p><h3 id="408大纲-1"><a href="#408大纲-1" class="headerlink" title="408大纲"></a>408大纲</h3><p> (一)栈和队列的基本概念<br> (二)栈和队列的顺序存储结构<br> (三)栈和队列的链式存储结构<br> (四)多维数组的存储<br> (五)特殊矩阵的压缩存储<br> (六)栈、队列和数组的应用</p><h3 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h3><h4 id="3-1-1-栈的基本概念"><a href="#3-1-1-栈的基本概念" class="headerlink" title="3.1.1 栈的基本概念"></a>3.1.1 栈的基本概念</h4><h5 id="1-栈的定义"><a href="#1-栈的定义" class="headerlink" title="1.栈的定义"></a>1.栈的定义</h5><p><img src="/images/Data-Structure/image-20210416211011395.png" alt=""></p><p><strong>栈</strong>是只允许在一端进行插入或删除操作的<strong>线性表</strong>。<br><strong>栈顶</strong>：线性表允许进行插入删除的那一端。<br><strong>栈底</strong>：固定的，不允许进行插入和删除的另一端。</p><p>栈的操作特性可以明显地概括为后进先出（LIFO）</p><h5 id="2-栈的基本操作"><a href="#2-栈的基本操作" class="headerlink" title="2.栈的基本操作"></a>2.栈的基本操作</h5><p>InitStack(&amp;S)：初始化一个空栈S。<br>StackEmpty(S)：判断一个栈是否为空，若栈s为空则返回true，否则返回false。<br>Push(&amp;S,x)：进栈，若栈s未满，则将x加入使之成为新栈顶。<br>Pop(&amp;S,&amp;x)：出栈，若栈s非空，则弹出栈项元素，并用x返回。<br>GetTop(S,&amp;x)：读栈顶元素，若栈s非空，则用x返回栈项元素。<br>DestroyStack(&amp;S)：销毁栈，并释放栈S占用的存储空间</p><p><strong>在解答算法题时，若题干未做出限制，则可直接使用这些基本的操作函数。</strong></p><h4 id="3-1-2-栈的顺序存储结构"><a href="#3-1-2-栈的顺序存储结构" class="headerlink" title="3.1.2 栈的顺序存储结构"></a>3.1.2 栈的顺序存储结构</h4><p>栈是一种操作受限的线性表，类似于线性表，它也有对应的两种存储方式。</p><h5 id="1-顺序栈的实现"><a href="#1-顺序栈的实现" class="headerlink" title="1.顺序栈的实现"></a>1.顺序栈的实现</h5><p>栈的顺序存储类型可描述为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MaxSize <span class="token number">50</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span><span class="token punctuation">}</span>sqstack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>栈项指针</strong>：S.top，初始时设置S.top=-1；栈项元素：S.data[S.top]。<br><strong>进栈操作</strong>：栈不满时，栈顶指针先加1，再送值到栈顶元素。<br><strong>出栈操作</strong>：栈非空时，先取栈顶元素值，再将栈顶指针减1。<br><strong>栈空条件</strong>：s. top=\=-1；<strong>栈满条件</strong>: S.top==MaxSize-1; <strong>栈长</strong>: s. top+1。</p><p><strong>注意</strong>:栈和队列的判空、判满条件，会因实际给的条件不同而变化，需具体问题具体分析。</p><h5 id="2-顺序栈的基本运算"><a href="#2-顺序栈的基本运算" class="headerlink" title="2.顺序栈的基本运算"></a>2.顺序栈的基本运算</h5><p>同上。</p><h5 id="3-共享栈"><a href="#3-共享栈" class="headerlink" title="3.共享栈"></a>3.共享栈</h5><p>利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。<br>共享栈是为了更有效地利用存储空间，两个栈的空间相互调节。</p><h4 id="3-1-3-栈的链式存储结构"><a href="#3-1-3-栈的链式存储结构" class="headerlink" title="3.1.3 栈的链式存储结构"></a>3.1.3 栈的链式存储结构</h4><p>采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且<strong>不存在栈满上溢的情况</strong>。通常采用单链表实现，并规定<strong>所有操作都是在单链表的表头进行的</strong>。这里规定链栈没有头结点，Lhead 指向栈顶元素。</p><p><img src="/images/Data-Structure/image-20210422154019487.png" alt=""></p><p>栈的顺序存储类型可描述为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Linknode</span><span class="token punctuation">{</span>    ELemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Linknode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token operator">*</span>Listack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>采用链式存储，便于结点的插入与删除。链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行。</p><h3 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h3><h4 id="3-2-1-队列的基本概念"><a href="#3-2-1-队列的基本概念" class="headerlink" title="3.2.1 队列的基本概念"></a>3.2.1 队列的基本概念</h4><h5 id="1-队列的定义"><a href="#1-队列的定义" class="headerlink" title="1.队列的定义"></a>1.队列的定义</h5><p>队列简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。其操作的特性是先进先出(FIFO)<br><strong>队头</strong>：允许删除的一端，又称队首<br><strong>队尾</strong>：允许插入的一端</p><h5 id="2-队列常见的基本操作"><a href="#2-队列常见的基本操作" class="headerlink" title="2.队列常见的基本操作"></a>2.队列常见的基本操作</h5><p>InitQueue(&amp;Q)：初始化队列，构造个空队列Q。<br>QueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。<br>EnQueue(&amp;Q,x)：入队，若队列Q未满，将x加入，使之成为新的队尾。<br>DeQueue(&amp;Q, &amp;x)：出队，若队列Q非空，删除队头元素，并用x返回。<br>GetHead(Q,&amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给X。</p><h4 id="3-2-2-队列的顺序存储结构"><a href="#3-2-2-队列的顺序存储结构" class="headerlink" title="3.2.2 队列的顺序存储结构"></a>3.2.2 队列的顺序存储结构</h4><h5 id="1-队列的顺序存储"><a href="#1-队列的顺序存储" class="headerlink" title="1.队列的顺序存储"></a>1.队列的顺序存储</h5><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置（不同教材对front和rear的定义可能不同，对于不同的定义，出队入队的操作是不同的）。</p><p>队列的顺序存储类型可描述为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MaxSize <span class="token number">50</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token punctuation">,</span>rear<span class="token punctuation">;</span><span class="token punctuation">}</span>SqQueue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>初始状态</strong>（队空条件）: Q.front==Q.rear==0。<br><strong>进队操作</strong>：队不满时，先送值到队尾元素，再将队尾指针加1。<br><strong>出队操作</strong>：队不空时，先取队头元素值，再将队头指针加1。</p><p>这样存储可能会发生“假溢出”。</p><p><img src="/images/Data-Structure/image-20210422155137122.png" alt=""></p><center><span style="color:blue;font-size:15px">2021/4/22</span></center><h5 id="2-循环队列"><a href="#2-循环队列" class="headerlink" title="2.循环队列"></a>2.循环队列</h5><p>为了克服顺序存储的缺点，这里引出循环队列的概念，即把存储队列元素的表从逻辑上视为一个环。当队首指针Q.front=MaxSize-1后，再前进一个位置就自动到0，这可以利用除法<strong>取余</strong>运算来实现。</p><p>初始时：Q.front=Q.rear=0。<br>队首指针进1：Q.front= (Q.front+1)%MaxSize。<br>队尾指针进1：Q.rear= (Q.rear+1)%MaxSize。<br>队列长度：(Q.rear+MaxSize-Q.front)%MaxSize。</p><p>但是队空和队满的条件都是Q.front==Q.rear，为了<strong>区分队空还是队满</strong>的情况，有三种处理方式：<br>（1）牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，约定以“队头指针在队尾指针的下-一位置作为队满的标志。<br>队满条件：(Q.rear+1) %MaxSize==Q.front。<br>队空条件仍：Q.front==Q.rear.<br>队列中元素的个数：(Q.rear-Q.front+MaxSize)%MaxSize。<br>（2）类型中增设表示元素个数的数据成员。这样，队空的条件为Q.size==0；队满的条件为Q.size==MaxSize。这两种情况都有Q.front==Q. rear。<br>（3）类型中增设tag 数据成员，以区分是队满还是队空。（入队置1，出队置0，初试设0）tag等于0时，若因删除导致Q. front==Q.rear，则为队空；tag等于1时,若因插入导致Q.front==Q.rear,则为队满。</p><p><img src="/images/Data-Structure/image-20210422164650942.png" alt=""></p><h5 id="3-循环队列的操作"><a href="#3-循环队列的操作" class="headerlink" title="3.循环队列的操作"></a>3.循环队列的操作</h5><p>（1）初始化<br>（2）判断空<br>（3）入队</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">EnQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>ElemType x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MaxSize<span class="token operator">==</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>data<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MaxSize<span class="token punctuation">;</span>    <span class="token keyword">return</span> ture<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）出队</p><h4 id="3-2-3-队列的链式存储结构"><a href="#3-2-3-队列的链式存储结构" class="headerlink" title="3.2.3 队列的链式存储结构"></a>3.2.3 队列的链式存储结构</h4><h5 id="1-队列的链式存储"><a href="#1-队列的链式存储" class="headerlink" title="1.队列的链式存储"></a>1.队列的链式存储</h5><p>队列的链式表示称为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点。</p><p><img src="/images/Data-Structure/image-20210422171448161.png" alt=""></p><p>队列的链式存储类型可描述为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    ElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>LinkNode<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    LinkNode <span class="token operator">*</span>front<span class="token punctuation">,</span> <span class="token operator">*</span>rear<span class="token punctuation">;</span><span class="token punctuation">}</span> LinkQueue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当Q.front==NULL且Q.rear==NULL时，链式队列为空。</p><p>不带头结点的链式队列在操作上往往比较麻烦，因此<strong>通常将链式队列设计成一个带头结点的单链表</strong>，这样插入和删除操作就统一了。</p><p><img src="/images/Data-Structure/image-20210422171950914.png" alt=""></p><p>用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。</p><h5 id="2-链式队列的基本操作"><a href="#2-链式队列的基本操作" class="headerlink" title="2.链式队列的基本操作"></a>2.链式队列的基本操作</h5><p>（1）初始化<br>（2）判断空<br>（3）入队<br>（4）出队</p><h4 id="3-2-4-双端队列"><a href="#3-2-4-双端队列" class="headerlink" title="3.2.4 双端队列"></a>3.2.4 双端队列</h4><p>双端队列是指允许两端都可以进行入队和出队操作的队列。其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端，两端都可以入队和出队。<br>输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列。<br>输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为输入受限的双端队列。<br>若限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相邻接的栈。</p><h3 id="3-3栈和队列的应用"><a href="#3-3栈和队列的应用" class="headerlink" title="3.3栈和队列的应用"></a>3.3栈和队列的应用</h3><h4 id="3-3-1-栈在括号匹配中的应用"><a href="#3-3-1-栈在括号匹配中的应用" class="headerlink" title="3.3.1 栈在括号匹配中的应用"></a>3.3.1 栈在括号匹配中的应用</h4><h4 id="3-2-2-栈在表达式求值中的应用"><a href="#3-2-2-栈在表达式求值中的应用" class="headerlink" title="3.2.2 栈在表达式求值中的应用"></a>3.2.2 栈在表达式求值中的应用</h4><div class="table-container"><table><thead><tr><th>中缀表达式(a 操作符 b)</th><th>后缀表达式(逆波兰式)(a b 操作符)</th><th>前缀表达式(波兰式)(操作符 a b)</th></tr></thead><tbody><tr><td>a+b</td><td>ab+</td><td>+ab</td></tr><tr><td>a+b-c</td><td>ab+c-</td><td>-+abc</td></tr><tr><td>a+b-c*d</td><td>ab+cd*-</td><td>-+ab*cd</td></tr><tr><td>a+b*(c-d)-e/f</td><td>abcd-*+ef/-</td><td>+a-*-cdb/ef</td></tr></tbody></table></div><p><strong>后缀表达式的运算：</strong></p><p>在后缀表达式中已考虑了运算符的优先级，没有括号，只有操作数和运算符。<br>中缀表达式A+B*(C-D)-E/F​所对应的后缀表达式为ABCD-*+EF/-​。</p><p>若项是操作数，则将其压入栈中；若项是操作符，则连续从栈中退出两个操作数Y和X，形成运算指令X op Y,并将计算结果重新压入栈中。全部处理完后，栈顶存放的就是结果。</p><p><strong>前缀表达式的运算：</strong></p><p>前缀表达式从右往左扫，原理差不多</p><p><strong>中缀表达式转后缀表达式：</strong></p><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。<br>从左到右处理各个元素，直到末尾。可能遇到三种情况: .<br>①遇到操作数。直接加入后缀表达式。<br>②遇到界限符。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(” 为止。注意:“(” 不加入后缀表达式。<br>③遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(”或栈空则停止。之后再把当前运算符入栈。<br>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p><p><a href="https://www.bilibili.com/video/BV1b7411N798?p=28">中缀表达式转后缀表达式/中缀表达式的计算（用栈实现）:</a></p><h4 id="3-3-3-栈在递归中的作用"><a href="#3-3-3-栈在递归中的作用" class="headerlink" title="3.3.3 栈在递归中的作用"></a>3.3.3 栈在递归中的作用</h4><p>适合用“递归”算法解决：可以把原始问题转换为<strong>属性相同</strong>，但<strong>规模较小</strong>的问题<br>栈递归算法大大减少了程序的代码量，但在通常情况下，它的效率不是太高。</p><p>递归函数的实现需要借助一个函数调用栈来实现。<br>（也可以将递归算法转换为非递归算法，通常需要借助栈来实现这种转换。）</p><h4 id="3-3-4-队列在层次遍历中的应用（广度优先遍历）"><a href="#3-3-4-队列在层次遍历中的应用（广度优先遍历）" class="headerlink" title="3.3.4 队列在层次遍历中的应用（广度优先遍历）"></a>3.3.4 队列在层次遍历中的应用（广度优先遍历）</h4><p>逐层\逐行处理（广度优先遍历）。这类问题的解决方法往往是在处理当前层或当前行时就对下一层或下一行做预处理，把处理顺序安排好，待当前层或当前行处理完毕，就可以处理下一层或下一行。使用队列是为了保存下一步的处理顺序。表3.2显示了层次遍历二叉树的过程。<br>该过程的简单描述如下:<br>①根结点入队。<br>②若队空（所有结点都已处理完毕），则结束遍历；否则重复③操作。<br>③队列中第一个结点出队并访问。若其有左孩子，则将左孩子入队；若其有右孩子，则将右孩子入队，返回②。</p><p><img src="/images/Data-Structure/image-20210422210537669.png" alt=""></p><h4 id="3-3-5-队列在计算机系统中的应用"><a href="#3-3-5-队列在计算机系统中的应用" class="headerlink" title="3.3.5 队列在计算机系统中的应用"></a>3.3.5 队列在计算机系统中的应用</h4><p>打印数据缓冲区、CPU进程访问队列……</p><center><span style="color:blue;font-size:15px">2021/4/23</span></center><h3 id="3-4-特殊矩阵的压缩存储"><a href="#3-4-特殊矩阵的压缩存储" class="headerlink" title="3.4 特殊矩阵的压缩存储"></a>3.4 特殊矩阵的压缩存储</h3><p>矩阵在计算机图形学、工程计算中占有举足轻重的地位。在数据结构中考虑的是如何用最小的内存空间来存储同样的一组数据。</p><h4 id="3-4-1-数组的定义"><a href="#3-4-1-数组的定义" class="headerlink" title="3.4.1 数组的定义"></a>3.4.1 数组的定义</h4><h4 id="3-4-2-数组的存储结构"><a href="#3-4-2-数组的存储结构" class="headerlink" title="3.4.2 数组的存储结构"></a>3.4.2 数组的存储结构</h4><h4 id="3-4-3-矩阵的压缩存储"><a href="#3-4-3-矩阵的压缩存储" class="headerlink" title="3.4.3 矩阵的压缩存储"></a>3.4.3 矩阵的压缩存储</h4><p>压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是为了节省存储空间。</p><h5 id="1-对称矩阵"><a href="#1-对称矩阵" class="headerlink" title="1.对称矩阵"></a>1.对称矩阵</h5><p><img src="/images/Data-Structure/PL%5D02XD8%5BHT24T%605$D1%7B%7BG4-1619144889792.png" alt=""></p><h5 id="2-三角矩阵"><a href="#2-三角矩阵" class="headerlink" title="2.三角矩阵"></a>2.三角矩阵</h5><p><img src="/images/Data-Structure/image-20210423103127933.png" alt=""></p><h5 id="3-三对角矩阵"><a href="#3-三对角矩阵" class="headerlink" title="3.三对角矩阵"></a>3.三对角矩阵</h5><p><img src="/images/Data-Structure/image-20210423104520259.png" alt=""></p><h4 id="3-4-4-稀疏矩阵"><a href="#3-4-4-稀疏矩阵" class="headerlink" title="3.4.4 稀疏矩阵"></a>3.4.4 稀疏矩阵</h4><p>稀疏矩阵：非零元素远远少于矩阵元素的个数</p><p><img src="/images/Data-Structure/image-20210423104735236.png" alt=""></p><center><span style="color:blue;font-size:15px">2021/4/27</span></center><h2 id="第4章-串"><a href="#第4章-串" class="headerlink" title="第4章 串"></a>第4章 串</h2><p>统考大纲只要求掌握字符串模式匹配，需重点掌握KMP匹配算法的原理及next数组的推理过程，了解nextval数组的求解方法。</p><h3 id="408大纲-2"><a href="#408大纲-2" class="headerlink" title="408大纲"></a>408大纲</h3><p>字符串模式匹配</p><h3 id="4-1-串的定义和实现"><a href="#4-1-串的定义和实现" class="headerlink" title="4.1 串的定义和实现"></a>4.1 串的定义和实现</h3><p>字符串简称串，计算机上非数值处理的对象基本都是字符串数据。</p><h4 id="4-1-1-串的定义"><a href="#4-1-1-串的定义" class="headerlink" title="4.1.1 串的定义"></a>4.1.1 串的定义</h4><p>串(string) 是由零个或多个字符组成的有限序列。一般记为</p><script type="math/tex; mode=display">S='{a_1a_2...a_n}'(n\geq0)</script><p><strong>子串：</strong>串中任意个连续的字符组成的子序列。<br><strong>主串：</strong>包含子串的串。<br><strong>字符在主串中的位置：</strong>字符在串中的序号。<br><strong>子串在主串中的位置：</strong>子串的第一个字符在主串中的位置。</p><p>串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集。</p><p>串的基本操作通常以子串作为操作对象，如查找、插入或删除一个子串等。</p><h4 id="4-1-2-串的顺序结构"><a href="#4-1-2-串的顺序结构" class="headerlink" title="4.1.2 串的顺序结构"></a>4.1.2 串的顺序结构</h4><h5 id="1-定长顺序存储表示"><a href="#1-定长顺序存储表示" class="headerlink" title="1.定长顺序存储表示"></a>1.定长顺序存储表示</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MAXLEN <span class="token number">255</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> ch<span class="token punctuation">[</span>MAXLEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span>SString<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>串长有两种表示方法：一是如上述定义描述的那样，用一个额外的变量len来存放串的长度；二是在串<br>值后面加一一个不计入串长的结束标记字符“\0”， 此时的串长为隐含值。</p><h5 id="2-堆（动态）分配存储表示"><a href="#2-堆（动态）分配存储表示" class="headerlink" title="2.堆（动态）分配存储表示"></a>2.堆（动态）分配存储表示</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span>SString<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-块链存储表示"><a href="#3-块链存储表示" class="headerlink" title="3.块链存储表示"></a>3.块链存储表示</h5><p>也可采用链表方式存储串值。由于串的特殊性(每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符， 也可以存放多个字符。每个结点称为块，整个链表称为块链结构。最后一个结点占不满时通常用“#”补上。</p><p><img src="/images/Data-Structure/image-20210427105854294.png" alt=""></p><h4 id="4-1-3-串的基本操作"><a href="#4-1-3-串的基本操作" class="headerlink" title="4.1.3 串的基本操作"></a>4.1.3 串的基本操作</h4><ul><li><strong>StrAssign(&amp;T, chars)：赋值操作。</strong>把串T赋值为chars。</li><li>StrCopy(&amp;T,S)：复制操作。由串S复制得到串T。</li><li>StrEmpty(S)：判空操作。若S为空串，则返回TRUE，否则返回FALSE。</li><li><strong>StrCompare(S,T)：比较操作</strong>。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0;若S&lt;T，则返回值&lt;0。</li><li><strong>StrLength(S)：求串长。</strong>返回串S的元素个数。</li><li><strong>SubString (&amp;Sub,S,pos,len)：求子串。</strong>用Sub返回串S的第pos个字符起长度为len的子串。</li><li><strong>Concat (&amp;T,S1,S2)：串联接。</strong>用T返回由S1和S2联接而成的新串。</li><li>Index(S,T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。</li><li>ClearString(&amp;S)：清空操作。将S清为空串。</li><li>DestroyString(&amp;S)：销毁串。将串S销毁。</li></ul><p>在上述定义的操作中，<strong>串赋值StrAssign、串比较StrCompare、求串长StrLength、串联接Concat及求子串SubString五种操作构成串类型的最小操作子集</strong>，即这些操作不可能利用其他串操作来实现；反之，其他串操作（除串清除ClearString和串销毁DestroyString外）均可在该最小操作子集上实现。</p><p>例如，可利用判等、求串长和求子串等操作实现定位函数Index(S,T)。算法思想为:在主串S中取从第一个字符起、长度和串T相等的子串，与串T比较，若相等则求得函数值为i，否则i值增1，直至串S中不存在和串T相等的子串为止。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Index</span><span class="token punctuation">(</span>String S，String T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token function">StrLength</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">,</span>m<span class="token operator">=</span><span class="token function">StrLength</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>n<span class="token operator">-</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">SubString</span><span class="token punctuation">(</span>sub<span class="token punctuation">,</span>S<span class="token punctuation">,</span>i<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">StrCompare</span><span class="token punctuation">(</span>sub<span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-串的模式匹配"><a href="#4-2-串的模式匹配" class="headerlink" title="4.2 串的模式匹配"></a>4.2 串的模式匹配</h3><p>子串的定位操作通常称为串的模式匹配，它求的是子串(常称模式串)在主串中的位置。</p><h4 id="4-2-1-简单的模式匹配算法"><a href="#4-2-1-简单的模式匹配算法" class="headerlink" title="4.2.1 简单的模式匹配算法"></a>4.2.1 简单的模式匹配算法</h4>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>又一次搞崩博客的经历</title>
      <link href="2021/02/14/annoying-err/"/>
      <url>2021/02/14/annoying-err/</url>
      
        <content type="html"><![CDATA[<p>经过一次折腾，网站又双叒叕访问不了了，怎么都解决不了，而且这次的问题也太怪了</p><p>ip和域名都能ping通</p><p><img src="/images/annoying-err/image-20210214134957668.png" alt=""></p><p>nginx启动正常</p><p><img src="/images/annoying-err/image-20210214134338024.png" alt=""></p><p>端口未被占用</p><p><img src="/images/annoying-err/image-20210214134406848.png" alt=""></p><p>防火墙已开放80端口（<a href="https://www.cnblogs.com/furenjian/p/12612547.html">防火墙设置 </a>）</p><p><img src="/images/annoying-err/image-20210214134506577.png" alt=""></p><p>然鹅就是访问不了</p><p><img src="/images/annoying-err/image-20210214134541301.png" alt=""></p><p>真是怪了，折腾了好久都不行，可能博客得瘫痪一段时间了</p><p>后记：突然又能用了，我等理解不能</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++中STL的常用用法</title>
      <link href="2021/02/03/cpp-stl/"/>
      <url>2021/02/03/cpp-stl/</url>
      
        <content type="html"><![CDATA[<h3 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h3><h4 id="1-容器（container）"><a href="#1-容器（container）" class="headerlink" title="1.容器（container）"></a>1.容器（container）</h4><ul><li>1.向量（vector）</li><li>2.双端队列（deque）</li><li>3.列表（list）</li><li>4.集合（set）</li><li>5.多重集合（multiset）</li><li>6.映射（map）</li><li>7.关联容器（associative）</li></ul><h4 id="2-迭代器（iterator）"><a href="#2-迭代器（iterator）" class="headerlink" title="2.迭代器（iterator）"></a>2.迭代器（iterator）</h4><p>迭代器提供了顺序访问容器中每个元素的方法。对迭代器可以使用“++”运算符来获得指向下一个元素的迭代器，可以使用“*”运算符访问一个迭代器所指向的元素。如果元素类型是类或结构体，还可以使用“-&gt;”运算符直接访问该元素的一个成员，有些迭代器还支持通过“—”运算符获得指向上一个元素的迭代器。指针也具有相同的特性，因此指针本身就是一种迭代器，迭代器是泛化的指针。</p><h4 id="3-函数对象（function-object）"><a href="#3-函数对象（function-object）" class="headerlink" title="3.函数对象（function object）"></a>3.函数对象（function object）</h4><p>函数对象是泛化的函数</p><h4 id="4-算法（algorithm）"><a href="#4-算法（algorithm）" class="headerlink" title="4.算法（algorithm）"></a>4.算法（algorithm）</h4><p>使用STL的算法，需要包含头文件\<algorithm\></algorithm\></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="map-unordered-map"><a href="#map-unordered-map" class="headerlink" title="map / unordered_map"></a>map / unordered_map</h3><p>map是STL的一个关联容器，它提供一对一的hash。</p><ul><li>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；</li><li>第二个可能称为该关键字的值(value)；</li></ul><p>使用map得包含map类所在的头文件</p><p><code>#include &lt;map&gt;</code></p><h4 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h4><p><code>map&lt;int, string&gt; hashtable;</code></p><h4 id="插入元素："><a href="#插入元素：" class="headerlink" title="插入元素："></a>插入元素：</h4><p> <code>hashtable[7] = "seven";</code><br> <code>hashtable.insert(pair&lt;int, string&gt;(7, "seven"));</code></p><h4 id="查找元素："><a href="#查找元素：" class="headerlink" title="查找元素："></a>查找元素：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// find 返回迭代器指向当前查找元素的位置否则返回map::end()位置</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span><span class="token operator">::</span>iterator iter <span class="token operator">=</span>  hashtable<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用auto更好</span><span class="token keyword">if</span><span class="token punctuation">(</span>iter <span class="token operator">!=</span> hashtable<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span>iter<span class="token operator">-&gt;</span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="刪除与清空元素："><a href="#刪除与清空元素：" class="headerlink" title="刪除与清空元素："></a>刪除与清空元素：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//迭代器刪除</span>iter <span class="token operator">=</span> hashtable<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hashtable<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//用关键字刪除</span><span class="token keyword">int</span> status <span class="token operator">=</span> hashtable<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//如果刪除了會返回1，否則返回0</span> <span class="token comment">//用迭代器范围刪除 : 把整个map清空</span>hashtable<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>hashtable<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hashtable<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等同于hashtable.clear()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="map的大小："><a href="#map的大小：" class="headerlink" title="map的大小："></a>map的大小：</h4><p><code>hashtable.size();</code></p><h4 id="其他常用用法："><a href="#其他常用用法：" class="headerlink" title="其他常用用法："></a>其他常用用法：</h4><p><strong>begin</strong>()     返回指向map头部的迭代器</p><p><strong>end</strong>()      返回指向map末尾的迭代器</p><p><strong>count</strong>()     返回指定元素出现的次数</p><p><strong>empty</strong>()     如果map为空则返回true</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端</title>
      <link href="2021/01/28/front-end/"/>
      <url>2021/01/28/front-end/</url>
      
        <content type="html"><![CDATA[<p>在学校学过，然后就没有然后了。。。</p><p>本篇大多内容来自菜鸟教程</p><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><p>内容不多，看着菜鸟教程入门的写了一个<a href="/html/Front-end/dazahui.html">超级无敌大浆糊页面</a></p><p>不过hexo居然丧心病狂地把我这个页面也给渲染了。。。查到的<a href="https://blog.csdn.net/weixin_41287260/article/details/99705257">解决办法</a></p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>CSS 指层叠样式表 (<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)<br>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:<br>选择器通常是您需要改变样式的 HTML 元素。每条声明由一个属性和一个值组成。</p><p>例：<code>p {color:red;text-align:center;}</code></p><p>CSS注释：</p><p><code>/*这是个注释*/</code></p><h3 id="id-和-class-选择器"><a href="#id-和-class-选择器" class="headerlink" title="id 和 class 选择器"></a>id 和 class 选择器</h3><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">#para1</span><span class="token punctuation">{</span>    <span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点”.”号显示：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*所有拥有 center 类的 HTML 元素均为居中*/</span><span class="token selector">.center</span> <span class="token punctuation">{</span><span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*所有的 p 元素使用 class="center" 让该元素的文本居中*/</span><span class="token selector">p.center</span> <span class="token punctuation">{</span><span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>类名的第一个字符不能使用数字！</strong></p><h3 id="如何插入样式表"><a href="#如何插入样式表" class="headerlink" title="如何插入样式表"></a>如何插入样式表</h3><p>插入样式表的方法有三种:</p><ul><li>外部样式表(External style sheet)</li><li>内部样式表(Internal style sheet)</li><li>内联样式(Inline style)</li></ul><h4 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h4><p>当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，可以通过改变一个文件来改变整个站点的外观。每个页面使用 link 标签链接到样式表。 link 标签在（文档的）头部：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mystyle.css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>外部样式表可以在任何文本编辑器中进行编辑。文件不能包含任何的 html 标签。样式表应该以 .css 扩展名进行保存。下面是一个样式表文件的例子：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">hr</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>sienna<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">p</span> <span class="token punctuation">{</span><span class="token property">margin-left</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">body</span> <span class="token punctuation">{</span><span class="token property">background-image</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">"/images/back40.gif"</span><span class="token punctuation">)</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h4><p>当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 style 标签在文档头部定义内部样式表</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">        <span class="token selector">hr</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>sienna<span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token selector">p</span> <span class="token punctuation">{</span><span class="token property">margin-left</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token selector">body</span> <span class="token punctuation">{</span><span class="token property">background-image</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">"images/back40.gif"</span><span class="token punctuation">)</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token selector">table,th,td</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">/*逗号：多个标签*/</span>        <span class="token selector">tr.alt td</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">/*空格：class为alt的tr下层的td*/</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><p>请慎用这种方法</p><p>要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>sienna<span class="token punctuation">;</span><span class="token property">margin-left</span><span class="token punctuation">:</span>20px</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是一个段落。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="color:sienna;margin-left:20px">这是一个段落。</p><h4 id="多重样式优先级"><a href="#多重样式优先级" class="headerlink" title="多重样式优先级"></a>多重样式优先级</h4><p>样式表允许以多种方式规定样式信息。样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。一般情况下，优先级如下：</p><p><strong>内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</strong></p><blockquote><p><strong>注意：*</strong>如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。*</p></blockquote><h3 id="CSS-backgrounds-背景"><a href="#CSS-backgrounds-背景" class="headerlink" title="CSS backgrounds(背景)"></a>CSS backgrounds(背景)</h3><ul><li>background-color</li><li>background-image</li><li>background-repeat</li><li>background-attachment</li><li>background-position</li><li>background</li></ul><h4 id="background-color-背景颜色"><a href="#background-color-背景颜色" class="headerlink" title="background-color 背景颜色"></a>background-color 背景颜色</h4><p>red;<br>#00ff00;<br>rgb(255,0,0);</p><h4 id="background-image-背景图片"><a href="#background-image-背景图片" class="headerlink" title="background-image 背景图片"></a>background-image 背景图片</h4><p><code>body {background-image:url('1.jpg');}</code></p><h4 id="background-repeat-背景图片重复平铺"><a href="#background-repeat-背景图片重复平铺" class="headerlink" title="background-repeat 背景图片重复平铺"></a>background-repeat 背景图片重复平铺</h4><p>默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体。一些图像如果在水平方向与垂直方向平铺，这样看起来很不协调，</p><p><code>background-repeat:repeat-x;</code></p><p>这样就让其只在水平方向平铺</p><h4 id="background-attachment-背景图片定位"><a href="#background-attachment-背景图片定位" class="headerlink" title="background-attachment 背景图片定位"></a>background-attachment 背景图片定位</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">body</span><span class="token punctuation">{</span><span class="token property">background-image</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">'img_tree.png'</span><span class="token punctuation">)</span></span><span class="token punctuation">;</span><span class="token property">background-repeat</span><span class="token punctuation">:</span>no-repeat<span class="token punctuation">;</span><span class="token property">background-position</span><span class="token punctuation">:</span>right top<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就实现了图片不重复，且放在右上角</p><h4 id="background-position-背景随页面滚动"><a href="#background-position-背景随页面滚动" class="headerlink" title="background-position 背景随页面滚动"></a>background-position 背景随页面滚动</h4><p>background-attachment属性设置背景图像是否固定或者随着页面的其余部分滚动。</p><h4 id="background-简写属性"><a href="#background-简写属性" class="headerlink" title="background 简写属性"></a>background 简写属性</h4><p><code>body {background:#ffffff url('img_tree.png') no-repeat right top;}</code></p><p>顺序为上面介绍的顺序，无需全部使用，可以按照页面的实际需要使用.</p><iframe src="https://www.runoob.com/try/try.php?filename=trycss_background_shorthand2" width="100%" height="600"></iframe><h3 id="CSS-text-文本"><a href="#CSS-text-文本" class="headerlink" title="CSS text(文本)"></a>CSS text(文本)</h3><ul><li>color</li><li>text-align</li><li>text-decoration</li><li>text-transform</li><li>text-indent</li><li>letter-spacing</li><li>line-height</li><li>word-spacing</li><li>text-shadow</li></ul><h4 id="color-文本颜色"><a href="#color-文本颜色" class="headerlink" title="color 文本颜色"></a>color 文本颜色</h4><p><code>&lt;span style="color:red;"&gt;这是红字&lt;/span&gt;</code></p><p><span style="color:red;">这是红字</span></p><h4 id="text-align-文本的对齐方式"><a href="#text-align-文本的对齐方式" class="headerlink" title="text-align 文本的对齐方式"></a>text-align 文本的对齐方式</h4><p><code>&lt;p style="text-align:center;"&gt;我在中间&lt;/p&gt;</code></p><p style="text-align:center;">我在中间</p><h4 id="text-decoration-文本上的线"><a href="#text-decoration-文本上的线" class="headerlink" title="text-decoration 文本上的线"></a>text-decoration 文本上的线</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-decoration</span><span class="token punctuation">:</span>overline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>上面的线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-decoration</span><span class="token punctuation">:</span>line-through<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>删除线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-decoration</span><span class="token punctuation">:</span>underline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>底下的线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-decoration</span><span class="token punctuation">:</span>underline overline dotted blue<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>蓝色上下虚线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-decoration</span><span class="token punctuation">:</span>underline wavy red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>红色波浪形下划线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://ep4l.com<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-decoration</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>超链接去线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div>    <p style="text-decoration:overline;">上面的线</p>    <p style="text-decoration:line-through;">删除线</p>    <p style="text-decoration:underline;">底下的线</p>    <p style="text-decoration:underline overline dotted blue;">蓝色上下虚线</p>    <p style="text-decoration:underline wavy red;">红色波浪形下划线</p>    <a href="https://ep4l.com" style="text-decoration:none;">超链接去线</a></div><h4 id="text-transform-大小写转换"><a href="#text-transform-大小写转换" class="headerlink" title="text-transform 大小写转换"></a>text-transform 大小写转换</h4><p>可以转变文本的大小写</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-transform</span><span class="token punctuation">:</span>uppercase<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-transform</span><span class="token punctuation">:</span>lowercase<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-transform</span><span class="token punctuation">:</span>capitalize<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p style="text-transform:uppercase;">This is some text.</p><p style="text-transform:lowercase;">This is some text.</p><p style="text-transform:capitalize;">This is some text.</p><h4 id="text-indent-首行缩进"><a href="#text-indent-首行缩进" class="headerlink" title="text-indent 首行缩进"></a>text-indent 首行缩进</h4><p>文本缩进属性是用来指定文本的第一行的缩进。</p><p><code>&lt;p style="text-indent:50px;"&gt;balabala&lt;/p&gt;</code></p><p style="text-indent:50px;">车位费幕后成为覅海外仓粉煤灰IC我没法hi欧吃完饭后IC我为此欧辰我IEhi从未hi出没无常我覅欧美汇慈文传媒是服务器从IC我粗黑触怒万能充我拿出WiFi从未in哦</p><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><h5 id="letter-spacing-字符之间的空间："><a href="#letter-spacing-字符之间的空间：" class="headerlink" title="letter-spacing 字符之间的空间："></a>letter-spacing 字符之间的空间：</h5><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">letter-spacing</span><span class="token punctuation">:</span>2px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">letter-spacing</span><span class="token punctuation">:</span>-3px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p style="letter-spacing:2px;">This is some text.</p><p style="letter-spacing:-3px;">This is some text.</p><h5 id="line-height-行与行之间的空间："><a href="#line-height-行与行之间的空间：" class="headerlink" title="line-height 行与行之间的空间："></a>line-height 行与行之间的空间：</h5><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">line-height</span><span class="token punctuation">:</span>70%<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">line-height</span><span class="token punctuation">:</span>200%<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p style="line-height:70%;">    This is some text.<br>    This is some text.<br></p><p style="line-height:200%;">    This is some text.<br>    This is some text.<br></p><h5 id="word-spacing-单词之间的空间："><a href="#word-spacing-单词之间的空间：" class="headerlink" title="word-spacing 单词之间的空间："></a>word-spacing 单词之间的空间：</h5><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">word-spacing</span><span class="token punctuation">:</span>30px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    This is some text. This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p style="word-spacing:30px;">This is some text. This is some text.</p><h5 id="text-shadow-文本阴影："><a href="#text-shadow-文本阴影：" class="headerlink" title="text-shadow 文本阴影："></a>text-shadow 文本阴影：</h5><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>white<span class="token punctuation">;</span><span class="token property">text-shadow</span><span class="token punctuation">:</span>2px 2px 4px #000000<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    This is some text. This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p style="color:white;text-shadow:2px 2px 4px #000000;">This is some text. This is some text.</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-shadow</span><span class="token punctuation">:</span>2px 2px blue<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-shadow:2px 2px blue;">This is some text.</p><h3 id="CSS-fonts-字体"><a href="#CSS-fonts-字体" class="headerlink" title="CSS fonts(字体)"></a>CSS fonts(字体)</h3><ul><li>font-family </li><li>font-style</li><li>font-size </li><li>font-weight</li><li>font-variant</li><li>font</li></ul><p>CSS字体属性定义字体，加粗，大小，文字样式。</p><h4 id="font-family-字体"><a href="#font-family-字体" class="headerlink" title="font-family  字体"></a>font-family  字体</h4><p>font-family 属性设置文本的字体系列。<br>font-family 属性应该设置几个字体名称作为一种”后备”机制，如果浏览器不支持第一种字体，他将尝试下一种字体。</p><p><code>p{font-family:"Times New Roman", Times, serif;}</code></p><p><a href="https://www.runoob.com/cssref/css-websafe-fonts.html">常用的安全字体组合</a></p><h4 id="font-style-字体样式"><a href="#font-style-字体样式" class="headerlink" title="font-style 字体样式"></a>font-style 字体样式</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-style</span><span class="token punctuation">:</span>normal<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是一个段落,正常。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-style</span><span class="token punctuation">:</span>italic<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是一个段落,斜体。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-style</span><span class="token punctuation">:</span>oblique<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是一个段落,斜体。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p style="font-style:normal;">这是一个段落,正常。</p><p style="font-style:italic;">这是一个段落,斜体。</p><p style="font-style:oblique;">这是一个段落,斜体。</p><h4 id="font-size-字体大小"><a href="#font-size-字体大小" class="headerlink" title="font-size 字体大小"></a>font-size 字体大小</h4><p>能否管理文字的大小，在网页设计中是非常重要的。但是，你不能通过调整字体大小使段落看上去像标题，或者使标题看上去像段落。<br>请务必使用正确的HTML标签，就h1 - h6表示标题和p表示段落：<br>字体大小的值可以是绝对或相对的大小。<br>如果你不指定一个字体的大小，默认大小和普通文本段落一样，是16像素（16px=1em）。</p><h5 id="用em来设置字体大小"><a href="#用em来设置字体大小" class="headerlink" title="用em来设置字体大小"></a>用em来设置字体大小</h5><p>1em和当前字体大小相等。在浏览器中默认的文字大小是16px。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span>2.5em<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span> /* 40px/16=2.5em */<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span>0.875em<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span> /* 14px/16=0.875em */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p style="font-size:2.5em;">This is some text.</p> <p style="font-size:0.875em;">This is some text.</p> <h5 id="使用百分比和EM组合"><a href="#使用百分比和EM组合" class="headerlink" title="使用百分比和EM组合"></a>使用百分比和EM组合</h5><p>在所有浏览器的解决方案中，设置 body元素的默认字体大小的是百分比：</p><p><code>body {font-size:100%;}</code></p><p>在所有浏览器中，可以显示相同的文本大小，并允许所有浏览器缩放文本的大小。</p><h4 id="其他属性-1"><a href="#其他属性-1" class="headerlink" title="其他属性"></a>其他属性</h4><ul><li>font-weight: bold;                                              设置粗体</li><li>font-variant: small-caps;                                   设置小号的大写</li><li>font: italic bold 12px/30px Georgia,serif;       简写</li></ul><h3 id="CSS-链接状态选择器"><a href="#CSS-链接状态选择器" class="headerlink" title="CSS 链接状态选择器"></a>CSS 链接状态选择器</h3><p>链接的样式，可以用任何CSS属性（如颜色，字体，背景等）。</p><p>特别的链接，可以有不同的样式，这取决于他们是什么状态。</p><p>这四个链接状态是：</p><ul><li>a:link - 正常，未访问过的链接</li><li>a:visited - 用户已访问过的链接</li><li>a:hover - 当用户鼠标放在链接上时</li><li>a:active - 链接被点击的那一刻</li></ul><p>当设置为若干链路状态的样式，也有一些顺序规则：</p><ul><li>a:hover 必须跟在 a:link 和 a:visited后面</li><li>a:active 必须跟在 a:hover后面</li></ul><iframe src="https://www.runoob.com/try/try.php?filename=trycss_link2" width="100%" height="600"></iframe><p>这些状态写入内联样式好像需要js</p><h3 id="CSS-列表项标记"><a href="#CSS-列表项标记" class="headerlink" title="CSS 列表项标记"></a>CSS 列表项标记</h3><ul><li>list-style-type</li></ul><p>用来设置列表项标记</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">list-style-type</span><span class="token punctuation">:</span>circle<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>这是<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>圈圈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">list-style-type</span><span class="token punctuation">:</span>square<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>这是<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>方块<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">list-style-type</span><span class="token punctuation">:</span>upper-roman<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>这是<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>大写罗马字母<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">list-style-type</span><span class="token punctuation">:</span>lower-alpha<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>这是<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>小写字母<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">list-style-image</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">'https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/favicon-16x16.png'</span><span class="token punctuation">)</span></span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>这是<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul style="list-style-type:circle;">  <li>这是</li>  <li>圈圈</li></ul><ul style="list-style-type:square;">  <li>这是</li>  <li>方块</li></ul><ol style="list-style-type:upper-roman;">  <li>这是</li>  <li>大写罗马字母</li></ol><ol style="list-style-type:lower-alpha;">  <li>这是</li>  <li>小写字母</li></ol><ul style="list-style-image:url('https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/favicon-16x16.png');">    <li>这是</li>    <li>图片</li></ul><h3 id="CSS-table-表格"><a href="#CSS-table-表格" class="headerlink" title="CSS table(表格)"></a>CSS table(表格)</h3><ul><li>border</li><li>border-collapse</li><li>border-spacing</li><li>text-align / vertical-align</li><li>padding</li><li>background-color / color</li></ul><h4 id="border-表格边框"><a href="#border-表格边框" class="headerlink" title="border 表格边框"></a>border 表格边框</h4><p>对table/th/td使用</p><p><code>border: 1px solid black;</code></p><h4 id="border-collapse-折叠边框"><a href="#border-collapse-折叠边框" class="headerlink" title="border-collapse 折叠边框"></a>border-collapse 折叠边框</h4><p>对table使用</p><p>设置表格的边框是否被折叠成一个单一的边框或隔开</p><p><code>border-collapse:collapse;</code></p><h4 id="border-spacing-边框间距（仅用于”边框分离”模式）"><a href="#border-spacing-边框间距（仅用于”边框分离”模式）" class="headerlink" title="border-spacing 边框间距（仅用于”边框分离”模式）"></a>border-spacing 边框间距（仅用于”边框分离”模式）</h4><p>对table使用</p><p><code>border-collapse:separate;</code></p><p><code>border-spacing:10px 50px;</code></p><h4 id="表格文字对齐"><a href="#表格文字对齐" class="headerlink" title="表格文字对齐"></a>表格文字对齐</h4><p><code>text-align:right;</code>去</p><p><code>vertical-align:bottom;</code></p><h4 id="padding-填充属性"><a href="#padding-填充属性" class="headerlink" title="padding 填充属性"></a>padding 填充属性</h4><p>对table/th/td使用，可以写4个值</p><p><code>padding:15px;</code></p><h4 id="表格颜色"><a href="#表格颜色" class="headerlink" title="表格颜色"></a>表格颜色</h4><p>对table/th/td使用</p><p><code>background-color:green;</code></p><p><code>color:white;</code></p><h3 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a>CSS 盒子模型</h3><p>所有HTML元素可以看作盒子。<br>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。<br>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。<br>下面的图片说明了盒子模型(Box Model)：</p><ul><li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li><li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。</li><li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li><li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li></ul><p><img src="https://www.runoob.com/images/box-model.gif" alt=""></p><div style="    background-color: lightgrey;    width: 300px;    border: 25px solid green;    padding: 25px;    margin: 25px;">这里是盒子内的实际内容。有 25px 内间距，25px 外间距、25px 绿色边框。</div><h4 id="元素的宽度和高度"><a href="#元素的宽度和高度" class="headerlink" title="元素的宽度和高度"></a>元素的宽度和高度</h4><p><strong>重要:</strong> 当您指定一个 CSS 元素的宽度和高度属性时，你只是设置内容区域的宽度和高度。要知道，完整大小的元素，你还必须添加内边距，边框和边距。</p><h3 id="CSS-Border-边框"><a href="#CSS-Border-边框" class="headerlink" title="CSS Border(边框)"></a>CSS Border(边框)</h3><p>CSS边框属性允许你指定一个元素边框的样式和颜色。</p><ul><li>border-style</li><li>border-width</li><li>border-color</li><li>各边分别设置</li><li>border</li></ul><h4 id="border-style-边框样式"><a href="#border-style-边框样式" class="headerlink" title="border-style 边框样式"></a>border-style 边框样式</h4><div>    <p style="border-style:none">none:无边框。</p>    <p style="border-style:dotted">dotted:虚线边框。</p>    <p style="border-style:dashed">dashed:虚线边框。</p>    <p style="border-style:solid">solid:实线边框。</p>    <p style="border-style:double">double:双边框。</p>    <p style="border-style:groove"> groove:凹槽边框。</p>    <p style="border-style:ridge">ridge:脊状边框。</p>    <p style="border-style:inset">inset：嵌入边框。</p>    <p style="border-style:outset">outset：外凸边框。</p>    <p style="border-style:hidden">hidden：隐藏边框。</p></div><h4 id="border-width-边框宽度"><a href="#border-width-边框宽度" class="headerlink" title="border-width 边框宽度"></a>border-width 边框宽度</h4><p>为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em(单位为 px, pt, cm, em 等)，或者使用 3 个关键字之一，它们分别是 thick 、medium（默认值） 和 thin。</p><p><strong>注意：</strong>CSS 没有定义 3 个关键字的具体宽度，所以一个用户可能把 <strong>thick</strong> 、<strong>medium</strong> 和 <strong>thin</strong> 分别设置为等于 5px、3px 和 2px，而另一个用户则分别设置为 3px、2px 和 1px。</p><p><strong>注意:</strong> “border-width” 属性 如果单独使用则不起作用。要先使用 “border-style” 属性来设置边框。</p><div>    <p style="border-style:solid;border-width:thick"> thick</p>    <p style="border-style:solid;border-width:medium"> medium</p>    <p style="border-style:solid;border-width:thin"> thin</p></div><h4 id="border-color-边框颜色"><a href="#border-color-边框颜色" class="headerlink" title="border-color 边框颜色"></a>border-color 边框颜色</h4><p><strong>注意：</strong> border-color单独使用是不起作用的，必须得先使用border-style来设置边框样式。</p><div>    <p style="border-style:solid;border-color:red;">实线红色边框</p>    <p style="border-style:solid;border-color:#98bf21;">实线绿色边框</p></div><h4 id="单独设置各边"><a href="#单独设置各边" class="headerlink" title="单独设置各边"></a>单独设置各边</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value">    <span class="token property">border-top-style</span><span class="token punctuation">:</span>dotted<span class="token punctuation">;</span></span><span class="token attr-value"><span class="token property">border-right-style</span><span class="token punctuation">:</span>solid<span class="token punctuation">;</span></span><span class="token attr-value"><span class="token property">border-bottom-style</span><span class="token punctuation">:</span>dotted<span class="token punctuation">;</span></span><span class="token attr-value"><span class="token property">border-left-style</span><span class="token punctuation">:</span>solid<span class="token punctuation">;</span></span><span class="token attr-value">    <span class="token property">border-left-width</span><span class="token punctuation">:</span>15px<span class="token punctuation">;</span></span><span class="token attr-value">    <span class="token property">border-color</span><span class="token punctuation">:</span>#ff0000 #00ff00 #0000ff <span class="token function">rgb</span><span class="token punctuation">(</span>250<span class="token punctuation">,</span>0<span class="token punctuation">,</span>255<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>两个不同的边界样式。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div>    <p style="    border-top-style:dotted;    border-right-style:solid;    border-bottom-style:dotted;    border-left-style:solid;    border-left-width:15px;    border-color:#ff0000 #00ff00 #0000ff rgb(250,0,255);">两个不同的边界样式。</p></div><p>上面的例子也可以设置一个单一属性：</p><p><code>&lt;p style="border-style:dotted solid;"&gt;两个不同的边界样式。&lt;/p&gt;</code></p><p style="border-style:dotted solid;">两个不同的边界样式。</p><p>border-style属性可以有1-4个值：</p><ul><li>4个值的顺序：上、右、下、左</li><li>3个值的顺序：上、左右、下</li><li>2个值的顺序：上下、左右</li></ul><h4 id="border-简写属性"><a href="#border-简写属性" class="headerlink" title="border 简写属性"></a>border 简写属性</h4><p><code>&lt;p style="border:5px solid red;"&gt;简写&lt;/p&gt;</code></p><p style="border:5px solid red;">简写</p><p><code>&lt;p style="border-style:solid;border-top:thick double #ff0000;"&gt;简写&lt;/p&gt;</code></p><p style="border-style:solid;border-top:thick double #ff0000;">简写</p><h4 id="其他属性-2"><a href="#其他属性-2" class="headerlink" title="其他属性"></a>其他属性</h4><p><code>&lt;p style="border:1px solid; border-radius:16px; padding:5px"&gt;圆角边框&lt;/p&gt;</code></p><p style="border:1px solid; border-radius:16px; padding:5px">圆角边框</p><p><code>&lt;p style="background-color:#ddffff; padding:10px;border-left:6px solid #2196F3"&gt;背景和左边框配合&lt;/p&gt;</code></p><p style="background-color:#ddffff; padding:10px;border-left:6px solid #2196F3">背景和左边框配合</p><h3 id="CSS-outline-轮廓"><a href="#CSS-outline-轮廓" class="headerlink" title="CSS outline(轮廓)"></a>CSS outline(轮廓)</h3><p>轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</p><p>轮廓（outline）属性指定元素轮廓的样式、颜色和宽度。</p><p>轮廓设置方法和边框相同，把border改为outline即可</p><p><img src="https://www.runoob.com/images/box_outline.gif" alt=""></p><p><code>&lt;p style="border:10px red solid;outline:25px blue dotted;"&gt;这是边框和轮廓&lt;/p&gt;</code></p><p>这是上面的字</p><p style="border:10px red solid;outline:25px blue dotted; ">这是边框和轮廓</p><p>这是下面的字</p><p>可以看见，outline是不占空间的，即不会增加额外的width或者height或者margin。</p><h3 id="CSS-margin-外边距"><a href="#CSS-margin-外边距" class="headerlink" title="CSS margin(外边距)"></a>CSS margin(外边距)</h3><p>margin 可以单独改变元素的上，下，左，右边距，也可以一次改变所有的属性。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/08/VlwVi.png" alt=""></p><h4 id="可能的值"><a href="#可能的值" class="headerlink" title="可能的值"></a>可能的值</h4><div class="table-container"><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">auto</td><td style="text-align:left">设置浏览器边距。 这样做的结果会依赖于浏览器</td></tr><tr><td style="text-align:left"><em>length</em></td><td style="text-align:left">定义一个固定的margin（使用像素，pt，em等）</td></tr><tr><td style="text-align:left"><em>%</em></td><td style="text-align:left">定义一个使用百分比的边距</td></tr></tbody></table></div><h3 id="CSS-padding-填充"><a href="#CSS-padding-填充" class="headerlink" title="CSS padding(填充)"></a>CSS padding(填充)</h3><p>CSS padding（填充）是一个简写属性，定义元素边框与元素内容之间的空间，即上下左右的内边距。</p><h4 id="可能的值-1"><a href="#可能的值-1" class="headerlink" title="可能的值"></a>可能的值</h4><div class="table-container"><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><em>length</em></td><td style="text-align:left">定义一个固定的填充(像素, pt, em,等)</td></tr><tr><td style="text-align:left"><em>%</em></td><td style="text-align:left">使用百分比值定义一个填充</td></tr></tbody></table></div><h3 id="CSS-分组-和-嵌套-选择器"><a href="#CSS-分组-和-嵌套-选择器" class="headerlink" title="CSS 分组 和 嵌套 选择器"></a>CSS 分组 和 嵌套 选择器</h3><h4 id="分组选择器"><a href="#分组选择器" class="headerlink" title="分组选择器"></a>分组选择器</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">h1,h2,p</span>     <span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span>green<span class="token punctuation">;</span>     <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="嵌套选择器"><a href="#嵌套选择器" class="headerlink" title="嵌套选择器"></a>嵌套选择器</h4><p>它可能适用于选择器内部的选择器的样式。</p><p>在下面的例子设置了三个样式：</p><ul><li><strong>p{ }</strong>: 为所有 <strong>p</strong> 元素指定一个样式。</li><li><strong>.marked{ }</strong>: 为所有 <strong>class=”marked”</strong> 的元素指定一个样式。</li><li><strong>.marked p{ }</strong>: 为所有 <strong>class=”marked”</strong> 元素内的 <strong>p</strong> 元素指定一个样式。</li><li><strong>p.marked{ }</strong>: 为所有 <strong>class=”marked”</strong> 的 <strong>p</strong> 元素指定一个样式。</li></ul><h3 id="CSS-尺寸-Dimension"><a href="#CSS-尺寸-Dimension" class="headerlink" title="CSS 尺寸 (Dimension)"></a>CSS 尺寸 (Dimension)</h3><p>CSS 尺寸 (Dimension) 属性允许你控制元素的高度和宽度。同样，它允许你增加行间距。</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-height.html">height</a></td><td style="text-align:left">设置元素的高度。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-line-height.html">line-height</a></td><td style="text-align:left">设置行高。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-max-height.html">max-height</a></td><td style="text-align:left">设置元素的最大高度。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-max-width.html">max-width</a></td><td style="text-align:left">设置元素的最大宽度。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-min-height.html">min-height</a></td><td style="text-align:left">设置元素的最小高度。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-min-width.html">min-width</a></td><td style="text-align:left">设置元素的最小宽度。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-width.html">width</a></td><td style="text-align:left">设置元素的宽度。</td></tr></tbody></table></div><h3 id="CSS-Display-显示-与-Visibility（可见性）"><a href="#CSS-Display-显示-与-Visibility（可见性）" class="headerlink" title="CSS Display(显示) 与 Visibility（可见性）"></a>CSS Display(显示) 与 Visibility（可见性）</h3><ul><li>visibility</li><li>display</li></ul><h4 id="隐藏元素-display-none或visibility-hidden"><a href="#隐藏元素-display-none或visibility-hidden" class="headerlink" title="隐藏元素 - display:none或visibility:hidden"></a>隐藏元素 - display:none或visibility:hidden</h4><p>visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。</p><p>display:none可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。</p><h4 id="CSS-Display-块和内联元素"><a href="#CSS-Display-块和内联元素" class="headerlink" title="CSS Display - 块和内联元素"></a>CSS Display - 块和内联元素</h4><p><strong>块元素</strong>是一个元素，占用了全部宽度，在前后都是换行符。</p><p>块元素的例子：</p><ul><li>h1</li><li>p</li><li>div</li></ul><p><strong>内联元素</strong>只需要必要的宽度，不强制换行。</p><p>内联元素的例子：</p><ul><li>span</li><li>a</li></ul><h4 id="如何改变一个元素显示"><a href="#如何改变一个元素显示" class="headerlink" title="如何改变一个元素显示"></a>如何改变一个元素显示</h4><p>可以更改内联元素和块元素的显示，反之亦然</p><p><strong>注意：</strong>变更元素的显示类型看该元素是如何显示，不改变它是什么样的元素。例如：一个内联元素设置为display:block不允许有它内部的嵌套块元素。</p><p>下面的示例把列表项显示为内联元素：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>red</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>inline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>列表项1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>inline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>列表项2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>inline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>列表项3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>inline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>列表项4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul style="color:red">    <li style="display:inline;">列表项1</li>    <li style="display:inline;">列表项2</li>    <li style="display:inline;">列表项3</li>    <li style="display:inline;">列表项4</li></ul><p>下面的示例把span元素作为块元素：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>red</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>span1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>span2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>span3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>span4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div style="color:red">    <span style="display:block;">span1</span>    <span style="display:block;">span2</span>    <span style="display:block;">span3</span>    <span style="display:block;">span4</span></div><h3 id="CSS-Position-定位"><a href="#CSS-Position-定位" class="headerlink" title="CSS Position(定位)"></a>CSS Position(定位)</h3><p>position 属性指定了元素的定位类型。</p><p>position 属性的五个值：</p><ul><li>static</li><li>relative</li><li>fixed</li><li>absolute</li><li>sticky</li></ul><p>设立position属性后，元素可以使用顶部，底部，左侧和右侧属性定位。</p><h4 id="static-默认"><a href="#static-默认" class="headerlink" title="static 默认"></a>static 默认</h4><p>HTML 元素的默认值，即没有定位，遵循正常的文档流对象。</p><p>静态定位的元素不会受到 top, bottom, left, right影响。</p><h4 id="fixed-不随窗口滚动"><a href="#fixed-不随窗口滚动" class="headerlink" title="fixed 不随窗口滚动"></a>fixed 不随窗口滚动</h4><p><strong>不占据空间</strong></p><p>元素的位置相对于浏览器窗口是固定位置。</p><p>即使窗口是滚动的它也不会移动</p><h4 id="relative-相对位置"><a href="#relative-相对位置" class="headerlink" title="relative 相对位置"></a>relative 相对位置</h4><p>相对定位元素的定位是相对其正常位置。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>red</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">position</span><span class="token punctuation">:</span>relative<span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span>-20px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>对于其正常位置向左移动<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>正常位置<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">position</span><span class="token punctuation">:</span>relative<span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>相对于其正常位置向右移动<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><div style="color:red">    <p style="position:relative;left:-20px;">对于其正常位置向左移动</p><p>    </p><p>正常位置</p><p>    </p><p style="position:relative;left:20px;">相对于其正常位置向右移动</p><p></p></div><p>移动相对定位元素，但它原本所占的空间不会改变，可能对覆盖其他元素的显示。</p><h4 id="absolute-绝对位置"><a href="#absolute-绝对位置" class="headerlink" title="absolute 绝对位置"></a>absolute 绝对位置</h4><p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于html。</p><p>absolute 定位<strong>不占据空间</strong>，因此absolute 定位的元素和其他显示重叠。</p><p><strong>clip 属性</strong>可以剪裁绝对定位元素。</p><h4 id="sticky-基于用户的滚动位置来定位"><a href="#sticky-基于用户的滚动位置来定位" class="headerlink" title="sticky  基于用户的滚动位置来定位"></a>sticky  基于用户的滚动位置来定位</h4><p>粘性定位的元素是依赖于用户的滚动，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换。</p><p>它的行为就像 <strong>position:relative;</strong> 而当页面滚动超出目标区域时，它的表现就像 <strong>position:fixed;</strong>，它会固定在目标位置。</p><p>这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p><iframe src="https://www.runoob.com/try/try.php?filename=trycss_position_sticky" width="100%" height="600"></iframe><h4 id="重叠的元素"><a href="#重叠的元素" class="headerlink" title="重叠的元素"></a>重叠的元素</h4><p>元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素</p><p>z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面）</p><p>具有更高堆叠顺序的元素总是在较低的堆叠顺序元素的前面。</p><p>一个元素可以有正数或负数的堆叠顺序：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span><span class="token property">z-index</span><span class="token punctuation">:</span>-1<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>因为图像元素设置了 z-index 属性值为 -1, 所以它会显示在文字之后。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> 如果两个定位元素重叠，没有指定z - index，最后定位在HTML代码中的元素将被显示在最前面</p><h3 id="CSS-Overflow-内容溢出的显示方式"><a href="#CSS-Overflow-内容溢出的显示方式" class="headerlink" title="CSS Overflow (内容溢出的显示方式)"></a>CSS Overflow (内容溢出的显示方式)</h3><p>CSS overflow 属性可以控制内容溢出元素框时在对应的元素区间内添加滚动条。</p><p>默认情况下，overflow 的值为 visible， 意思是内容溢出元素框：</p><p>overflow属性有以下值：</p><div class="table-container"><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">visible</td><td style="text-align:left">默认值。内容不会被修剪，会呈现在元素框之外。</td></tr><tr><td style="text-align:left">hidden</td><td style="text-align:left">内容会被修剪，并且其余内容是不可见的。</td></tr><tr><td style="text-align:left">scroll</td><td style="text-align:left">内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。(两个滚动条都出现)</td></tr><tr><td style="text-align:left">auto</td><td style="text-align:left">如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</td></tr><tr><td style="text-align:left">inherit</td><td style="text-align:left">规定应该从父元素继承 overflow 属性的值。</td></tr></tbody></table></div><p><strong>注意:</strong>overflow 属性只工作于指定高度的块元素上。</p><h3 id="CSS-Float-浮动"><a href="#CSS-Float-浮动" class="headerlink" title="CSS Float(浮动)"></a>CSS Float(浮动)</h3><p>CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。</p><p>Float（浮动），往往是用于图像，但它在布局时一样非常有用。</p><p>元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。</p><p>一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</p><p>浮动元素之后的元素将围绕它。</p><p>浮动元素之前的元素将不会受到影响。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">float</span><span class="token punctuation">:</span>right</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    这是一些文本。这是一些文本。这是一些文本。    ......    这是一些文本。这是一些文本。这是一些文本。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="margin:0px;float:right">    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。</p><h4 id="彼此相邻的浮动元素"><a href="#彼此相邻的浮动元素" class="headerlink" title="彼此相邻的浮动元素"></a>彼此相邻的浮动元素</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">float</span><span class="token punctuation">:</span>left</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    ......    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">float</span><span class="token punctuation">:</span>left</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left"></p><p style="clear:both;"></p><p></p><h4 id="清除浮动-使用-clear"><a href="#清除浮动-使用-clear" class="headerlink" title="清除浮动 - 使用 clear"></a>清除浮动 - 使用 clear</h4><p>元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。</p><div class="table-container"><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">left</td><td style="text-align:left">在左侧不允许浮动元素。</td></tr><tr><td style="text-align:left">right</td><td style="text-align:left">在右侧不允许浮动元素。</td></tr><tr><td style="text-align:left">both</td><td style="text-align:left">在左右两侧均不允许浮动元素。</td></tr></tbody></table></div><h4 id="让段落的第一个字母浮动到左侧"><a href="#让段落的第一个字母浮动到左侧" class="headerlink" title="让段落的第一个字母浮动到左侧"></a>让段落的第一个字母浮动到左侧</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">float</span><span class="token punctuation">:</span>left<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span>1.2em<span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span>400%<span class="token punctuation">;</span>font</span><span class="token attr-value">                 <span class="token property">family</span><span class="token punctuation">:</span>algerian<span class="token punctuation">,</span>courier<span class="token punctuation">;</span><span class="token property">line-height</span><span class="token punctuation">:</span>80%<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        这<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>是一些文本。    这是一些文本。这是一些文本。    ...    这是一些文本。这是一些文本。这是一些文本。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span style="float:left;width:1.2em;font-size:400%;font-family:algerian,courier;line-height:80%;">这</span>是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。</p><h3 id="其他属性-3"><a href="#其他属性-3" class="headerlink" title="其他属性"></a>其他属性</h3><h4 id="cursor-更改光标"><a href="#cursor-更改光标" class="headerlink" title="cursor 更改光标"></a>cursor 更改光标</h4>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学速成课</title>
      <link href="2021/01/22/crash-course-computer-science/"/>
      <url>2021/01/22/crash-course-computer-science/</url>
      
        <content type="html"><![CDATA[<p>视频在<a href="https://www.bilibili.com/video/BV1EW411u7th">这里</a></p><h2 id="1-计算机早期历史"><a href="#1-计算机早期历史" class="headerlink" title="1.计算机早期历史"></a>1.计算机早期历史</h2><p>算盘 → 步进计算器（1694 第一个可以做加减乘除的机器）→ 差分机（1823 失败）分析机（设想）</p><h2 id="2-电子计算机"><a href="#2-电子计算机" class="headerlink" title="2.电子计算机"></a>2.电子计算机</h2><p>机械继电器（bug的起源）→ 真空管（1904 电子管）→ 晶体管（1947 半导体）</p><h2 id="3-布尔逻辑和逻辑门"><a href="#3-布尔逻辑和逻辑门" class="headerlink" title="3.布尔逻辑和逻辑门"></a>3.布尔逻辑和逻辑门</h2><p>二进制<br>布尔代数（not and or）的晶体管实现：非（接地）与（串联）或（并联）<br>XOR（异或）用上面的三种门组成</p><h2 id="4-二进制"><a href="#4-二进制" class="headerlink" title="4.二进制"></a>4.二进制</h2><p>二进制的原理及表示范围<br>字节（8bit）（用颜色举例，8bit有256种，现在用的32bit有4,294,967,295种）；<br>由于内存的增加，内存地址现在应该有64位<br>浮点数的表示，ASCII码，Unicode</p><h2 id="5-算术逻辑单元-ALU"><a href="#5-算术逻辑单元-ALU" class="headerlink" title="5.算术逻辑单元-ALU"></a>5.算术逻辑单元-ALU</h2><p>ALU有2个单元：1个算术单元和一个逻辑单元</p><p>算术单元：</p><ul><li>半加器：<br>sum：当前位的和<br>carry：进位</li></ul><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123023411810.png" alt="半加器"></p><ul><li>全加器：<br>由于有进位的存在，半加器输出了进位，下一位需要接收3个二进制位</li></ul><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123023902758.png" alt="全加器"></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123024147310.png" alt="8位行波进位加法器，现代实际使用超前进位加法器"></p><p>除了加减，类似计算机里也有专门做乘法的算术单元，电路比较复杂</p><p>逻辑单元：<br>执行逻辑操作，例如and，or，not和一些简单的数值测试（如测试输出是否为0）</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123025231997.png" alt="简单的ALU"></p><h2 id="6-寄存器和内存"><a href="#6-寄存器和内存" class="headerlink" title="6.寄存器和内存"></a>6.寄存器和内存</h2><p>用基本逻辑门可以做出存一位信息的叫”AND-OR锁存器”</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123025835832.png" alt="锁存器"></p><p>加亿点细节，用一根线来同时作用设置和复位，再加一根线用来做写入的开关</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123025922499.png" alt="门锁"></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123030158536.png" alt="门锁"></p><p>数个锁存器的组合叫<strong>寄存器</strong>，寄存器有多少位称为<strong>位宽</strong>，早期位宽为8，现在很多都是64<br>用1根线连接寄存器所有的允许输入线，用8条数据线发送数据，就可以给一个寄存器存入数据</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123030623292.png" alt="写寄存器"></p><p>有n个单元时，需要非常多(2n+1根)的线，可以改进成为矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123030954261.png" alt="门锁矩阵"></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123031155319.png" alt="放大"></p><p>对于256位的存储，只需要1条数据线，1条允许写入线，1条允许读取线，和16行16列的线，共35条即可</p><p>用8位可以表示这里的地址，12行8列的地址就是11001000，然后用两个多路复用器将8位的地址装换为行和列</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123031909074.png" alt="256位内存"></p><p>将8个内存连接起来，同一个地址可以存一个8位数字（1个字节），这里总共能存256个字节（byte）</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123031955194.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123032242052.png" alt="抽象成一块整体"></p><p>现在的64位计算机有64位的内存，但不论几位机，一个地址都是对应1Byte<br>内存的一个重要特征是：可以随时访问任何位置，因此叫”随机存取存储器（RAM）“</p><h2 id="7-中央处理器（CPU）"><a href="#7-中央处理器（CPU）" class="headerlink" title="7.中央处理器（CPU）"></a>7.中央处理器（CPU）</h2><p>先构建一个16个地址的内存和4个寄存器</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123033206319.png" alt=""></p><p>在内存里存储的数据前4位为操作码，后4位为地址或者寄存器</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123033336716.png" alt=""></p><p>我们还需要两个寄存器来完成CPU，一个叫指令地址寄存器，一个叫指令寄存器</p><p>取指令阶段：从地址寄存器存放的地址中取出指令 </p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123120300566.png" alt="取指令"></p><p>解码阶段：由控制单元（也是一堆逻辑门）进行解码</p><p>执行阶段：操作码0010：存放到寄存器a；地址码1110的值：00000011</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123121150970.png" alt="执行"></p><p>指令完成后，关闭所有电路，去拿下一条指令，指令地址寄存器+1，执行阶段结束<br>接下来再经过一个执行阶段，把一个值送进寄存器B，指令地址+1<br>接下来到了地址2，指令码是1000，把寄存器B的值加进A里，需要整合ALU来执行</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123123610284.png" alt=""></p><p>运算完之后output输出到control unit的临时存储寄存器，关闭ALU，把值写入寄存器A，A变为了00010001，指令地址再+1。</p><p>最后一个指令将寄存器A中的内存写入内存中</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123125844934.png" alt=""></p><p>cpu工作的节奏由“时钟”来负责管理，CPU”取指令→解码→执行“的速度叫”<strong>时钟速度</strong>“，单位是赫兹<br>cpu可以超频也可以降频</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123230724705.png" alt="CPU"></p><h2 id="8-指令与程序"><a href="#8-指令与程序" class="headerlink" title="8.指令与程序"></a>8.指令与程序</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编</title>
      <link href="2021/01/20/assembly/"/>
      <url>2021/01/20/assembly/</url>
      
        <content type="html"><![CDATA[<p><span style="color: #c31887;">受益匪浅，对cpu指令的执行，显存的运行过程，操作系统对程序的控制和运行，内存定位/寻址，递归/函数栈/子程序等等有了进一步的了解。</span></p><p><span style="color: #c31887;">本书的课后检测点和实验很重要，日后需要用的时候应重点复习</span></p><p><span style="color: #c31887;">重点：第九章，第十章</span></p><p><span style="color: #c31887;">2021/4/19 暂停更新，有时间再看，10-12章均有未完成的部分</span></p><p>使用的教材：汇编语言（第3版）王爽</p><center><span style="color:blue;font-size:15px">2021/1/20</span></center><h2 id="第1章-基础知识"><a href="#第1章-基础知识" class="headerlink" title="第1章 基础知识"></a>第1章 基础知识</h2><p>汇编语言是直接在硬件之上工作的编程语言，需要有一定知识，但是在汇编课程中我们部队硬件系统进行全面和深入的研究，汇编课程的研究重点放在如何利用硬件系统的编程结构和指令集有效灵活地控制系统进行工作。</p><h3 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h3><p>机器语言是机器指令的集合，电子计算机的机器指令是一列二进制数字，每一种微处理器都有自己的机器指令集，也就是机器语言。</p><h3 id="1-2-汇编语言的产生"><a href="#1-2-汇编语言的产生" class="headerlink" title="1.2 汇编语言的产生"></a>1.2 汇编语言的产生</h3><p>汇编语言的主体是汇编指令，汇编指令是机器指令便于记忆的书写格式。</p><h3 id="1-3-汇编语言的组成"><a href="#1-3-汇编语言的组成" class="headerlink" title="1.3 汇编语言的组成"></a>1.3 汇编语言的组成</h3><p>（1）汇编指令：机器码的助记符，有相应的机器码。</p><p>（2）伪指令：没有对应的机器码，由编译器执行，计算机并不执行。</p><p>（3）其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。</p><p>汇编语言的核心是汇编指令，它决定了汇编语言的特性。</p><h3 id="1-4-存储器"><a href="#1-4-存储器" class="headerlink" title="1.4 存储器"></a>1.4 存储器</h3><p>指令和数据在存储器中存放，也就是我们平时所说的内存。</p><h3 id="1-5-指令和数据"><a href="#1-5-指令和数据" class="headerlink" title="1.5 指令和数据"></a>1.5 指令和数据</h3><p>指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二讲制信息。CPU在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。</p><h3 id="1-6-存储单元"><a href="#1-6-存储单元" class="headerlink" title="1.6 存储单元"></a>1.6 存储单元</h3><p>微型机存储器的存储单元可以存储一个Byte，即8个二进制位。</p><h3 id="1-7-CPU对存储器的读写"><a href="#1-7-CPU对存储器的读写" class="headerlink" title="1.7 CPU对存储器的读写"></a>1.7 CPU对存储器的读写</h3><p>CPU要想进行数据的读写，必须和外部器件(标准的说法是芯片)进行下面3类信息的交互。</p><ul><li>存储单元的地址(地址信息)；</li><li>器件的选择，读或写的命令(控制信息)；</li><li>读或写的数据(数据信息)。</li></ul><p>在计算机中专门有连接CPU和其他芯片的导线，通常称为总线。总线从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为3类，<strong>地址总线</strong>、<strong>控制总线</strong>和<strong>数据总线</strong>。</p><p>CPU从3号单元中读取数据的过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210120230352328.png" alt=""></p><p>（1）CPU 通过地址线将地址信息3发出。<br>（2）CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。<br>（3）存储器将3号单元中的数据8通过数据线送入CPU。</p><h3 id="1-8-地址总线"><a href="#1-8-地址总线" class="headerlink" title="1.8 地址总线"></a>1.8 地址总线</h3><p>一个CPU有N跟地址总线，则可以说这个CPU的地址总线的宽度为N。这样的CPU最多可以寻找2的N次方个内存单元。</p><h3 id="1-9-数据总线"><a href="#1-9-数据总线" class="headerlink" title="1.9 数据总线"></a>1.9 数据总线</h3><p>数据总线的宽度决定了CPU和外界的数据传送速度。8 根数据总线一次可传送一个8位二进制数据(即一个字节)。16 根数据总线一次可传送两个字节。</p><h3 id="1-10-控制总线"><a href="#1-10-控制总线" class="headerlink" title="1.10 控制总线"></a>1.10 控制总线</h3><p>CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。<br>前面所讲的内存读或写命令是由几根控制线综合发出的，其中有一根称为 “读信号输出”的控制线负贵由CPU向外传送读信号，CPU向该控制线上输出低电平表示将要读取数据；有一根称为“写信号输出”的控制线则负责传送写信号。</p><h3 id="1-11-内存地址空间（概述）"><a href="#1-11-内存地址空间（概述）" class="headerlink" title="1.11 内存地址空间（概述）"></a>1.11 内存地址空间（概述）</h3><p>举例来讲，一个CPU的地址总线宽度为10，那么可以寻址1024个内存单元，这1024 个可寻到的内存单元就构成这个CPU的内存地址空间。下面进行深入讨论。首先需要介绍两部分基本知识，主板和接口卡。</p><h3 id="1-12-主板"><a href="#1-12-主板" class="headerlink" title="1.12 主板"></a>1.12 主板</h3><p>在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件，这些器件通过总线(地址总线、数据总线、控制总线)相连。这些器件有<strong>CPU</strong>、<strong>存储器</strong>、<strong>外围芯片组</strong>（北桥负责高速信号，比如CPU与内存、显卡等设备的通信。南桥负责低速信号，比如PCI/PCIe、SATA、USB等外围设备通信。再后来北桥芯片逐渐被集成到了CPU里面。<strong>芯片组的主要差别就是CPU对外围设备和拓展支持情况的差别</strong>）、扩展插槽等。扩展插槽上一般插有RAM内存条和各类接口卡。</p><h3 id="1-13-接口卡"><a href="#1-13-接口卡" class="headerlink" title="1.13 接口卡"></a>1.13 接口卡</h3><p>CPU对外部设备都不能直接控制，直接控制这些设备进行工作的是插在扩展插槽上的接口卡。<br>简单地讲，就是CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作。</p><h3 id="1-14-各类存储器芯片"><a href="#1-14-各类存储器芯片" class="headerlink" title="1.14 各类存储器芯片"></a>1.14 各类存储器芯片</h3><p>一台PC机中，装有多个存储器芯片，这些存储器芯片从物理连接上看是独立的、不同的器件。从读写属性上看分为两类：<strong>随机存储器</strong>(RAM)和<strong>只读存储器</strong>(ROM)。 随机存储器可读可写，但必须带电存储，关机后存储的内容丢失；只读存储器只能读取不能写入，关机后其中的内容不丢失。这些存储器从功能和连接上又可分为以下几类。</p><ul><li><p>随机存储器<br>用于存放供CPU使用的绝大部分程序和数据。</p></li><li><p>装有BIOS(Basic Input/Output System,基本输入/输出系统)的ROM<br>BIOS是由主板和各类接口卡(如显卡、网卡等)厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM。例如，主板上的ROM中存储着主板的BIOS(通常称为系统BIOS)；显卡上的ROM中存储着显卡的BIOS；如果网卡上装有ROM，那其中就可以存储网卡的BIOS。</p></li><li>接口卡上的RAM<br>某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有RAM。最典型的是显示卡上的RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210120235427070.png" alt=""></p><h3 id="1-15-内存地址空间"><a href="#1-15-内存地址空间" class="headerlink" title="1.15 内存地址空间"></a>1.15 内存地址空间</h3><p>上述的那些存储器，在物理上是独立的器件，但是在以下两点上相同。</p><ul><li>都和CPU的总线相连。</li><li>CPU对它们进行读或写的时候都通过控制线发出内存读写命令。</li></ul><p>这也就是说，CPU 在操控它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。在汇编这门课中，我们所面对的是内存地址空间。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210120235904993.png" alt=""></p><p>在图1.8中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</p><p>假设，图1.8中的内存地址空间的地址段分配如下。<br>地址0~7FFFH的32KB空间为主随机存储器的地址空间:<br>地址8000H~9FFFH的8KB空间为显存地址空间:<br>地址A000H~FFFFH的24KB空间为各个ROM的地址空间。</p><p>这样，CPU向内存地址为1000H的内存单元中写入数据，这个数据就被写入主随机存储器中；CPU向内存地址为8000H的内存单元中写入数据，这个数据就被写入显存中，然后会被显卡输出到显示器上；CPU向内存地址为C000H的内存单元中写入数据的操作是没有结果的，C000H 单元中的内容不会被改变，C000H 单元实际上就是ROM存储器中的一个单元。</p><p>内存地址空间的大小受CPU地址总线宽度的限制。80386CPU 的地址总线宽度为32，其内存地址空间最大为4GB。</p><p>我们在基于一个计算机硬件系统编程的时候，必须知道这个系统中的内存地址空间分配情况。不同的计算机系统的内存地址的分配情况是不同的。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/20200430191506580.png" alt="8086PC机内存地址空间"></p><center><span style="color:blue;font-size:15px">2021/1/23</span></center><h2 id="第2章-寄存器"><a href="#第2章-寄存器" class="headerlink" title="第2章 寄存器"></a>第2章 寄存器</h2><p>一个典型的CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。<br>对一个汇编程序员来说，CPU中的主要部件是寄存器。</p><h3 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h3><p>8086CPU的所以寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为<strong>通用寄存器</strong>。<br>为了向上一代的8位CPU寄存器兼容，这4个通用寄存器都可分为两个独立使用的8位寄存器来用。<br>例如：AX可分为AH（高8位）和AL（低8位）</p><h3 id="2-2-字在寄存器中的存储"><a href="#2-2-字在寄存器中的存储" class="headerlink" title="2.2 字在寄存器中的存储"></a>2.2 字在寄存器中的存储</h3><p>出于对兼容性的考虑，8086CPU可以一次性处理以下两种尺寸的数据</p><ul><li>字节：记为byte，由8个bit组成</li><li>字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节</li></ul><p>出于对数据直观分析的需要，我们多用十六进制来表示一个数据</p><h3 id="2-3-几条汇编指令"><a href="#2-3-几条汇编指令" class="headerlink" title="2.3 几条汇编指令"></a>2.3 几条汇编指令</h3><div class="table-container"><table><thead><tr><th style="text-align:center">程序段中的指令</th><th style="text-align:center">指令执行后AX中的数据</th><th style="text-align:center">指令执行后BX中的数据</th></tr></thead><tbody><tr><td style="text-align:center">mov ax,4E20H</td><td style="text-align:center">4E20H</td><td style="text-align:center">0000H</td></tr><tr><td style="text-align:center">add ax,106H</td><td style="text-align:center">6226H</td><td style="text-align:center">0000H</td></tr><tr><td style="text-align:center">mov bx,2000H</td><td style="text-align:center">6226H</td><td style="text-align:center">2000H</td></tr><tr><td style="text-align:center">add ax,bx</td><td style="text-align:center">8226H</td><td style="text-align:center">2000H</td></tr><tr><td style="text-align:center">mov bx,ax</td><td style="text-align:center">8226H</td><td style="text-align:center">8226H</td></tr><tr><td style="text-align:center">add ax,bx</td><td style="text-align:center"><strong>044CH</strong></td><td style="text-align:center">8226H</td></tr></tbody></table></div><p>最后一条指令所得的值应该为1044CH，但是ax寄存器放不下，最高位的1不能保存</p><div class="table-container"><table><thead><tr><th style="text-align:center">程序段中的指令</th><th style="text-align:center">指令执行后AX中的数据</th><th style="text-align:center">指令执行后BX中的数据</th></tr></thead><tbody><tr><td style="text-align:center">mov ax,001AH</td><td style="text-align:center">001AH</td><td style="text-align:center">0000H</td></tr><tr><td style="text-align:center">mov bx,0026H</td><td style="text-align:center">001AH</td><td style="text-align:center">0026H</td></tr><tr><td style="text-align:center">add al,bl</td><td style="text-align:center">0040H</td><td style="text-align:center">0026H</td></tr><tr><td style="text-align:center">add ah,bl</td><td style="text-align:center">2640H</td><td style="text-align:center">0026H</td></tr><tr><td style="text-align:center">add bh,al</td><td style="text-align:center">2640H</td><td style="text-align:center">4026H</td></tr><tr><td style="text-align:center">mov ah,0</td><td style="text-align:center">0040H</td><td style="text-align:center">4026H</td></tr><tr><td style="text-align:center">add al,85H</td><td style="text-align:center">00C5H</td><td style="text-align:center">4026H</td></tr><tr><td style="text-align:center">add al,93H</td><td style="text-align:center"><strong>0058H</strong></td><td style="text-align:center">4026H</td></tr></tbody></table></div><p>最后的ax应该为158H，但此时的al是作为一个独立的8位寄存器来使用的，和ah没有关系，所以最高位丢失</p><p>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。</p><h3 id="2-4-物理地址"><a href="#2-4-物理地址" class="headerlink" title="2.4 物理地址"></a>2.4 物理地址</h3><p>每个内存单元在存储空间内都有唯一的地址，称为物理地址。<br>在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU可以有不同的形成物理地址的方式。</p><h3 id="2-5-16位结构的CPU"><a href="#2-5-16位结构的CPU" class="headerlink" title="2.5 16位结构的CPU"></a>2.5 16位结构的CPU</h3><p>什么是16位结构的CPU呢？</p><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器之间的通路为16位</li></ul><p>内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，对于16位CPU，能一次性处理，传输、暂时存储16位的地址。</p><center><span style="color:blue;font-size:15px">2021/2/23</span></center><h3 id="2-6-8086CPU给出物理地址的方法"><a href="#2-6-8086CPU给出物理地址的方法" class="headerlink" title="2.6 8086CPU给出物理地址的方法"></a>2.6 8086CPU给出物理地址的方法</h3><p><strong>8086CPU有20位地址总线，可以传送20位地址</strong>，达到IMB寻址能力。<strong>8086CPU是16位结构</strong>，在内部一次性处理、 传输、暂时存储的地址为16 位。从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，<strong>表现出的寻址能力只有64KB。</strong><br>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址，</p><p>当8086CPU要读写内存时:<br>(1) CPU中的相关部件提供两个16位的地址，一个称为段地址，另个称为偏移地址:<br>(2) 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件;<br>(3) 地址加法器将两个16位地址合成为一个20位的物理地址;<br>(4) 地址加法器通过内部总线将20位物理地址送入输入输出控制电路:<br>(5) 输入输出控制电路将20位物理地址送上地址总线:<br>(6) 20位物理地址被地址总线传送到存储器。<br><strong>地址加法器采用物理地址=段地址x16+偏移地址的方法用段地址和偏移地址合成物理（段地址左移四位）</strong><br>地址。例如，8086CPU 要访问地址为123C8H的内存单元，此时，地址加法器的工作过程如图2.7所示(图中数据皆为十六进制表示)。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210223143146227.png" alt=""></p><h3 id="2-7-“段地址-16-偏移地址-物理地址”的本质含义"><a href="#2-7-“段地址-16-偏移地址-物理地址”的本质含义" class="headerlink" title="2.7 “段地址*16+偏移地址=物理地址”的本质含义"></a>2.7 “段地址*16+偏移地址=物理地址”的本质含义</h3><p>“段地址x16+偏移地址=物理地址”的本质含义是: CPU在访问内存时，用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</p><p>更一般地说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。8086CPU 中，段地址x16可看作是基础地址。</p><h3 id="2-8-段的概念（内存地址小结）"><a href="#2-8-段的概念（内存地址小结）" class="headerlink" title="2.8 段的概念（内存地址小结）"></a>2.8 段的概念（内存地址小结）</h3><p>（1）观察下面的地址</p><div class="table-container"><table><thead><tr><th style="text-align:center">物理地址</th><th style="text-align:center">段地址</th><th style="text-align:center">偏移地址</th></tr></thead><tbody><tr><td style="text-align:center">21F60H</td><td style="text-align:center">2000H</td><td style="text-align:center">1F60H</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">2100H</td><td style="text-align:center">0F60H</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">21F0H</td><td style="text-align:center">0060H</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">21F6H</td><td style="text-align:center">0000H</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1F00H</td><td style="text-align:center">2F60H</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table></div><p><strong>结论：</strong>CPU可以用不同的段地址和偏移地址形成同一个物理地址</p><p>（2）如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可定位多少个内存单元？</p><p><strong>结论：</strong>偏移地址16位，变化范围为0~FFFFH,仅用偏移地址来寻址最多可寻64KB个内存单元</p><p>在8086PC机中，存储单元的地址用两个元素来描述，即段地址和偏移地址。<br>“数据在 21F60H内存单元中。”这句话对于 8086PC机一般不这样讲， 取而代之的是两种类似的说法<br>①数据存在内存2000:1F60单元中；<br>②数据存在内存的2000H段中的1F60H单元中。<br>这两种描述都表示“数据在内存21F60H单元中”。</p><p>可以根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段。</p><h3 id="2-9-段寄存器（Segment-Register）"><a href="#2-9-段寄存器（Segment-Register）" class="headerlink" title="2.9 段寄存器（Segment Register）"></a>2.9 段寄存器（Segment Register）</h3><p>段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器：CS（Code Segment）、DS（Data Segment）、SS（Stack Segment）、ES（Extra Segment）、当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。</p><p>本章中只看一下CS</p><center><span style="color:blue;font-size:15px">2021/3/2</span></center><h3 id="2-10-CS和IP（指令的执行过程）"><a href="#2-10-CS和IP（指令的执行过程）" class="headerlink" title="2.10 CS和IP（指令的执行过程）"></a>2.10 CS和IP（指令的执行过程）</h3><p>CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。<strong>CS为代码段寄存器</strong>（Code Segment），<strong>IP 为指令指针寄存器</strong>（Instruction Pointer），从名称上我们可以看出它们和指令的关系。</p><p>在8086PC机中，任意时刻，设CS中的内容为M，IP中的内容为N, 8086CPU 将从内存Mx16+N单元开始，读取一条指令并执行。<br>也可以这样表述: 8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/RV8OC4_%7DN08H4BD4QD%604K%5DH.png" alt=""></p><p>读取一条指令后，IP中的值自动增加，以使CPU可以读取下一条指令，当前读入的指令B82301长度为3个字节，所以IP中的值增加3，后面的指令也依次如上运行</p><p><strong>8086CPU的工作过程可以简要描述如下。</strong><br>(1) 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器:<br>(2) IP=IP+所读取指令的长度， 从而指向下一条指令:<br>(3) 执行指令。转到步骤(1)， 重复这个过程。</p><p>在8086CPU加电启动或复位后，CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。</p><p><strong>在内存中，指令和信息没有任何区别，CPU根据什么将内存中的信息看作指令？</strong><br>CPU将CS:IP指向的内存单元中的内容看作指令。如果说，内存中的一段信息曾被CPU执行过的话，那么，它所在的内存单元必然被CS:IP指向过。</p><h3 id="2-11-修改CS、IP的指令（jmp）"><a href="#2-11-修改CS、IP的指令（jmp）" class="headerlink" title="2.11 修改CS、IP的指令（jmp）"></a>2.11 修改CS、IP的指令（jmp）</h3><p>使用mov（传送指令）可以修改大部分寄存器的值，如AX，BX等，但不能设置CS，IP的值。<br>能够改变CS，IP的内容的指令被统称为转移指令，现在介绍一个最简单的：<strong>jmp指令</strong><br>若想同时修改CS、IP的内容，可用形似”<strong>jmp 段地址:偏移地址</strong>“的指令完成<br>若想仅修改IP的内容，可直接用”<strong>jmp 某一合法寄存器</strong>“的指令完成</p><h3 id="2-12-代码段"><a href="#2-12-代码段" class="headerlink" title="2.12 代码段"></a>2.12 代码段</h3><p>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段，如果用于存代码，就可以认为是一个代码段。</p><p>将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认可被CS:IP指向的内存单元中的内容为指令。</p><center><span style="color:blue;font-size:15px">2021/3/3</span></center><h3 id="实验1-查看CPU和内存，用机器指令和汇编指令编程"><a href="#实验1-查看CPU和内存，用机器指令和汇编指令编程" class="headerlink" title="实验1 查看CPU和内存，用机器指令和汇编指令编程"></a>实验1 查看CPU和内存，用机器指令和汇编指令编程</h3><h4 id="1-预备知识：Debug的使用"><a href="#1-预备知识：Debug的使用" class="headerlink" title="1.预备知识：Debug的使用"></a>1.预备知识：Debug的使用</h4><p>(1)什么是Debug?<br>Debug是DOS、Windows 都提供的实模式(8086方式)程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。</p><p><strong>实模式：</strong>16位模式，不同的程序可使用不同的分段策略，两个程序的不同逻辑地址，可能对应相同的物理地址，程序A可能修改程序B已经保存在内存里的值（游戏修改器）。</p><p><strong>保护模式：</strong>32位模式，程序不能更改其他程序的内存。</p><p>(2)常用到的Debug功能。</p><ul><li>用Debug的R命令查看、改变CPU寄存器的内容； </li><li>用Debug的D命令查看内存中的内容；</li><li>用Debug的E命令改写内存中的内容；</li><li>用Debug的U命令将内存中的机器指令翻译成汇编指令；</li><li>用Debug的T命令执行一条机器指令；</li><li>用Debug的A命令以汇编指令的格式在内存中写入一条机器指令。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303182904129.png" alt="用R命令查看、改变CPU寄存器的内容"></p><p>也可以用R命令来改变寄存器中的内容，如”r ax” “r ip”等</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303184200633.png" alt="用D命令查看内存中的内容"></p><p>使用D命令，Debug将输出3部分内容</p><p>（1）中间是从指定地址开始的128（16*8）个内存单元的内容，用十六进制的格式输出。</p><p>（2）左边是每行的起始地址 </p><p>（3）右边是每个内存单元中的数据对应的可显示的ASCII码字符</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303185328227.png" alt="用E命令改写内存中的内容"></p><p>也可直接写e 1000:0后逐个修改</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303185916604.png" alt="用E命令向内存中写入字符和字符串"></p><p>如何向内存中写入机器码呢？我们知道，机器码也是数据，也可以用E命令将机器码写入内存。</p><div class="table-container"><table><thead><tr><th style="text-align:center">机器码</th><th style="text-align:center">对应的汇编指令</th></tr></thead><tbody><tr><td style="text-align:center">b80100</td><td style="text-align:center">mov ax,0001</td></tr><tr><td style="text-align:center">b90200</td><td style="text-align:center">mov cx,0002</td></tr><tr><td style="text-align:center">01c8</td><td style="text-align:center">add ax,cx</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303190646149.png" alt="写入机器码并用U命令查看"></p><p>U命令可以将内存单元中的内容翻译为汇编指令，并显示出来。</p><p>由此，我们可以再一次看到内存中的数据和代码没有任何区别，关键在于如何解释。</p><p>如何执行我们写入的机器指令呢？使用Debug的T命令可以执行一条或多条指令。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303191609348.png" alt="使用T命令执行CS:IP指向的指令"></p><p>用E命令写入机器指令很不方便，为此，Debug提供了A命令。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303215741998.png" alt="用A命令写入指令"></p><h4 id="2-实验任务"><a href="#2-实验任务" class="headerlink" title="2.实验任务"></a>2.实验任务</h4><p>（1）使用Debug，将下面的程序段写入内存，逐条执行，观察每条指令执行后CPU中相关寄存器中内容的变化。（ez）</p><p>（2）将下面3条指令写入从2000:0开始的内存单元中，利用这3条指令计算2的8次方。（ez）</p><blockquote><p>mov ax,1</p><p>add ax,ax</p><p>jmp 2000:0003</p></blockquote><p>(3)主板上的ROM中写有一个生产日期，在内存FFF00H~FFFFFH的某几个单元中，请找到这个生产日期并试图改变它</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303221907140.png" alt=""></p><p>rom修改无效 这个日期是由于win10不自带debug，所以使用DosBox来虚拟Dos环境，这个日期也是虚拟出来的，由于不是直接操作实模式，避免了一些误操作。</p><p>(4)向内存从B8100H开始的单元中填写数据</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303223129794.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303223121403.png" alt="执行后在屏幕右上方出现这些字符"></p><p>但是用d查看，内存中存储的数据会变化，因为显存中的内容和屏幕是一一对应的。在</p><p>输入的过程中屏幕上的内容变化了，显存中的内容也会跟着变。</p><h2 id="第3章-寄存器（内存访问）"><a href="#第3章-寄存器（内存访问）" class="headerlink" title="第3章 寄存器（内存访问）"></a>第3章 寄存器（内存访问）</h2><p>上一章中，我们主要从CPU如何执行指令的角度讲解了8086CPU的逻辑结构，形成物理地址的方法，相关的寄存器以及一些指令。<br>这一章中，我们从访问内存的角度继续学习几个寄存器。</p><h3 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h3><p>CPU中，用16位寄存器来存储一个字。高8位高字节，低8位低字节。在内存中存储时，由于内存是字节单元，则一个字要用两个地址连续的内存单元来存放。<br>比如用0,1两个内存单元来存放数据20000（4E20H)，则0号单元存储20H，1号单元存储4EH。</p><p>我们提出<strong>字单元</strong>的概念：字单元，即存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p><h3 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2  DS和[address]"></a>3.2  DS和[address]</h3><p>CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。</p><blockquote><p>mov bx,1000H</p><p>mov ds,bx</p><p>mov al,[0]</p></blockquote><p>上面的3条指令将10000H(1000:0)中的数据读到al中。<br>mov除了前面用过的将数据送入寄存器，讲寄存器的内容送入另一个寄存器，还可以<strong>将一个内存单元的内容送入一个寄存器</strong>中。<br>[···]表示一个内存单元。[···]中的0表示内存单元的偏移地址，执行指令时，8086CPU自动取ds中的数据为内存单元的段地址。</p><p>由于8086CPU不支持将数据直接送入段寄存器的操作，所以只好用一个寄存器进行中转。</p><h3 id="3-3-字的传送"><a href="#3-3-字的传送" class="headerlink" title="3.3 字的传送"></a>3.3 字的传送</h3><p>因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是说可以一次性传送一个字。只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了。</p><h3 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a>3.4 mov、add、sub指令</h3><p>mov指令允许的形式：</p><ul><li>mov 寄存器,数据</li><li>mov 寄存器,寄存器</li><li>mov 寄存器,内存单元</li><li>mov 内存单元,寄存器</li><li>mov 段寄存器,寄存器</li><li>mov 寄存器,段寄存器</li><li>mov 内存单元,段寄存器</li><li>mov 段寄存器,内存单元</li></ul><p>数据其实也可以mov给内存单元，但是要加位宽修饰符</p><p>add和sub一样，都有两个操作对象，也可以有几种形式</p><ul><li>add 寄存器,数据</li><li>add 寄存器,寄存器</li><li>add 寄存器,内存单元</li><li>add 内存单元,寄存器</li></ul><center><span style="color:blue;font-size:15px">2021/4/10</span></center><h3 id="3-5-数据段"><a href="#3-5-数据段" class="headerlink" title="3.5 数据段"></a>3.5 数据段</h3><p>前面讲过，对于8086pc机，在编程时，可以根据需要，将一组内存单元定义为一个段。所以我们也可以将一组长度小于64kb，地址连续，起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。</p><p>将一段内存当作数据段，是我们在编程时的一种安排，可以在具体操作时，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。</p><blockquote><p>数据和程序没有区别，段地址若是ds段，可看做是数据，段地址若是cs段，可看做是程序指令</p></blockquote><h3 id="3-6-栈"><a href="#3-6-栈" class="headerlink" title="3.6 栈"></a>3.6 栈</h3><p>LIFO(Last In First Out)</p><h3 id="3-7-CPU提供的栈机制"><a href="#3-7-CPU提供的栈机制" class="headerlink" title="3.7 CPU提供的栈机制"></a>3.7 CPU提供的栈机制</h3><p>现今的CPU中都有栈的设计，8086CPU提供相关的指令来以栈的方式访问内存空间。这意味着，可以将一段内存当作栈来使用</p><p>下面举例说明，我们可以将10000H~1000FH这段内存当作栈来使用。</p><p><img src="/images/assembly/image-20210410145339891.png" alt="8086CPU的栈操作"></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ax,0123Hpush axmov bx,2266Hpush bxmov cx,1122Hpush cxpop axpop bxpop cx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：字型数据用两个单元存放，高地址单元存放高8位，低地址单元存放低8位。</p><p>在8086CPU中，有两个寄存器，<strong>段寄存器</strong>SS (Stack Segment) 和<strong>寄存器</strong>SP (stack pointer) ，栈顶的段地址存放在SS中，偏移地址存放在SP中。任意时刻，SS:SP指向栈顶元素，push和pop指令执行时，CPU从SS和SP中得到栈顶的地址。</p><blockquote><p>如上图，初试状态栈为空时，SS=1000H，SP=0010H</p></blockquote><p>push ax 的执行，由以下两步完成。</p><ol><li>SP=SP-2，SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li><li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li></ol><p>pop ax 的执行过程和 push ax 刚好相反，由以下两步完成。</p><ol><li>将SS:SP 指向的内存单元处的数据送入ax中</li><li>SP=SP+2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新栈顶</li></ol><h3 id="3-8-栈顶超界的问题"><a href="#3-8-栈顶超界的问题" class="headerlink" title="3.8 栈顶超界的问题"></a>3.8 栈顶超界的问题</h3><p>栈顶超界是危险的，我们希望CPU可以帮我们解决这个问题，但实际的情况是，8086CPU中并没有这样的寄存器，我们在编程的时候要自己操心栈顶超界的问题。</p><h3 id="3-9-push、pop指令"><a href="#3-9-push、pop指令" class="headerlink" title="3.9 push、pop指令"></a>3.9 push、pop指令</h3><p>push和pop指令的格式可以是如下形式：</p><ul><li>push 寄存器</li><li>push 段寄存器</li><li>push 内存单元</li></ul><p>push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov不同的是，push和pop指令访问的内存单元的地址是由SS:SP 指出的。同时，push 和 pop 指令还要改变sp中的内容。</p><h3 id="3-10-栈段"><a href="#3-10-栈段" class="headerlink" title="3.10 栈段"></a>3.10 栈段</h3><p>我们也可以将长度小于64kb的一组地址连续，起始地址为16的倍数的内存单元当作栈空间来用，从而定义了一个栈段。（段地址放在ss中）</p><blockquote><p>一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于CPU中寄存器的设置，即CS , IP , SS , SP , DS的指向。</p></blockquote><h3 id="实验2-用机器指令和汇编指令编程"><a href="#实验2-用机器指令和汇编指令编程" class="headerlink" title="实验2 用机器指令和汇编指令编程"></a>实验2 用机器指令和汇编指令编程</h3><h4 id="1-预备知识：Debug的使用-1"><a href="#1-预备知识：Debug的使用-1" class="headerlink" title="1.预备知识：Debug的使用"></a>1.预备知识：Debug的使用</h4><p>(1)关于D命令</p><p>D命令是查看内存单元的命令，CPU在访问内存单元的时候从段寄存器中得到内存单元的段地址，所以，Debug在其处理D命令的程序段中，必须有将段地址送入寄存器的代码。</p><p>D命令也提供了一种符合CPU机理的格式：“d 段寄存器:偏移地址”，以下是几个例子。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">①-r ds:1000-d ds:0;查看从1000:0开始的内存②-r ds:1000-d ds:10 18;查看1000:10~1000:18中的内容③-d cs:0;查看当前代码段中的指令代码④-d ss:0;查看当前栈段中的内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2)在E、A、U命令中使用寄存器</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">①-r ds:1000-e ds:0 11 22 33 44 55 66;查看从1000:0开始的内存②-u cs:0;以汇编指令的形式，显示当然代码段中的代码③ -r cs:0:1000-a ds:0;以汇编指令的形式，向从1000:0开始的内存单元中写入指令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(3)下一条指令执行了吗？</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ax,2000mov ss,axmov sp,10mov ax,3123...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在用T执行单步操作 mov ss,ax 后，下一条指令直接变成了mov ax,3123。<br>在用T命令执行 mov ss,ax的时候，它的下一条指令mov sp,10也紧接着执行了。<br>不单是mov ss,ax，对于如 mov ss,bx，mov ss,[0]，pop ss等指令都会发生上面的情况，这些指令有哪些共性呢，它们都是<strong>修改栈段寄存器SS的指令</strong>。</p><p>为什么会这样呢，这涉及我们在以后的课程中要深入研究的内容：<strong>中断机制</strong>。</p><h4 id="2-实验任务-1"><a href="#2-实验任务-1" class="headerlink" title="2.实验任务"></a>2.实验任务</h4><p>(1) 使用Debug，将下面的程序段写入内存，逐条执行，根据指令执行后的实际运行情况填空。（ez)</p><p>(2) 仔细观察图3.19中的实验内容，然后分析：为什么2000:0~2000:f中的内容会发生改变。（书上）</p><center><span style="color:blue;font-size:15px">2021/4/11</span></center><h2 id="第4章-第一个程序"><a href="#第4章-第一个程序" class="headerlink" title="第4章 第一个程序"></a>第4章 第一个程序</h2><p>现在我们将开始编写完整的汇编语言程序，用编译和连接程序将它们编译连接成为可执行文件</p><h3 id="4-1-一个源程序从写出到执行的过程"><a href="#4-1-一个源程序从写出到执行的过程" class="headerlink" title="4.1 一个源程序从写出到执行的过程"></a>4.1 一个源程序从写出到执行的过程</h3><ul><li>编写源程序</li><li>对源程序进行编译连接（编译生成目标文件，连接生成可执行文件）</li><li>执行可执行文件中的程序</li></ul><h3 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codesgcodesg segmentmov ax,0123Hmov bx,0456Hadd ax,bxadd ax,axmov ax,4c00Hint 21Hcodesg endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-伪指令"><a href="#1-伪指令" class="headerlink" title="1. 伪指令"></a>1. 伪指令</h4><p>在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令有对应的机器码，可以被编译为机器指令，最终为CPU所执行。而伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。</p><p>上面的程序出现了3种伪指令</p><p>(1)    XXX segment<br>                    …<br>        XXX ends<br>segment 和 ends 是一对成对使用的伪指令，是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。功能是定义一个段，分别说明段的开始和结束。<br>一个汇编程序是由多个段组成的，这些段被用来存放代码，数据或当作栈空间来使用。<br>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。</p><p>(2)    end<br>end是一个汇编程序的结束标记，汇编器在编译汇编程序的过程中，如果碰到了指令end，就结束对源程序的编译。<br><strong>注意</strong>：不要把end和ends搞混</p><p>(3)    assume<br>这条伪指令可以把某一段寄存器和程序中的某一个用segment…ends定义的段相关联。</p><h4 id="2-源程序中的”程序”"><a href="#2-源程序中的”程序”" class="headerlink" title="2. 源程序中的”程序”"></a>2. 源程序中的”程序”</h4><p>程序最先以汇编指令的形式存放在源程序中，经编译，连接后转变为机器码，存储在可执行文件中。（伪指令是由编译器来处理的）</p><h4 id="3-标号"><a href="#3-标号" class="headerlink" title="3. 标号"></a>3. 标号</h4><p>如“codesg”。一个标号指代了一个地址，作为一个段的名称，这个段的名称最终将被编译，连接程序处理为一个段的段地址。</p><h4 id="4-程序的结构"><a href="#4-程序的结构" class="headerlink" title="4. 程序的结构"></a>4. 程序的结构</h4><p>如上程序</p><h4 id="5-程序返回"><a href="#5-程序返回" class="headerlink" title="5. 程序返回"></a>5. 程序返回</h4><p>若想要一个程序p2运行，则必须有一个正在运行的程序p1，将p2从可执行文件中加载入内存后，将CPU的控制权交给p2，p2才能运行。p2开始运行后，p1暂停运行。<br>当p2运行完毕后，将CPU的控制权交还给使它得以运行的程序p1，此后，p1继续运行。<br>我们把交还CPU的控制权的过程称为<strong>程序返回</strong></p><p>​    mov ax,4c00H<br>​    int 21H</p><p>这两条指令所实现的功能就是程序返回。</p><h4 id="6-语法错误和逻辑错误"><a href="#6-语法错误和逻辑错误" class="headerlink" title="6. 语法错误和逻辑错误"></a>6. 语法错误和逻辑错误</h4><p>语法错误可以在程序编译时被编译器发现。</p><h3 id="4-3-编译源程序"><a href="#4-3-编译源程序" class="headerlink" title="4.3 编译源程序"></a>4.3 编译源程序</h3><p>可以用任意的文本编辑器来编辑源程序，只要最终将其存储为纯文本文件即可。(扩展名一般写.asm)</p><h3 id="4-4-编译"><a href="#4-4-编译" class="headerlink" title="4.4 编译"></a>4.4 编译</h3><p><img src="/images/assembly/image-20210411105338039.png" alt=""></p><h3 id="4-5-连接"><a href="#4-5-连接" class="headerlink" title="4.5 连接"></a>4.5 连接</h3><p><img src="/images/assembly/image-20210411105620229.png" alt=""></p><p>连接的作用有以下几个</p><ul><li>当源程序很大时，可以将它分为多个源程序文件来编译，成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件。</li><li>程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件。</li><li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。</li></ul><h3 id="4-6-以简化的方式进行编译和连接"><a href="#4-6-以简化的方式进行编译和连接" class="headerlink" title="4.6 以简化的方式进行编译和连接"></a>4.6 以简化的方式进行编译和连接</h3><h3 id="4-7-1-exe的运行"><a href="#4-7-1-exe的运行" class="headerlink" title="4.7 1.exe的运行"></a>4.7 1.exe的运行</h3><h3 id="4-8-谁将可执行文件中的程序装载进入内存并使它运行？"><a href="#4-8-谁将可执行文件中的程序装载进入内存并使它运行？" class="headerlink" title="4.8 谁将可执行文件中的程序装载进入内存并使它运行？"></a>4.8 谁将可执行文件中的程序装载进入内存并使它运行？</h3><h4 id="操作系统的外壳（shell）"><a href="#操作系统的外壳（shell）" class="headerlink" title="操作系统的外壳（shell）"></a>操作系统的外壳（shell）</h4><p>任何通用的操作系统，都要提供一个称为shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统进行工作。</p><p>DOS中有一个程序<strong>command.com</strong>，这个程序在DOS中称为命令解释器，也就是<strong>DOS系统的shell</strong>。</p><p>DOS启动时，先完成其他重要的初始化工作，然后运行command.com，command.com运行后，执行完其他的相关任务后，在屏幕上显示出由当前盘符和当前路径组成的提示符，等待用户的输入。</p><p>用户可以输入所要执行的命令，如cd、dir等，这些命令由command执行，完成这些命令后，再次等待用户的输入。</p><p><strong>如果用户要执行一个程序</strong>，则输入可执行文件的名称，command会找到文件，将这个可执行文件中的程序加载入内存，设置CS：IP指向程序的入口，此后，command暂停运行，CPU运行程序。程序运行结束后，返回到command中，再次等待用户输入。</p><p>刚才的汇编程序从写出到执行的过程：</p><div class="table-container"><table><thead><tr><th>编程</th><th>1.asm</th><th>编译</th><th>1.obj</th><th>连接</th><th>1.exe</th><th>加载</th><th>内存中的程序</th><th>运行</th></tr></thead><tbody><tr><td>（Edit）</td><td></td><td>（masm）</td><td></td><td>（link）</td><td></td><td>（command）</td><td></td><td>（CPU）</td></tr></tbody></table></div><h3 id="4-9-程序执行过程的跟踪"><a href="#4-9-程序执行过程的跟踪" class="headerlink" title="4.9 程序执行过程的跟踪"></a>4.9 程序执行过程的跟踪</h3><p>使用command不能逐条指令地看到程序的执行过程，因为command的程序加载，设置CS：IP指向程序的入口的操作是连续完成的，当CS：IP一指向程序的入口，command就放弃了CPU的控制权。</p><p>为了观察程序的运行过程，可以使用Debug，Debug可以将程序加载入内存，设置CS：IP指向程序的入口，但Debug并不放弃对CPU的控制，这样，我们就可以使用Debug的相关命令来单步执行程序，查看每一条指令的执行结果。</p><p><img src="/images/assembly/image-20210411113906738.png" alt=""></p><p>这里，需要讲解一下DOS系统中.EXE文件中的程序的加载过程。</p><p><img src="/images/assembly/image-20210411165545638.png" alt=""></p><p>（1）程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为ds：0；</p><p>（2）这个内存区的前256个字节中存放的是PSP，DOS用来和程序进行通信。从256字节处向后的空间存放的是程序。</p><h3 id="实验3-编程、编译、连接、跟踪"><a href="#实验3-编程、编译、连接、跟踪" class="headerlink" title="实验3 编程、编译、连接、跟踪"></a>实验3 编程、编译、连接、跟踪</h3><p>书上</p><center><span style="color:blue;font-size:15px">2021/4/12</span></center><h2 id="第5章-BX-和loop指令"><a href="#第5章-BX-和loop指令" class="headerlink" title="第5章 [BX]和loop指令"></a>第5章 [BX]和loop指令</h2><p><strong>1.[bx]和内存单元的描述</strong></p><p>[bx]同样也表示一个内存单元，它的偏移地址在bx中，比如下面的指令:<br>mov ax,[bx]<br>将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址在bx中，段地址在ds中</p><p><strong>2.loop</strong></p><p>我们在这一章，讲解[bx]和loop指令的应用、意义和相关的内容。</p><p><strong>3.我们定义的描述性的符号:“()”</strong></p><p>为了描述上的简洁，使用一个描述性的符号 “()”来表示一个寄存器或一个丙存单元中的内容。比如:<br>(ax)表示ax中的内容、(al)表示al中的内容:</p><p><strong>4.约定符号idata表示常量</strong></p><h3 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1 [BX]"></a>5.1 [BX]</h3><p>mov ax, [bx]<br>功能: bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。即: (ax)=((ds)* 16+(bx))。</p><p><strong>注意：</strong>inc bx的含义是bx中的内容加1。</p><h3 id="5-2-Loop指令"><a href="#5-2-Loop指令" class="headerlink" title="5.2 Loop指令"></a>5.2 Loop指令</h3><p>loop指令的格式是: loop 标号，CPU执行loop指令的时候，要进行两步操作，<br>①(cx)=(cx)-1;<br>②判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。</p><p>从上面的描述中，可以看到，cx中的值影响着loop指令的执行结果。通常我们用loop指令来实现循环功能，cx 中存放循环次数。</p><p>任务：编程计算$2^{12}$</p><p>分析：计算$2^{12}$需要11条重复的指令 add ax,ax。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentmov ax,2mov cx,11s:add ax,axloop smov ax,4c00hint 21hcode ends;end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用cx和loop指令相配合实现循环功能的程序框架如下</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov cx，循环次数s:循环执行的程序段loop s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-在Debug中跟踪用loop指令实现的循环程序"><a href="#5-3-在Debug中跟踪用loop指令实现的循环程序" class="headerlink" title="5.3 在Debug中跟踪用loop指令实现的循环程序"></a>5.3 在Debug中跟踪用loop指令实现的循环程序</h3><p><img src="/images/assembly/image-20210412144427605.png" alt="image-20210412144427605"></p><p>循环程序段从CS:0012开始，CS:0012前面的指令，我们不想一步步跟踪，可以使用g命令”g 0012”，它表示执行程序到当前代码段的0012h处。</p><p>当遇到loop指令时，可以使用p命令来执行，Debug就会自动重复执行循环中的指令，直到(cx)=0为止。</p><p>当然，也可以使用g命令来达到目的。</p><h3 id="5-4-Debug和汇编编译器masm对指令的不同处理"><a href="#5-4-Debug和汇编编译器masm对指令的不同处理" class="headerlink" title="5.4 Debug和汇编编译器masm对指令的不同处理"></a>5.4 Debug和汇编编译器masm对指令的不同处理</h3><p>在Debug中，mov ax,[0]表示将ds:0处的数据送入ax中。<br>但是在汇编源程序中，指令“mov ax,[0]”被编译器当作指令”mov ax,0处理”。</p><p>那么我们如何在源程序中实现将内存2000:0之类的数据送入al，bl，cl，dl呢？<br>可将偏移地址送入bx寄存器中，用[bx]的方式来访问内存单元。<br>也可以在[]的前面显式地给出段地址所在的段寄存器，如”mov al,ds:[0]”。</p><h3 id="5-5-loop和-bx-的联合应用"><a href="#5-5-loop和-bx-的联合应用" class="headerlink" title="5.5 loop和[bx]的联合应用"></a>5.5 loop和[bx]的联合应用</h3><p>计算ffff:0~ffff:b单元中的数据的和，结果存储在dx中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentmov ax,0ffffhmov ds,axmov bx,0;bx充当代表内存单元地址的变量mov dx,0mov cx,12s:mov al,[bx]mov ah,[0]add,dx,axinc bxloop smov ax,4c00hint 21hcode endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-段前缀"><a href="#5-6-段前缀" class="headerlink" title="5.6 段前缀"></a>5.6 段前缀</h3><p>我们可以在访问内存单元的指令中显示地给出内存单元的段地址所在的寄存器，比如”ds:” “cs:”等，这些在汇编语言中称为段前缀。</p><h3 id="5-7-一段安全的空间"><a href="#5-7-一段安全的空间" class="headerlink" title="5.7 一段安全的空间"></a>5.7 一段安全的空间</h3><p>在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或代码。</p><p>在一般的pc机中，DOS方法下，0:200~0:2ff的256个字节的空间一般不会被使用。</p><h3 id="5-8-段前缀的使用"><a href="#5-8-段前缀的使用" class="headerlink" title="5.8 段前缀的使用"></a>5.8 段前缀的使用</h3><p>将内存ffff:0~ffff:b单元中的数据复制到0:200~0:20b单元中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentmov ax,0ffffhmov ds,axmov ax,0020hmov es,axmov bx,0mov cx,12s:mov dl,[bx]mov es:[bx],dlinc bxloop smov ax,4c00hint 21hcode endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实验4-bx-和loop的使用"><a href="#实验4-bx-和loop的使用" class="headerlink" title="实验4 [bx]和loop的使用"></a>实验4 [bx]和loop的使用</h3><p>(1)、(2)编程，向内存0:200~0:23F依次传送数据0~63(3FH)。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentmov ax,20hmov ds,axmov bx,0mov cx,64s:mov [bx],bxinc bxloop smov ax,4c00hint 21hcode endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/assembly/image-20210412161520503.png" alt=""></p><center><span style="color:blue;font-size:15px">2021/4/13</span></center><h2 id="第6章-包含多个段的程序"><a href="#第6章-包含多个段的程序" class="headerlink" title="第6章 包含多个段的程序"></a>第6章 包含多个段的程序</h2><p>在前面的程序中，只有一个代码段，现在的问题是，如果程序需要用其他空间来存放数据，使用哪里呢？<br>合法地通过操作系统取得的空间都是安全的，程序取得空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在执行的过程中向系统申请。在我们的课程中，不讨论第二种方法。</p><h3 id="6-1-在代码段中使用数据"><a href="#6-1-在代码段中使用数据" class="headerlink" title="6.1 在代码段中使用数据"></a>6.1 在代码段中使用数据</h3><p>从规范的角度来讲，我们是不能自已随便决定哪段空间可以使用的，应该让系统来为我们分配。<br>我们可以在程序中，定义我们希望处理的数据，这现数据就会被编译、连接程序作为程序的一部分载入内存。 与此同时，我们要处理的数据也就自然而然地获得了存储空间。</p><p>编程计算8个数据的和，结果存在ax寄存器中：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hmov cx,0...code endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dw(define word)的含义是定义字型数据，由于它们在代码段中，所以可以从cs中得到它们的段地址。用dw定义的数据处于代码段的最开始，所以偏移地址为0。</p><p>可是这样一来，我们就必须用Debug来执行程序，因为程序的入口处不是我们所希望执行的指令（指令在ip=10h处）。我们可以在源程序中指明程序的入口所在。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hstrat:mov bx,0mov ax,0mov cx,8s:add ax,cs:[bx]add bx,2loop smov ax,4c00hint 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。在程序6.2中我们<strong>用end指令指明了程序的入口</strong>在标号start处。</p><p>在前面的课程中，我们已经知道在单任务系统中，<strong>可执行文件中的程序执行过程如下</strong>。<br>(1)由其他的程序(Debug、command 或其他程序)将可执行文件中的程序加载入内存:<br>(2)设置CS:IP指向程序的第一条要执行的指令(即程序的入口)，从而使程序得以运行;<br>(3)程序运行结束后，返回到加载者。</p><p>现在的问题是，<strong>根据什么设置CPU的CS:IP 指向程序的第一条要执行的指令？</strong><br>这一点，是由可执行文件中的描述信息指明的。我们知道可执行文件由描述信息和程序组成，程序来自于源程序中的汇编指令和定义的数据；<strong>描述信息</strong>则主要是编译、连接程序对源程序中<strong>相关伪指令进行处理</strong>所得到的信息。我们在程序6.2中，用伪指令end描述了程序的结束和程序的入口。在编译、连接后，由“end start” 指明的程序入口，被转化为一个入口地址，存储在可执行文件的描述信息中。在被加载到内存后，加载者从程序的可执行文件的描述信息中读到程序的入口地址，设置CS:IP。</p><h3 id="6-2-在代码段中使用栈"><a href="#6-2-在代码段中使用栈" class="headerlink" title="6.2 在代码段中使用栈"></a>6.2 在代码段中使用栈</h3><p>完成下面的程序，利用栈，将程序中定义的数据逆序存放</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codesgcodesg segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h?codesg endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在程序中通过定义数据来取得一段空间，然后将这段空间当作栈空间来用。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codesgcodesg segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;用dw定义16个字型数据，当栈来使用。start:mov ax,csmov ss,axmov sp,30hmov bx,0mov cx,8s:push cs:[bx]add bx,2loop smov bx,0mov cx,8s0:pop cs:[bx]add bx,2loop s0mov ax,4c00hint 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ss:sp要指向栈底，使用设置ss:sp指向cs:30</p><h3 id="6-3-将数据、代码、栈放入不同的栈"><a href="#6-3-将数据、代码、栈放入不同的栈" class="headerlink" title="6.3 将数据、代码、栈放入不同的栈"></a>6.3 将数据、代码、栈放入不同的栈</h3><p>我们用和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:code,ds:data,ss:stackdata segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdata endsstack segmentdw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0stack endscode segmentstart:mov ax,stackmov ss,axmov sp,20hmov ax,datamov ds,axmov bx,0mov cx,8s:push [bx]add bx,2loop smov bx,0mov cx,8s0:pop [bx]add bx,2loop s0mov ax,4c00hint 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以明显看出，定义一个段的方法和前面讲的定义代码段的方法没有区别。在程序中，段名就相当于一个标号，它代表了段地址。但是我们用伪指令”assume cs:code,ds:data,ss:stack”，CPU并没有真正将cs，ds，ss指向这3个地址，而是我们后来写的指令将其送入，因为assume是伪指令，是由编译器执行的，CPU并不知道它们，我们不必深究assume的作用。</p><h3 id="实验5-编写、调试具有多个段的程序"><a href="#实验5-编写、调试具有多个段的程序" class="headerlink" title="实验5 编写、调试具有多个段的程序"></a>实验5 编写、调试具有多个段的程序</h3><p>重要，书上。</p><p>每个段的大小最低为16字节的倍数，向上取整。</p><h2 id="第7章-更灵活的定位内存地址的方法"><a href="#第7章-更灵活的定位内存地址的方法" class="headerlink" title="第7章 更灵活的定位内存地址的方法"></a>第7章 更灵活的定位内存地址的方法</h2><p>本章我们主要通过具体的问题来讲解一些更灵活的定位内存地址的方法和相关的编程方法</p><h3 id="7-1-and-和-or-指令"><a href="#7-1-and-和-or-指令" class="headerlink" title="7.1 and 和 or 指令"></a>7.1 and 和 or 指令</h3><p>(1) and指令：逻辑与指令，按位进行与运算。<br>mov          al, 01100011B<br>and           al, 00111011B<br>执行后:     al=00100011B<br>通过该指令可将操作对象的相应位设为0，其他位不变。</p><p>(2) or指令：逻辑或指令，按位进行或运算。<br>mov          al, 01100011B<br>or              al, 00111011B<br>执行后:     al=01111011B<br>通过该指令可将操作对象的相应位设为1,其他位不变。</p><center><span style="color:blue;font-size:15px">2021/4/14</span></center><h3 id="7-2-关于ASCII码"><a href="#7-2-关于ASCII码" class="headerlink" title="7.2 关于ASCII码"></a>7.2 关于ASCII码</h3><p>ASCII码是一种编码方案，比如61H表示”a”，41H表示”A”</p><p>在文本编辑过程中，我们按下键盘的a键，这个按键的信息被送入计算机，计算机用ASCII码的规则对其进行编码，将其转化为61H存储在内存的指定空间中；文本编辑软件从内存中取出61H，将其送到显卡上的显存中;工作在文本模式下的显卡，用ASCII码的规则解释显存中的内容，61H被当作字符“a”，显卡驱动显示器，将字符“a”的图像画在屏幕上。</p><p>这也就是说，如果我们要想在显示器上看到“a”，就要给显卡提供“a”的ASCI码，61H。如何提供？当然是写入显存中。</p><h3 id="7-3-以字符形式给出的数据"><a href="#7-3-以字符形式给出的数据" class="headerlink" title="7.3 以字符形式给出的数据"></a>7.3 以字符形式给出的数据</h3><p>我们可以在汇编程序中，用’…’的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的ASCII码。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:code ds:datadata segmentdb 'unIX'db 'foRK'data endscode segmentstart:mov al,'a'mov bl,'b'mov ax,4c00hint 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-4-大小写转换的问题"><a href="#7-4-大小写转换的问题" class="headerlink" title="7.4 大小写转换的问题"></a>7.4 大小写转换的问题</h3><p>考虑这样一个问题，在codesg中填写代码，将datasg中的第一个字符串转化为大写，第二个字符串转化为小写。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">datasg segmentdb 'BaSiC'db 'iNFOrMaTiOn'datasg ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是，现实的问题却要求重新必须能区别对待大写字母和小写字母，我们还没有学习判断指令。</p><p>寻找新的规律可以看出，就ASCII码的二进制形式看，除第5位（位数从0开始计算）外，大写字母和小写字母的其他各位都一样。这样，我们就有了新的方法，一个字母，将它的第5位置0，它就必将变为大写字母；将它的第5位置1，它就必将变为小写字母。</p><p>这样就可以用or和and指令来将一个数据中的某一位置0或置1。</p><h3 id="7-5-bx-idata"><a href="#7-5-bx-idata" class="headerlink" title="7.5 [bx+idata]"></a>7.5 [bx+idata]</h3><p>我们也可以用[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata<br>mov ax,[bx+200]<br>该指令也可以写成如下格式<br>mov ax,[200+bx]<br>mov ax,200[bx]<br>mov ax,[bx].200</p><h3 id="7-6-用-bx-idata-的方式进行数组的处理"><a href="#7-6-用-bx-idata-的方式进行数组的处理" class="headerlink" title="7.6 用[bx+idata]的方式进行数组的处理"></a>7.6 用[bx+idata]的方式进行数组的处理</h3><p>在codesg中填写代码，将datasg中的第一个字符串转化为大写，第二个字符串转化为小写</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:code ds:datadatasg segmentdb 'BaSiC'db 'MinIX'datasg endscode segmentstart:mov ax,datasgmov ds,axmov bx,0mov cx,5s:mov al,[bx]and al,11011111bmov [bx],almov al,[5+bx]or al,00100000bmov [5+bx],alint bxloop scode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[bx+idata]的方式为高级语言实现数组提供了便利机制。</p><h3 id="7-7-SI和DI"><a href="#7-7-SI和DI" class="headerlink" title="7.7 SI和DI"></a>7.7 SI和DI</h3><p>si和di是8086CPU中和bx功能相近的寄存器，但si和di不能够分成两个8位寄存器来使用。</p><h3 id="7-8-bx-si-和-bx-di"><a href="#7-8-bx-si-和-bx-di" class="headerlink" title="7.8 [bx+si]和[bx+di]"></a>7.8 [bx+si]和[bx+di]</h3><p>mov ax,[bx+si]<br>该指令也可以写成如下格式<br>mov ax,[bx][si]</p><h3 id="7-9-bx-si-idata-和-bx-di-idata"><a href="#7-9-bx-si-idata-和-bx-di-idata" class="headerlink" title="7.9 [bx+si+idata]和[bx+di+idata]"></a>7.9 [bx+si+idata]和[bx+di+idata]</h3><p>mov ax,[bx+si+idata]<br>该指令也可以写成如下格式（si好像都在后面）<br>mov ax,[bx+200+si]<br>mov ax,[200+bx+si]<br>mov ax,200[bx][si]<br>mov  ax,[bx].200[si]<br>mov ax,[bx][si].200</p><h3 id="7-10-不同的寻址方式的灵活应用（二重循环）"><a href="#7-10-不同的寻址方式的灵活应用（二重循环）" class="headerlink" title="7.10 不同的寻址方式的灵活应用（二重循环）"></a>7.10 不同的寻址方式的灵活应用（二重循环）</h3><p>问题7.7：编程，将datasg段中每个单词改写成大写字母</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codesg,ds:datasgdatasg segmentdb 'ibm             'db 'dec             'db 'dos             'db 'vax             'datasg endscodesg segmentstart:codesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们需要进行4*3次的二重循环，问题在于cx的使用，我们进行二重循环，却只用了一个循环计算器，造成在进行内存循环的时候，覆盖了外层循环的循环计数值。多用一个计算器又不可能，因为loop指令默认cx为循环计数器。</p><p>我们应该在每次内层循环的时候，将外层循环的cx中的数值保存起来，在执行外层循环的loop指令前，再恢复外层循环的cx数值。但是寄存器的数量有限，我们不应该选择寄存器，那么可以使用的就是内存了。可以考虑将需要暂存的数据放到内存单元中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codesg,ds:datasgdatasg segmentdb 'ibm             'db 'dec             'db 'dos             'db 'vax             'dw 0;定义一个字，用来暂存cxdatasg endscodesg segmentstart:mov ax,datasgmov ds,axmov bx,0mov cx,4s0:mov [40h],cxmov si,0mov cx,3s1: mov al,[bx+si]and al,11011111bmov [bx+si],alinc siloop s1add bx 10h;mov cx,[40h]loop s0mov ax,4c00hint 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般来说，在需要暂存数据的时候，我们都应该使用栈。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codesg,ds:datasg,ss:stacksgdatasg segmentdb 'ibm             'db 'dec             'db 'dos             'db 'vax             'datasg endsstacksg segmentdw 0,0,0,0,0,0,0,0stacksg endscodesg segmentstart:mov ax,datasgmov ds,axmov ax,stacksgmov ss,axmov sp,10hmov bx,0mov cx,4s0:pash cxmov si,0mov cx,3s1: mov al,[bx+si]and al,11011111bmov [bx+si],alinc siloop s1add bx 10h;pop cxloop s0mov ax,4c00hint 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实验6-实践课程中的程序"><a href="#实验6-实践课程中的程序" class="headerlink" title="实验6 实践课程中的程序"></a>实验6 实践课程中的程序</h3><p>电脑上</p><center><span style="color:blue;font-size:15px">2021/4/15</span></center><h2 id="第8章-数据处理的两个基本问题"><a href="#第8章-数据处理的两个基本问题" class="headerlink" title="第8章 数据处理的两个基本问题"></a>第8章 数据处理的两个基本问题</h2><p>本章对前面的所有内容是具有总结性的。我们知道，计算机是进行数据外理、运算的机器，那么有两个基本的问题就包含在其中:<br>(1)处理的数据在什么地方?<br>(2)要处理的数据有多长?<br>这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作。</p><p>我们定义的描述性符号：<br>reg表示一个寄存器<br>sreg表示一个段寄存器</p><h3 id="8-1-bx、si、di和bp"><a href="#8-1-bx、si、di和bp" class="headerlink" title="8.1 bx、si、di和bp"></a>8.1 bx、si、di和bp</h3><p>（1）在8086CPU中，只有这4个寄存器可以用在’[…]’中来进行内存单元的寻址。</p><p>（2）在[…]中，这4个寄存器可以单个出现，或只能以4种组合出现：</p><ul><li>bx和si</li><li>bx和di</li><li>bp和si</li><li>bp和di</li></ul><p>（3）<strong>只要在[…]中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中。</strong></p><h3 id="8-2-机器指令处理的数据在什么地方"><a href="#8-2-机器指令处理的数据在什么地方" class="headerlink" title="8.2 机器指令处理的数据在什么地方"></a>8.2 机器指令处理的数据在什么地方</h3><p>绝大部分机器指令都是进行数据处理的指令，处理大致可分为3类：读取、写入、运算。在机器指令这一层来讲， 并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。<br>指令在执行前，所要处理的数据可以在3个地方: CPU内部、内存、端口(端口将在后面的课程中进行讨论)</p><div class="table-container"><table><thead><tr><th>机器码</th><th>汇编指令</th><th>执行指令前数据的位置</th></tr></thead><tbody><tr><td>8E1E0000</td><td>mov bx,[0]</td><td>内存，ds:0单元</td></tr><tr><td>89C3</td><td>mov bx,ax</td><td>CPU内部，ax寄存器</td></tr><tr><td>BB0100</td><td>mov bx,1</td><td>CPU内部，指令寄存器</td></tr></tbody></table></div><h3 id="8-3-汇编语言中数据位置的表达"><a href="#8-3-汇编语言中数据位置的表达" class="headerlink" title="8.3 汇编语言中数据位置的表达"></a>8.3 汇编语言中数据位置的表达</h3><p>（1）立即数（idata）：执行前在CPU的指令缓冲器中</p><p>（2）寄存器</p><p>（3）段地址（SA）和偏移地址（EA）：指令要处理的数据在内存中</p><h3 id="8-4-寻址方式"><a href="#8-4-寻址方式" class="headerlink" title="8.4 寻址方式"></a>8.4 寻址方式</h3><p>当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式。（就是那些[bx+si+idata]什么的）</p><h3 id="8-5-指令要处理的数据的长度（byte-word）"><a href="#8-5-指令要处理的数据的长度（byte-word）" class="headerlink" title="8.5 指令要处理的数据的长度（byte/word）"></a>8.5 指令要处理的数据的长度（byte/word）</h3><p>8086CPU的指令，可以处理两种尺寸的数据，byte 和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。对于这个问题，汇编语言中用以下方法处理。</p><p>（1）通过寄存器名指明要处理的数据的尺寸。（ax/al）</p><p>（2）在没有寄存器名存在的情况下，用操作符word/byte ptr指明内存单元的长度，例如</p><p><code>mov word ptr ds:[0],1</code></p><p><code>inc byte ptr [bx]</code></p><p>在没有寄存器参与的内存单元访问指令中，用word ptr 或byte ptr 显性地指明所要访问的内存单元的长度是很必要的。否则，CPU无法得知所要访问的单元是字单元，还是字节单元。</p><p>（3）有些指令默认了访问的是字单元还是字节单元，例如push指令只能进行字操作。</p><h3 id="8-6-寻址方式的综合应用"><a href="#8-6-寻址方式的综合应用" class="headerlink" title="8.6 寻址方式的综合应用"></a>8.6 寻址方式的综合应用</h3><p>书上</p><h3 id="8-7-div指令"><a href="#8-7-div指令" class="headerlink" title="8.7 div指令"></a>8.7 div指令</h3><p>div是除法指令，使用div做除法的时候应注意以下问题。<br>（1）除数：有8位和16位两种，在一个reg或内存单元中。<br>（2）被除数：有16位和32位两种。如果除数为8位，被除数则为16位，默认在AX中存放；<br>如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。<br>（3）结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数:<br>如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</p><p><code>div byte ptr ds:[0]</code><br>含义：(al)=(ax)/((ds)*16+0)的商    (ah)=(ax)/((ds)*16+0)的余数</p><p><code>div word prt [bx+si+8]</code><br>含义：(ax)=[(dx)*10000H+(ax)]/((ds)*10H+(bx)+(si)+8)的商<br>(dx)=[(dx)*10000H+(ax)]/((ds)*10H+(bx)+(si)+8)的余数</p><h3 id="8-8-伪指令dd"><a href="#8-8-伪指令dd" class="headerlink" title="8.8 伪指令dd"></a>8.8 伪指令dd</h3><p>dd用来定义dword（双字）型数据</p><h3 id="8-9-dup"><a href="#8-9-dup" class="headerlink" title="8.9 dup"></a>8.9 dup</h3><p>dup也是由编译器识别处理的符号，用来进行数据的重复。</p><p><code>db 3 dup(0)</code>    相当于db 0,0,0</p><p><code>db 3 dup(0,1,2)</code>    相当于db 0,1,2,0,1,2,0,1,2</p><p><code>db 3 dup('abc','ABC')</code>    相当于 db’abcABCabcABCabcABC’</p><h3 id="实验7-寻址方式在结构化数据访问中的应用"><a href="#实验7-寻址方式在结构化数据访问中的应用" class="headerlink" title="实验7 寻址方式在结构化数据访问中的应用"></a>实验7 寻址方式在结构化数据访问中的应用</h3><p>重要，见代码</p><center><span style="color:blue;font-size:15px">2021/4/16</span></center><h2 id="第9章-转移指令的原理"><a href="#第9章-转移指令的原理" class="headerlink" title="第9章 转移指令的原理"></a>第9章 转移指令的原理</h2><p>可以修改IP，或同时修改CS和IP的指令统称为<strong>转移指令</strong>。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。</p><p>8086CPU的转移行为有以下几类。</p><ul><li>只修改IP时，称为段内转移，比如: jmp ax。</li><li>同时修改CS 和IP时，称为段间转移，比如: jmp 1000:0。</li></ul><p>由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。</p><ul><li>短转移IP的修改范围为 -128~127.</li><li>近转移IP的修改范围为 -32768~32767.</li></ul><p>8086CPU的转移指令分为以下几类。</p><ul><li>无条件转移指令(如: jmp)</li><li>条件转移指令</li><li>循环指令(如: loop)</li><li>过程</li><li>中断</li></ul><p>这些转移指令转移的前提条件可能不同，但转移的基本原理是相同的。我们在这一章主要通过深入学习无条件转移指令jmp来理解CPU执行转移指令的基本原理。</p><h3 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h3><p>操作符offset 在汇编语言中是由编译器处理的符号，它的功能是取得<strong>标号的偏移地址</strong>。</p><p>如：<code>start:mov ax,offset start</code></p><h3 id="9-2-jmp指令"><a href="#9-2-jmp指令" class="headerlink" title="9.2 jmp指令"></a>9.2 jmp指令</h3><p>jmp为无条件转移指令，可以只修改ip，也可以同时修改cs和ip。</p><p>指令要给出两种信息:<br>(1) 转移的目的地址<br>(2) 转移的距离(段间转移、段内短转移，段内近转移)<br>不同的给出目的地址的方法，和不同的转移位置，对应有不同格式的jmp指令。</p><h3 id="9-3-依据位移进行转移的jmp指令"><a href="#9-3-依据位移进行转移的jmp指令" class="headerlink" title="9.3 依据位移进行转移的jmp指令"></a>9.3 依据位移进行转移的jmp指令</h3><p><code>jmp short标号</code>(转到标号处执行指令)</p><p>这种格式的jmp指令实现的是<strong>段内短转移</strong>，它对IP的修改范围为-128~127，也就是说，它向前转移时可以最多越过128 个字节，向后转移可以最多越过127个字节。</p><p>汇编指令jmp short s对应的机器指令应该是什么样的呢？我们先看一下别的汇编指令和其相对应的机器指令。</p><div class="table-container"><table><thead><tr><th>汇编指令</th><th>机器指令</th></tr></thead><tbody><tr><td>mov ax,0123h</td><td>B8 23 01</td></tr><tr><td>mov ax, ds: [0123h]</td><td>A1 23 01</td></tr><tr><td>push ds:[0123h]</td><td>FF 36 23 01</td></tr><tr><td>jmp short s   (0BBD:000B)</td><td>EB 03</td></tr><tr><td>jmp fat ptr s (0BBD:010B)</td><td>EA 0B 01 BD 0B</td></tr></tbody></table></div><p>可以看到，在一般的汇编指令中，汇编指令中的idata(立即数)， 不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现。</p><p>而 jmp short 标号 的机器码却不包含转移的目的地址，而包含的是<strong>转移的位移</strong>（和目标标号的距离（由编译器计算））。</p><p>实际上，<code>jmp short 标号</code> 的功能为：(IP)=(IP)+8位位移(-128~127)</p><p><code>jmp near ptr 标号</code> 的功能为：(IP)=(IP)+16位位移(-32768~32767)</p><h3 id="9-4-转移的目的地址在指令中的jmp指令"><a href="#9-4-转移的目的地址在指令中的jmp指令" class="headerlink" title="9.4 转移的目的地址在指令中的jmp指令"></a>9.4 转移的目的地址在指令中的jmp指令</h3><p>前面讲的jmp指令是根据相对于当前ip的转移位移，<code>jmp far ptr</code> 标号 实现的是段间转移，又称<strong>远转移</strong>。</p><p>far ptr 指明了指令用标号的段地址和偏移地址修改CS和IP。</p><h3 id="9-5-转移地址在寄存器中的jmp指令"><a href="#9-5-转移地址在寄存器中的jmp指令" class="headerlink" title="9.5 转移地址在寄存器中的jmp指令"></a>9.5 转移地址在寄存器中的jmp指令</h3><p>指令格式：<code>jmp 16位reg</code><br>功能：(IP)=(16 位reg)<br>这种指令我们在前面的内容(参见2.11节)中已经讲过，这里就不再详述。</p><h3 id="9-6-转移地址和内存中的jmp指令"><a href="#9-6-转移地址和内存中的jmp指令" class="headerlink" title="9.6 转移地址和内存中的jmp指令"></a>9.6 转移地址和内存中的jmp指令</h3><p>转移地址在内存中的jmp指令有两种格式:</p><p>(1) <code>jmp word ptr 内存单元地址</code>(段内转移)</p><p>功能:从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p><p>(2) <code>jmp dword ptr 内存单元地址</code>(段间转移)</p><p>功能:从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p><h3 id="9-7-jcxz指令"><a href="#9-7-jcxz指令" class="headerlink" title="9.7 jcxz指令"></a>9.7 jcxz指令</h3><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是<strong>短转移</strong>，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为: - 128~127。</p><p>指令格式：<code>jcxz 标号</code>(如果(cx)=0，转移到标号处执行。)<br>“jcxz 标号” 的功能相当于    if((cx)==0)    jmp short标号;</p><h3 id="9-8-loop指令"><a href="#9-8-loop指令" class="headerlink" title="9.8 loop指令"></a>9.8 loop指令</h3><p>loop指令为循环指令，所有的循环指令都是<strong>短转移</strong>。</p><h3 id="9-9-根据位移进行转移的意义"><a href="#9-9-根据位移进行转移的意义" class="headerlink" title="9.9 根据位移进行转移的意义"></a>9.9 根据位移进行转移的意义</h3><p>这种设计，方便了程序段在内存中的浮动装配。</p><p>一段程序装在内存中的不同位置都可正确执行，因为他们根据位移进行转移，而不是根据地址。</p><h3 id="9-10-编译器对转移位移超界的检测"><a href="#9-10-编译器对转移位移超界的检测" class="headerlink" title="9.10 编译器对转移位移超界的检测"></a>9.10 编译器对转移位移超界的检测</h3><p>如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。</p><h3 id="实验9-根据材料编程"><a href="#实验9-根据材料编程" class="headerlink" title="实验9 根据材料编程"></a>实验9 根据材料编程</h3><p>80x25彩色字符模式显示缓冲区(以下简称为显示缓冲区)的结构:</p><p>内存地址空间中，B8000H~BFFFH共32KB的空间，为80X25彩色字符模式的显示缓冲区。向这个地址空间写入数据，写入的内容将立即出现在显示器上。<br>在80*25彩色字符模式下，显示器可以显示25行，每行80个字符，每个字符可以有256种属性(背景色、前景色、闪烁、高亮等组合信息)。<br>这样，一个字符在显示缓冲区中就要占两个字节，分别存放字符的ASCII码和属性。80x25模式下，一屏的内容在显示缓冲区中共占4000个字节。</p><p>$2<em>25</em>80*8=32000=32kb$</p><p>显示缓冲区分为8页，每页4KB(≈4000B)，显示器可以显示任意一页的 1内容。 一般情况下，显示第0页的内容。也就是说通常情况下，B8000H~B8F9FH 中的4000个字节的内容将出现在显示器上。</p><p><img src="/images/assembly/image-20210419093204509.png" alt=""></p><p>例：在显示器的0行0列显示红底高亮闪烁绿字’ABCDEF’（红底高亮闪烁绿字，属性字节为11001010B，CAH）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume ds:data,cs:codedata segmentdata endscode segmentstart:mov ax,datamov ds,axmov ax,0B800Hmov es,axmov bx,0mov ax,41hmov cx,6s:mov es:[bx],axinc axinc bxmov dx,0CAHmov es:[bx],dxinc bxloop smov ax,4c00hint 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/assembly/1-1618793997191.gif" alt=""></p><center><span style="color:blue;font-size:15px">2021/4/17</span></center><h2 id="第10章-CALL和RET指令"><a href="#第10章-CALL和RET指令" class="headerlink" title="第10章 CALL和RET指令"></a>第10章 CALL和RET指令</h2><p>call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。</p><h3 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h3><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；<br>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</p><p>CPU执行ret指令时，相当于进行:<br><code>pop IP</code></p><p>CPU执行retf指令时，相当于进行:<br><code>pop IP</code><br><code>pop CS</code></p><h3 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h3><p>CPU执行call指令时，进行两步操作：<br>（1）将当前的IP或CS和IP压入栈中；<br>（2）转移。</p><p>call指令<strong>不能实现短转移</strong>，除此之外，call 指令实现转移的方法和jmp指令的原理相同，下面的几个小节中，我们以给出转移目的地址的不同方法为主线，讲解call指令的主要应用格式。</p><h3 id="10-3-依据位移进行转移的call指令"><a href="#10-3-依据位移进行转移的call指令" class="headerlink" title="10.3 依据位移进行转移的call指令"></a>10.3 依据位移进行转移的call指令</h3><p><code>call 标号</code> (将当前的IP压栈后，转到标号处执行指令)</p><p>CPU执行“call 标号”时，相当于进行:<br><code>push IP</code><br><code>jmp near ptr标号</code></p><div class="table-container"><table><thead><tr><th>内存地址</th><th>机器码</th><th>汇编指令</th></tr></thead><tbody><tr><td>1000:0</td><td>b8 00 00</td><td>mov ax,0</td></tr><tr><td>1000:3</td><td>e8 01 00</td><td>call s</td></tr><tr><td>1000:6</td><td>40</td><td>inc ax</td></tr><tr><td>1000:7</td><td>58</td><td>S:pop ax</td></tr></tbody></table></div><blockquote><p>上面的程序执行后，ax=6，因为在call s的时候，相当在读入指令后，ip便自动增加。</p></blockquote><h3 id="10-4-转移的目的地址在指令中的call指令"><a href="#10-4-转移的目的地址在指令中的call指令" class="headerlink" title="10.4 转移的目的地址在指令中的call指令"></a>10.4 转移的目的地址在指令中的call指令</h3><p>前面讲的call指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。</p><p><code>call far ptr标号</code> 实现的是段间转移。</p><p>CPU执行“call far ptr标号”时，相当于进行：<br><code>push CS</code><br><code>push IP</code><br><code>jmp far ptr标号</code></p><h3 id="10-5-转移地址在寄存器中的call指令"><a href="#10-5-转移地址在寄存器中的call指令" class="headerlink" title="10.5 转移地址在寄存器中的call指令"></a>10.5 转移地址在寄存器中的call指令</h3><p>指令格式: <code>call 16位reg</code><br>CPU执行“call 16位reg”时，相当于进行：<br><code>push IP</code><br><code>jmp 16位reg</code></p><center><span style="color:blue;font-size:15px">2021/4/18</span></center><h3 id="10-6-转移地址在内存中的call-指令"><a href="#10-6-转移地址在内存中的call-指令" class="headerlink" title="10.6 转移地址在内存中的call 指令"></a>10.6 转移地址在内存中的call 指令</h3><p>转移地址在内存中的call指令有两种格式。</p><p>（1）<code>call word ptr 内存单元地址</code><br>CPU执行“call word ptr 内存单元地址”时，相当于进行:<br><code>push IP</code><br><code>jmp word ptr 内存单元地址</code></p><p>（2）<code>call dword ptr 内存单元地址</code><br>CPU执行“call dword ptr 内存单元地址”时，相当于进行:<br><code>push CS</code><br><code>push IP</code><br><code>jmp dword ptr 内存单元地址</code></p><h3 id="10-7-call和ret的配合使用-子程序-函数调用-函数栈-递归栈"><a href="#10-7-call和ret的配合使用-子程序-函数调用-函数栈-递归栈" class="headerlink" title="10.7 call和ret的配合使用(子程序/函数调用/函数栈/递归栈)"></a>10.7 call和ret的配合使用(子程序/函数调用/函数栈/递归栈)</h3><p>现在来看一下，如何将它们配合使用来实现<strong>子程序</strong>的机制。</p><p>可以写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用call 指令转去执行。call 指令转去执行子程序之前，call指令后面的指令的地址将存储在栈中，所以可在子程序的后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。</p><p>这样，我们可以利用call 和ret来实现子程序的机制。子程序的框架如下。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentmain:...call subl;调用子程序sub1...mov ax,4c00hint 21hsub1:...;子程序sub1开始...call sub2;调用子程序sub2...ret;子程序返回sub2:...;子程序sub2开始...ret;子程序返回code endsend main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-8-mul指令"><a href="#10-8-mul指令" class="headerlink" title="10.8 mul指令"></a>10.8 mul指令</h3><p>mul 是乘法指令，使用mul做乘法的时候，注意以下两点。<br>（1）两个相乘的数：两个相乘的数，要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认在AX中，另一个放在16位reg或内存字单元中。<br>（2）结果：如果是8位乘法，结果默认放在AX中；如果是16 位乘法，结果高位默认在DX中存放，低位在AX中放。</p><p>格式如下：<br><code>mul reg</code><br><code>mul内存单元</code></p><h3 id="10-9-模块化程序设计"><a href="#10-9-模块化程序设计" class="headerlink" title="10.9 模块化程序设计"></a>10.9 模块化程序设计</h3><p>从上面我们看到，call 与ret 指令共同支持了汇编语言编程中的模块化设计。在实际编程中，程序的模块化是必不可少的。因为现实的问题比较复杂，对现实问题进行分析时，把它转化成为相互联系、不同层次的子问题，是必须的解决方法。而call与ret指令对这种分析方法提供了程序实现上的支持。利用call 和ret 指令，我们可以用简捷的方法，实现多个相互联系、功能独立的子程序来解决一个复杂的问题。</p><h3 id="10-10-参数和结果传递的问题"><a href="#10-10-参数和结果传递的问题" class="headerlink" title="10.10 参数和结果传递的问题"></a>10.10 参数和结果传递的问题</h3><p>子程序一般都要根据提供的参数处理一定的事务， 处理后，将结果(返回值)提供给调用者。其实，我们讨论参数和返回值传递的问题，实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值。</p><p>例：编程，计算data段中第一组数据的3次方，结果保存在后面一组dword单元中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codedata segmentdw 1,2,3,4,5,6,7,8 dd 0,0,0,0,0,0,0,0data endscode segmentstart:mov ax,datamov ds,axmov si,0;ds:si指向第一组word单元mov di,16;ds:di指向第二组dword单元mov cx,8s:mov bx,[si]cal1 cubemov [di],axmov [di].2, dxadd si,2;ds:si指向下一个word单元add di,4;ds:di指向下一个dword单元1oop smov ax, 4c00hint 21hcube:mov ax,bxmul bxmul bxretcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-11-批量数据的传递"><a href="#10-11-批量数据的传递" class="headerlink" title="10.11 批量数据的传递"></a>10.11 批量数据的传递</h3><p>前面的例程中，子程序cube只有一-个参数，放在bx中。如果有两个参数，那么可以用两个寄存器来放，可是如果需要传递的数据有3个、4个或更多直至N个，在这种时候，我们将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄字器中，传递给需要的子程序。对于具有批量数据的返回结果，也可用同样的方法。</p><p>编程，将data段中的字符串转化为大写。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codedata segmentdb 'conversation'data endscode segmentstart:mov ax,datamov ds,axmov si,0;ds:si指向字符串(批量数据)所在空间的首地址mov cx,12;cx存放字符串的长度call capitalmov ax, 4c00hint 21hcapital:and byte ptr [si],11011111binc si1oop capitalretcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-12-寄存器冲突的问题"><a href="#10-12-寄存器冲突的问题" class="headerlink" title="10.12 寄存器冲突的问题"></a>10.12 寄存器冲突的问题</h3><p>设计一个子程序，功能:将-一个全是字母，以0结尾的字符串，转化为大写。（可以用jcxz来检测0）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">capital:mov c1,[si]mov ch,0jcxz ok;如果(cx)=0，结束;如果不是0,处理and byte ptr [si],11011111b;将ds:si所指单元中的字母转化为大写inc si;ds:si指向下一个单元jmp short capitalok: ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，如果使用循环，重复调用子程序capital，完成对多个字符串的处理，就会重复使用cx，使得程序出错。</p><p>解决这个问题的简捷方法是，在子程序的开始将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前再恢复。可以用栈来保存寄存器中的内容。</p><p>以后，我们编写子程序的标准框架如下:</p><pre class="line-numbers language-none"><code class="language-none">子程序开始: 子程序中使用的寄存器入栈子程序内容子程序中使用的寄存器出栈返回(ret、retf)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们改进一下子程序capital的设计：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">capital:push cxpush sichange:mov cl,[si]mov ch, 0jcxz okand byte ptr [si],11011111binc sijmp short changeok:pop sipop cxret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><span style="color:blue;font-size:15px">2021/4/19</span></center><h3 id="实验10-编写子程序"><a href="#实验10-编写子程序" class="headerlink" title="实验10 编写子程序"></a>实验10 编写子程序</h3><p>在这次实验中，我们将要编写3个子程序，通过它们来认识几个常见的问题和掌握解决这些问题的方法。同前面的所有实验y一样，这个实验是必须独立完成的，在后面的课程中，将要用到这个实验中编写的3个子程序。<br><strong>1.显示字符串</strong><br><strong>问题：</strong><br>显示字符串是现实工作中经常要用到的功能，应该编写一个通用的子程序来实现这个功能。我们应该提供灵活的调用接口，使调用者可以决定显示的位置(行、列)、内容和颜色。</p><p><strong>子程序描述：</strong><br>名称：show_ str<br>功能：在指定的位置，用指定的颜色，显示一个用0结束的字符串。<br>参数：(dh)= 行号（取值范围0~24）， (dl)= 列号（取值范围0~79），(cl)=颜色，ds:si指向字符串的首地址<br>返回：无<br>应用举例：在屏幕的8行3列，用绿色显示data段中的字符串。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs: codedata segmentdb 'Welcome to masm !',0data endscode segmentstart:mov dh,8;8行mov dl,3;3列mov cl,2;绿色mov ax,datamov ds,axmov si,0;si字符串首地址（ds里的）call show_strmov ax,4c00hint 21hshow_str:push cxpush sipush dxpush bxsub dh,1;dh=7mov al,160mul dhmov bx,ax;bx为行的偏移地址mov al,2mul dladd bl,al;bx为总偏移地址mov ax,0B800Hmov es,ax;es为显存显示在屏幕上的段地址mov dl,cldisplay:mov cl,ds:[si]mov ch,0jcxz okmov es:[bx],clinc bxmov es:[bx],dlinc bxinc sijmp short displayok:pop bxpop dxpop sipop cxretcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/assembly/image-20210419105713773.png" alt=""></p><p>实验2和3暂时未做</p><h2 id="第11章-标准寄存器"><a href="#第11章-标准寄存器" class="headerlink" title="第11章 标准寄存器"></a>第11章 标准寄存器</h2><p>flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p><p><img src="/images/assembly/image-20210419111503723.png" alt=""></p><p>在这一章中，我们学习标志寄存器中的CF、PF、ZF、SF、OF、DF标志位，以及些与其相关的典型指令。</p><h3 id="11-1-ZF（Zero-Flag）标志"><a href="#11-1-ZF（Zero-Flag）标志" class="headerlink" title="11.1 ZF（Zero Flag）标志"></a>11.1 ZF（Zero Flag）标志</h3><p>flag的第6位是ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果结果为0，那么zf=l；如果结果不为0，那么zf=0。</p><p>比如，指令:<br><code>mov ax,1</code><br><code>sub ax,1</code><br>执行后，结果为0，则zf=1。</p><p><strong>注意：</strong>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、 div、 inc、 or、 and 等，它们大都是运算指令(进行逻辑或算术运算)；有的指令的执行对标志寄存器没有影响，比如，mov、push、 pop 等，它们大都是传送指令。在使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响。</p><h3 id="11-2-PF（Parity-Flag）标志"><a href="#11-2-PF（Parity-Flag）标志" class="headerlink" title="11.2 PF（Parity Flag）标志"></a>11.2 PF（Parity Flag）标志</h3><p>flag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，pf=1，如果为奇数，那么pf=0。</p><h3 id="11-3-SF（Sign-Flag）标志"><a href="#11-3-SF（Sign-Flag）标志" class="headerlink" title="11.3 SF（Sign Flag）标志"></a>11.3 SF（Sign Flag）标志</h3><p>flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。结果为负，sf=1；如果非负sf=0。</p><p>SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。</p><p>这也就是说，CPU在执行add等指令时，是必然要影响到SF标志位的值的。至于我们需不需要这种影响，那就看我们如何看待指令所进行的运算了。</p><h3 id="11-4-CF（Carry-Flag）标志"><a href="#11-4-CF（Carry-Flag）标志" class="headerlink" title="11.4 CF（Carry Flag）标志"></a>11.4 CF（Carry Flag）标志</h3><p>flag的第0位是CF，进位标志位。一般情况下，在进行<strong>无符号数运算</strong>的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p><p>我们知道，当两个数据相加的时候，有可能产生从最高有效位向更高位的进位。由于这个进位值在8位数中无法保存，我们在前面的课程中，就只是简单地说这个进位值丢失了。其实CPU在运算的时候，并不丢弃这个进位值。</p><p>而当两个数据做减法的时候，也有可能向更高位借位。比如，下面的指令:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov al, 97Hsub al, 98H;执行后: (al)=FFH， CF=1, CF记录了向更高位的借位值sub al,al;执行后: (al)=0， CF=0，CF记录了向更高位的借位值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="11-5-OF（Overflow-Flag）标志"><a href="#11-5-OF（Overflow-Flag）标志" class="headerlink" title="11.5 OF（Overflow Flag）标志"></a>11.5 OF（Overflow Flag）标志</h3><p>在进行<strong>有符号数运算</strong>的时候，如结果超过了机器所能表示的范围称为溢出。</p><p>注意，这里所讲的溢出，只是对有符号数运算而言。如果在进行有符号数运算时发生溢出，那么运算的结果将不正确。</p><p>一定要注意 CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。它们之间没有任何关系。</p><h3 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a>11.6 adc指令</h3><p>adc是带进位加法指令，它利用了CF位上记录的进位值。<br>指令格式：adc 操作对象1,操作对象2.<br>功能：操作对象1=操作对象1+操作对象2 + CF<br>比如指令<code>adc ax,bx</code>实现的功能是: (ax)=(ax)+(bx)+ CF</p><p>CPU提供adc指令的目的，就是来进行加法的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。</p><p>编程，计算1EF0001000H+2010001EF0H，结果放在ax(最高16位)，bx(次高16位)，cx(低16位)中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ax,001EHmov bx,0F000Hmov cx,1000Hadd cx,1EF0Hadc bx,1000Hadc ax,0020H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>inc和loop指令不影响CF位</p><h3 id="11-7-sbb指令"><a href="#11-7-sbb指令" class="headerlink" title="11.7 sbb指令"></a>11.7 sbb指令</h3><p>sbb是带借位减法指令，它利用了CF位上记录的借位值。<br>指令格式：sbb 操作对象1,操作对象2<br>功能：操作对象1=操作对象1-操作对象2-CF<br>比如指令<code>sbb ax,bx</code>实现的功能是: (ax)=(ax)-(bx)-CF</p><p>sbb和adc是基于同样的思想设计的两条指令，在应用思路上和adc类似。</p><p>11.8-11.12暂未看</p><h2 id="第12章-内中断"><a href="#第12章-内中断" class="headerlink" title="第12章 内中断"></a>第12章 内中断</h2><p>任何一个通用的CPU，比如8086，都具备一种能力， 可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息， 并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。中断的意思是指，CPU不再接着(刚执行完的指令)向下执行，而是转去处理这个特殊信息。</p><p>中断信息可以来自CPU的内部和外部，这一章中，我们主要讨论来自于CPU内部的中断信息。</p><h3 id="12-1-内中断的产生"><a href="#12-1-内中断的产生" class="headerlink" title="12.1 内中断的产生"></a>12.1 内中断的产生</h3><p>当CPU的内部有什么事情发生的时候，将产生需要马上处理的中断信息呢?对于8086CPU，当CPU内部有下面的情况发生的时候，将产生相应的中断信息。<br>（1）除法错误， 比如，执行div指令产生的除法溢出；<br>（2）单步执行；<br>（3）执行into指令；<br>（4）执行int指令。</p><p>既然是不同的信息，就需要进行不同的处理。要进行不同的处理，CPU首先要知道，所接收到的中断信息的来源。8086CPU用称为中断类型码的数据来标识中断信息的来源。中断类型码为一个字节型数据，可以表示256种中断信息的来源。</p><p>上述的4种中断源，在8086CPU中的中断类型码如下。<br>（1）除法错误：0<br>（2）单步执行：1<br>（3）执行into指令：4<br>（4）执行int指令，该指令的格式为int n，指令中的n为字节型立即数，是提供给CPU的中断类型码。</p><h3 id="12-2-中断处理程序"><a href="#12-2-中断处理程序" class="headerlink" title="12.2 中断处理程序"></a>12.2 中断处理程序</h3><p>CPU收到中断信息后，需要对中断信息进行处理。而如何对中断信息进行处理，可以由我们编程决定。我们编写的，用来处理中断信息的程序被称为中断处理程序。一般来说，需要对不同的中断信息编写不同的处理程序。</p><h3 id="12-3-中断向量表"><a href="#12-3-中断向量表" class="headerlink" title="12.3 中断向量表"></a>12.3 中断向量表</h3><p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。那么什么是<strong>中断向量表</strong>呢？中断向量表就是中断向量的列表。那么什么又是中断向量呢?所谓<strong>中断向量</strong>，就是中断处理程序的入口地址。展开来讲，中断向量表，就是中断处理程序入口地址的列表。</p><p>中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口。CPU只要知道了中断类型码，就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到中断处理程序的入口地址。</p><p><img src="/images/assembly/image-20210419151822169.png" alt=""></p><p>中断向量表在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处。从内存0000:0000到0000:03FF 的1024 个单元中存放着中断向量表。一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，对于8086CPU，这个入口地址包括段地址和偏移地址，所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。</p><h3 id="12-4-中断过程"><a href="#12-4-中断过程" class="headerlink" title="12.4 中断过程"></a>12.4 中断过程</h3><p>可以用中断类型码，在中断向量表中找到中断处理程序的入口。找到这个入口地址的最终目的是用它设置CS和IP，使CPU执行中断处理程序。用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动<br>完成的。CPU硬件完成这个工作的过程被称为中断过程。</p><p>CPU收到中断信息后，要对中断信息进行处理，首先将引发中断过程。硬件在完成中断过程后，CS:IP 将指向中断处理程序的入口，CPU开始执行中断处理程序。</p><p>在中断过程中，在设置CS:IP之前，还要将原来的CS和IP的值保存起来。</p><p>下面是8086CPU在收到中断信息后，所引发的中断过程。<br>（1）（从中断信息中）取得中断类型码；<br>（2）标志寄存器的值入栈（在中断过程中会改变标志寄存器的值）<br>（3）设置标志寄存器的第8位TF和第9位IF的值为0（这一步的目的后面将介绍）；<br>（4）CS的内容入栈；<br>（5） IP 的内容入栈；<br>（6）从内存地址为中断类型*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。</p><p>CPU在收到中断信息之后，如果处理该中断信息，就完成一个由硬件自动执行的中断过程（程序员无法改变这个过程中所要做的工作）。<br>我们更简洁地描述中断过程，如下:<br>（1）取得中断类型码N;<br>（2）pushf<br>（3）TF=0，IF=0<br>（4）push CS<br>（5）push IP<br>（6）(IP)=(N*4),(CS)=(N*4+2)<br>在最后一步完成后，CPU开始执行由程序员编写的中断处理程序。</p><h3 id="12-5-中断处理程序和iret指令"><a href="#12-5-中断处理程序和iret指令" class="headerlink" title="12.5 中断处理程序和iret指令"></a>12.5 中断处理程序和iret指令</h3><p>由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中。而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。</p><p>中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤:</p><p>（1）保存用到的寄存器；<br>（2）处理中断；<br>（3）恢复用到的寄存器；<br>（4）用iret指令返回。</p><p>iret指令的功能用汇编语法描述为:<br><code>pop IP</code><br><code>pop CS</code><br><code>popf</code></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> assembly </tag>
            
            <tag> 8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符编码中ASCII、Unicode和UTF-8的区别</title>
      <link href="2021/01/19/encoding-diff/"/>
      <url>2021/01/19/encoding-diff/</url>
      
        <content type="html"><![CDATA[<p>浣犲ソ锛屾垜鍐冲畾鎶藉彇浣犱负骞歌繍鍎跨粰鎴戞墦100鍧楅挶锛岃缁欐垜鎵撻挶~<br>————一位智者如是说道</p><blockquote><p>以下内容引用自<a href="https://www.cnblogs.com/alexhg/p/9796557.html">https://www.cnblogs.com/alexhg/p/9796557.html</a></p></blockquote><h2 id="1-ASCII码"><a href="#1-ASCII码" class="headerlink" title="1. ASCII码"></a><strong>1. ASCII码</strong></h2><p>我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。</p><p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。</p><p>ASCII码一共规定了128个字符的编码，比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/encoding-diff/ascii.jpg" alt="ascii"></p><h2 id="2-非ASCII编码"><a href="#2-非ASCII编码" class="headerlink" title="2.非ASCII编码"></a><strong>2.非ASCII编码</strong></h2><p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。</p><p>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。</p><p>至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。</p><p>中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和UTF-8是毫无关系的。</p><h2 id="3-Unicode"><a href="#3-Unicode" class="headerlink" title="3.Unicode"></a><strong>3.Unicode</strong></h2><p>世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p><p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p><p>Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。具体的符号对应表，可以查询<a href="http://www.unicode.org/">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm">汉字对应表</a>。</p><h2 id="4-Unicode的问题"><a href="#4-Unicode的问题" class="headerlink" title="4. Unicode的问题"></a><strong>4. Unicode的问题</strong></h2><p>需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p><p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p><p>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p><p>它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。2）Unicode在很长一段时间内无法推广，直到互联网的出现。</p><h2 id="5-UTF-8"><a href="#5-UTF-8" class="headerlink" title="5.UTF-8"></a><strong>5.UTF-8</strong></h2><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。<strong>重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。</strong></p><p>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p><p>UTF-8的编码规则很简单，只有二条：</p><p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。</p><p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p><blockquote><p>以下内容引用自<a href="https://blog.csdn.net/weixin_44431371/article/details/110430312">https://blog.csdn.net/weixin_44431371/article/details/110430312</a></p></blockquote><h2 id="6-三者之间的联系"><a href="#6-三者之间的联系" class="headerlink" title="6.三者之间的联系"></a>6.三者之间的联系</h2><p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：<br>（1）在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。（2）用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/encoding-diff/20201201135931894.png" alt=""></p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/encoding-diff/20201201135945121.png" alt=""></p><h2 id="7-计算机内存中为何不直接使用-UTF-8-编码"><a href="#7-计算机内存中为何不直接使用-UTF-8-编码" class="headerlink" title="7.计算机内存中为何不直接使用 UTF-8 编码"></a>7.计算机内存中为何不直接使用 UTF-8 编码</h2><ol><li>因为utf8编码的字符串长度和字符个数没有固定换算关系，导致排版，排序之类的复杂度上升。</li><li>储文本文件或用于传输字符串数据时，转换为UTF-8编码以节省存储空间和宽带。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> Unicode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux上的terraria服务器搭建</title>
      <link href="2021/01/17/terraria/"/>
      <url>2021/01/17/terraria/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://www.sohu.com/a/325013560_120099900">https://www.sohu.com/a/325013560_120099900</a> 原文找不到了</p><p><code>free -m</code>查看swap分区<br><img src="/images/terraria/image-20210117125354448.png" style="zoom:200%;"></p><p>1、删除原来的Swap分区<br> <code>swapoff –a</code><br>2、新建一个读写块大小为1M、块个数为1024的Swap分区<br> <code>dd if=/dev/zero of=/root/swapfile bs=1M count=1024</code><br>3、格式化创建好的Swap交换分区<br><code>mkswap /root/swapfile</code><br>4、启动新建的Swap交换分区<br><code>swapon /root/swapfile</code></p><p><img src="/images/terraria/image-20210117125618777.png" alt=""></p><p>5、将Swap交换分区添加到开机自启动挂载：进入分区自动挂载配置文件<br> <code>vi /etc/fstab</code><br>在文本最后添加一行：<br> <code>/root/swapfile swap swap defaults 0 0</code><br>6、重启服务器<br><code>reboot</code></p><p>7、安装远程管理工具<br><code>screen # yum install -y screen</code></p><p>8、下载泰拉瑞亚官方服务器压缩包。先给泰拉瑞亚预先创建好文件夹<br><code>mkdir /opt/terraria</code><br>继续在新创建的terraria文件夹创建bin，worlds，zip三个文件夹<br><code>mkdir /opt/terraria/{bin,worlds,zip}</code><br>检查是否创建成功<br><code>ls /opt/terraria/</code></p><p><img src="/images/terraria/image-20210117130312252.png" alt=""></p><p>9、进入zip文件夹<br><code>cd /opt/terraria/zip</code><br>10、下载最新版本的泰拉瑞亚服务包（用wget太慢，我先用putty下到本地然后用上传到服务器）</p><p><img src="/images/terraria/image-20210117130858133.png" alt=""></p><p>11、将下载好的压缩包解压到bin文件夹<br><code>unzip terraria-server-1412.zip -d/opt/terraria/bin</code><br>12、将配置文件拷贝到泰拉瑞亚文件夹的根目录。<br><code>cp -p /opt/terraria/bin/1412/Windows/serverconfig.txt /opt/terraria/</code><br>13、编辑拷贝过来的配置文档。<br> <code>vim /opt/terraria/serverconfig.txt</code><br>14、在文件的末尾加上</p><pre class="line-numbers language-none"><code class="language-none">world=/opt/terraria/Worlds/你的世界.wldautocreate=2worldname=你的世界difficulty=0maxplayers=4password=你的密码worldpath=/opt/terraria/Worlds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<br>autocreate 是没有发现世界自动生成世界的大小 1、2、3分别对应小、中、大<br>difficulty 对应的是0为普通，1为专家<br>maxplayers是最大人数<br>15、给运行文件赋予运行权限。<br><code>chmod 777 /opt/terraria/bin/1412/Linux/TerrariaServer.bin.x86_64</code><br>16、启动服务器。<br><code>cd /opt/terraria/bin/1412/Linux &amp;&amp; ./TerrariaServer.bin.x86_64 -config/opt/terraria/serverconfig.txt</code></p><p>(怎么感觉1.4不一样了，在这时候才创建世界，好像14步是多余的)<br>17、退出服务器程序<br><code>:exit</code><br>18、将之前添加的一段话中三行代码前面加上#号，使其失效<br><code>vim /opt/terraria/serverconfig.txt</code></p><p>(看起来好像也没必要了，因为刚刚启动服务器时也配置了)</p><p>服务器只有在服务端输入save命令之后才会保存地图数据。</p><p><code>save</code></p><hr><p>发现启动服务器后我博客上不去了。。。。</p><p>好像得重启一下nginx服务</p><p><code>systemctl restart nginx.service</code></p><p>screen常用命令：</p><pre class="line-numbers language-none"><code class="language-none">screen -S yourname -&gt; 新建一个叫yourname的sessionscreen -ls -&gt; 列出当前所有的sessionscreen -r yourname -&gt; 回到yourname这个sessionscreen -d yourname -&gt; 远程detach某个sessionscreen -d -r yourname -&gt; 结束当前session并回到yourname这个sessionctrl+a d  暂时中断会话<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hackergame 2020 尝试</title>
      <link href="2021/01/15/hackergame-2020-attempt/"/>
      <url>2021/01/15/hackergame-2020-attempt/</url>
      
        <content type="html"><![CDATA[<p>今天偶然刷到Hackergame的相关内容，以前从来不知道有这种东西，准备尝试做题并且学习一下。</p><p>网址：<a href="https://hack.lug.ustc.edu.cn/">https://hack.lug.ustc.edu.cn/</a></p><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116000201094.png" alt=""></p><p>要求提取一个flag，但是滑条的步长为0.00001，js代码还会把1略过，不可能滑到1</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116000645177.png" alt="">点击提交发现是用get请求，URL变为<code>http://202.38.93.111:10000/?number=0.01145</code>，可直接改为1<br>也可在控制台直接使用<code>$('#number')[0].value = 1;</code></p><h2 id="猫咪问答"><a href="#猫咪问答" class="headerlink" title="猫咪问答++"></a>猫咪问答++</h2><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116001306225.png" alt=""></p><p>1.不知道</p><p>2.搜索找到<code>https://tools.ietf.org/html/rfc1149</code>得到值：256</p><p>3.查找网络得到值：9</p><p>4.查找地图得到值：9</p><p>5.查找网络得到值：17098</p><p>1.参考<code>https://www.cnblogs.com/pu369/p/12201707.html</code>和<code>https://blog.skk.moe/post/hackergame-2020-write-up</code><br>得到：12</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">23</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'q1'</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'q2'</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'q3'</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'q4'</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'q4'</span><span class="token punctuation">,</span> <span class="token number">17098</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://202.38.93.111:10001/'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      body<span class="token operator">:</span> formData<span class="token punctuation">,</span>      method<span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">resp</span> <span class="token operator">=&gt;</span> resp<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">text</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>text<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">'没有全部答对，不能给你 flag'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2048"><a href="#2048" class="headerlink" title="2048"></a>2048</h2><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116011522357.png" alt=""></p><p>游戏很好玩，不过我是菜鸟，通过不了</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116012914685.png" alt=""></p><p>拦截到了一个请求，打开js</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/hackergame-2020-attempt/image-20210116013020557.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/hackergame-2020-attempt/image-20210116013632841.png" alt=""></p><p>访问<code>http://202.38.93.111:10005/getflxg?my_favorite_fruit=banana</code>通过</p><h2 id="一闪而过的-Flag"><a href="#一闪而过的-Flag" class="headerlink" title="一闪而过的 Flag"></a>一闪而过的 Flag</h2><blockquote><p>程序每次运行时隐约可见黑色控制台上有 flag 一闪而过。</p></blockquote><p>把文件拖入cmd即可</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116014242933.png" alt=""></p><h2 id="从零开始的记账工具人"><a href="#从零开始的记账工具人" class="headerlink" title="从零开始的记账工具人"></a>从零开始的记账工具人</h2><blockquote><p>如同往常一样，你的 npy 突然丢给你一个购物账单：“我今天买了几个小玩意，你能帮我算一下一共花了多少钱吗？”</p><p>你心想：<del>又双叒叕要开始吃土了</del> 这不是很简单吗？电子表格里面一拖动就算出来了</p><p>只不过拿到账单之后你才注意到，似乎是为了剁手时更加的安心，这次的账单上面的金额全使用了中文大写数字</p><p><strong>注意：请将账单总金额保留小数点后两位，放在 <code>flag{}</code> 中提交，例如总金额为 123.45 元时，你需要提交 <code>flag{123.45}</code></strong></p></blockquote><p>文件已经下载不了了。。。。。</p><h2 id="超简单的世界模拟器"><a href="#超简单的世界模拟器" class="headerlink" title="超简单的世界模拟器"></a>超简单的世界模拟器</h2><blockquote><p>你知道生命游戏（Conway’s Game of Life）吗？</p><p>你的任务是在生命游戏的世界中，复现出蝴蝶扇动翅膀，引起大洋彼岸风暴的效应。</p><p>通过改变左上角 15x15 的区域，在游戏演化 200 代之后，如果被特殊标注的正方形内的细胞被“清除”，你将会得到对应的 flag：</p><p>“清除”任意一个正方形，你将会得到第一个 flag。同时“清除”两个正方形，你将会得到第二个 flag。</p><p>注: 你的输入是 15 行文本，每行由 15 个 0 或者 1 组成，代表该区域的内容。</p></blockquote><p>瞎试了几次居然过了</p><h2 id="从零开始的火星文生活"><a href="#从零开始的火星文生活" class="headerlink" title="从零开始的火星文生活"></a>从零开始的火星文生活</h2><blockquote><p>脦脪鹿楼脝脝脕脣 拢脠拢谩拢茫拢毛拢氓拢貌拢莽拢谩拢铆拢氓 碌脛路镁脦帽脝梅拢卢脥碌碌陆脕脣脣眉脙脟碌脛 拢忙拢矛拢谩拢莽拢卢脧脰脭脷脦脪掳脩 拢忙拢矛拢谩拢莽 路垄赂酶脛茫拢潞<br>拢忙拢矛拢谩拢莽拢没拢脠拢麓拢枚拢鲁拢脽拢脝拢玫拢脦拢脽拢梅拢卤拢脭拢猫拢脽拢鲁拢卯拢茫拢掳拢盲拢卤拢卯拢莽拢脽拢麓拢脦拢盲拢脽拢盲拢鲁拢茫拢掳拢脛拢卤拢卯拢脟拢脽拢鹿拢帽拢脛拢虏拢脪拢赂拢猫拢贸拢媒<br>驴矛脠楼卤脠脠眉脝陆脤篓脤谩陆禄掳脡拢隆<br>虏禄脪陋脭脵掳脩脮芒路脻脨脜脧垄脳陋路垄赂酶脝盲脣没脠脣脕脣拢卢脪陋脢脟卤禄路垄脧脰戮脥脭茫赂芒脕脣拢隆</p></blockquote><p>好家伙，搞了半天没解出来，不过得到了常用乱码表</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116021901318.png" alt="这可得好好记得"></p><p>标准答案：</p><blockquote><p>下载附件之后如直接用 GBK 打开，那就真的是题面里说的“夹杂着日语和数字的火星文”了。恭喜掉进坑，乱码又多了一层（逃</p><p>用 UTF-8 打开，看到形如“脦脪鹿楼”的文本，推断是上图中的“古文码”乱码。但是“古文码”明明是“以 GBK 方式读取 UTF-8 编码”造成的，看来“脦脪鹿楼”本来应当是 GBK下看到的结果，却又被存成了 UTF-8。所以第一步是用 GBK 重新编码文本“脦脪鹿楼…”。</p><p>然后用 UTF-8 打开，看到形如“ÎÒ¹¥ÆÆÁË”的文本，推断是上图中的“拼音码”乱码。“拼音码”是“以 ISO8859-1 方式读取 GBK 编码”，而现在文本的编码是 UTF-8。所以接下应当用 ISO8859-1 重新编码文本“ÎÒ¹¥ÆÆÁË…”。</p><p>然后用 GBK 打开，就能看到可读的汉字和 flag 了（原始编码确实是 GBK 呢！）。不过这里的 flag 全部是从 ASCII 字符转成的全角字符，不能直接复制使用。可以手动替换成 ASCII 字符，或者用其他简便方法变回 ASCII 字符。</p><p><a href="https://github.com/USTC-Hackergame/hackergame2020-writeups/blob/master/official/从零开始的火星文生活/src/generate_and_solve.py">源代码</a> 中也给出了一个全角-&gt;半角的函数。</p><p>方法一（不写代码）</p><p>例如用 VSCode 的“Select Encoding”功能。</p><p>步骤（开始时 UTF-8 打开题目附件）：</p><ol><li>Save with Encoding -&gt; GBK</li><li>Reopen with Encoding -&gt; UTF-8</li><li>Save with Encoding -&gt; ISO8859-1</li><li>Reopen with Encoding -&gt; GBK</li></ol></blockquote><p>后面的感觉自己也不会做了，先这样，有时间再看吧</p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Hackergame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++语言程序设计（第六章）</title>
      <link href="2021/01/11/cpp2/"/>
      <url>2021/01/11/cpp2/</url>
      
        <content type="html"><![CDATA[<center><span style="color:blue;font-size:15px">2021/1/10</span></center><h2 id="第6章-数组、指针与字符串"><a href="#第6章-数组、指针与字符串" class="headerlink" title="第6章 数组、指针与字符串"></a>第6章 数组、指针与字符串</h2><h3 id="6-1-数组"><a href="#6-1-数组" class="headerlink" title="6.1 数组"></a>6.1 数组</h3><h4 id="6-1-2-数组的存储与初始化"><a href="#6-1-2-数组的存储与初始化" class="headerlink" title="6.1.2 数组的存储与初始化"></a>6.1.2 数组的存储与初始化</h4><p><strong>1.数组的存储</strong><br>数组元素在内存中是顺序、连续存储的。数组元素在内存中占据一组连续的存储单元，逻辑上相邻的元素在物理地址上也是相邻的。 </p><p><strong>2.数组的初始化</strong><br>数组的初始化就是在声明数组时给部分或全部元素赋值。<br>声明数组时如果列成全部元素的初值，可以不用说明元素个数：<br><em>int a[]={1,1,1};</em><br>当然，也可以只对元素中的部分元素进行初始化，这种初始化只能针对前若干元素：<br><em>float fa[5]={1.0, 2.0, 3.0};</em></p><p><strong>细节：</strong>当指定的初值个数小于数组大小时， 剩下的数组元素会被赋予0值。若定义数组时没有指定任何一个元素的初值，对于静态生存期的数组，每个元素仍然会被赋予0值；但对于动态生存期的数组，每个元素的初值都是不确定的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//动态生存期</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210110111504396.png" alt="动态生存期"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//静态生存期</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210110111610294.png" alt="静态生存期"></p><center><span style="color:blue;font-size:15px">2021/1/11</span></center><h4 id="6-1-3-数组作为函数参数"><a href="#6-1-3-数组作为函数参数" class="headerlink" title="6.1.3 数组作为函数参数"></a>6.1.3 数组作为函数参数</h4><p>使用数组名传递数据时，传递的是地址。<br><strong>细节：</strong>把数组作为参数时，一般不指定数组第一维的大小，即使指定，也会被忽略。</p><h4 id="6-1-4-对象数组"><a href="#6-1-4-对象数组" class="headerlink" title="6.1.4 对象数组"></a><strong>6.1.4 对象数组</strong></h4><p>数组的元素不仅可以是基本数据类型，也可以是自定义类型。</p><h4 id="6-1-5-程序实例"><a href="#6-1-5-程序实例" class="headerlink" title="6.1.5 程序实例"></a>6.1.5 程序实例</h4><p>例6-4 利用Point类进行点的线性拟合。</p><p>考虑一个用n个数据点拟合成直线的问题，直线模型为</p><script type="math/tex; mode=display"> y(x)=ax+b</script><p>这个问题称为线性回归。设变量y随自变量x变化，给定n组观测数据（$x_i,y_i$)，用直线来拟合这些点，其中a，b是直线的斜率和截距，称为回归系数。</p><p>为确定回归系数，通常采用最小二乘法，即要使下式达到最小。</p><script type="math/tex; mode=display">Q=\sum_{i=0}^{n-1}{[y_i-(ax_i+b)]^2}</script><p>根据极值定理，a和b满足下列方程：</p><script type="math/tex; mode=display">\frac{\partial Q}{\partial a}=2\sum_{i=0}^{n-1}{[y_i-(ax_i+b)](-x_i)}=0</script><script type="math/tex; mode=display">\frac{\partial Q}{\partial b}=2\sum_{i=0}^{n-1}{[y_i-(ax_i+b)](-1)}=0</script><p>解得：</p><script type="math/tex; mode=display">a=\frac{L_{xy}}{L_{xx}}=\frac{\sum_{i=0}^{n-1}{(x_i-\overline{x})(y_i-\overline{y})}}{\sum_{i=0}^{n-1}{(x_i-\overline{x})^2}}</script><script type="math/tex; mode=display">b=\overline{y}-a\overline{x}</script><p>相关系数r可以判断一组数据线性相关的密切程度，定义为：</p><script type="math/tex; mode=display">r=\frac{L_{xy}}{\sqrt{L_{xx}L_{yy}}}</script><script type="math/tex; mode=display">L_{yy}=\sum_{i=0}^{n-1}{(y_i-\overline{y})^2}</script><p>r的绝对值越接近1，表示数据的线性关系越好</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//Point.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_POINT_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">_POINT_H</span></span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">float</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">float</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">float</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_4.cpp 最小二乘法做线性拟合</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Point.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//直线线性担合,pointe为各点nPoint为点数</span><span class="token keyword">float</span> <span class="token function">lineFit</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point points<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> nPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">float</span> avgX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> avgY <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">float</span> lxx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> lyy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> lxy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nPoint<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>avgX <span class="token operator">+=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> nPoint<span class="token punctuation">;</span>avgY <span class="token operator">+=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> nPoint<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nPoint<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>lxx <span class="token operator">+=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> avgX<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> avgX<span class="token punctuation">)</span><span class="token punctuation">;</span>lyy <span class="token operator">+=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> avgY<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> avgY<span class="token punctuation">)</span><span class="token punctuation">;</span>lxy <span class="token operator">+=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> avgX<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> avgY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>cout<span class="token operator">&lt;&lt;</span> <span class="token string">"This line can be fitted by y=ax+b."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a="</span> <span class="token operator">&lt;&lt;</span> lxy <span class="token operator">/</span> lxx <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token comment">//输出回归系数a</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b="</span> <span class="token operator">&lt;&lt;</span> avgY <span class="token operator">-</span> avgX <span class="token operator">*</span> lxy <span class="token operator">/</span> lxx <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出回归系数b</span><span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>lxy <span class="token operator">/</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>lxx <span class="token operator">*</span> lyy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回相关系数r</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Point p<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">46</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">67</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">75</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">float</span> r <span class="token operator">=</span> <span class="token function">lineFit</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Line coefficient r="</span> <span class="token operator">&lt;&lt;</span> r <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210111162503679.png" alt="结果"></p><p>这个程序的缺点是可以处理的数据点数是固定的，由Point类对象数组的大小决定，这在实际使用中是一个很大的遗憾，在后面的章节中，会对本程序进行改造，以适应任意多个数据的处理。</p><h3 id="6-2-指针"><a href="#6-2-指针" class="headerlink" title="6.2 指针"></a>6.2 指针</h3><h4 id="6-2-1-内存空间的访问方式"><a href="#6-2-1-内存空间的访问方式" class="headerlink" title="6.2.1 内存空间的访问方式"></a>6.2.1 内存空间的访问方式</h4><p>每个字节是一个基本内存单元，有一个地址。<br>在C++中有专门用来存放内存单元地址的变量类型，这就是指针类型。</p><h4 id="6-2-2-指针变量的声明"><a href="#6-2-2-指针变量的声明" class="headerlink" title="6.2.2 指针变量的声明"></a>6.2.2 指针变量的声明</h4><p><strong>疑问：</strong>为什么在声明指针变量时要指出它所指的对象是什么类型呢？<br>限定对变量可以进行的运算及其运算规则。</p><h4 id="6-2-3-与地址相关的运算”-”和“-amp-”"><a href="#6-2-3-与地址相关的运算”-”和“-amp-”" class="headerlink" title="6.2.3 与地址相关的运算”*”和“&amp;”"></a>6.2.3 与地址相关的运算”*”和“&amp;”</h4><p>“*”称为指针运算符，也称解析（dereference），表示获取指针所指向的变量的值。<br>“&amp;”称为取地址运算符，用来得到一个对象的地址。<br>必须注意，“*”和“&amp;”在声明语句中和执行语句中其含义是不同的，它们作为一元运算符和作为二元运算符时含义也是不同的。</p><h4 id="6-2-4-指针的赋值"><a href="#6-2-4-指针的赋值" class="headerlink" title="6.2.4 指针的赋值"></a>6.2.4 指针的赋值</h4><p>可以使用一个已经赋值的指针去初始化另一个指针，这就是说，可以使多个指针指向同一个变量。<br>数组名称实际上就是一个不能被赋值的指针，即指针常量。</p><p>关于指针的类型，还应该注意以下几点。<br>（1）可以声明<strong>指向常量的指针</strong>，此时不能通过指针来改变所指对象的值，但指针本身可以改变，可以指向另外的对象。例如:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>pl<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment">//pl是指向常量的指针</span><span class="token keyword">int</span> b<span class="token punctuation">;</span>pl<span class="token operator">=</span><span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token comment">//正确，pl本身的值可以改变</span><span class="token operator">*</span>pl<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//编译时出错，不能通过pl改变所指的对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）可以声明<strong>指针类型的常量</strong>，这时指针本身的值不能被改变。例如:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p2<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>p2<span class="token operator">=</span><span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token comment">//错误，p2是指针常量，值不能改变</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（3）一般情况下，指针的值只能赋给相同类型的指针。但是有一种特殊的 <strong>void类型指针</strong>，可以存储任何类型的对象地址，就是说任何类型的指针都可以赋值给void类型的指针变量。经过使用类型显式转换，通过void类型的指针便可以访问任何类型的数据。<br><strong>提示：</strong>void 指针一般只在指针所指向的数据类型不确定时使用。</p><h4 id="6-2-5-指针运算"><a href="#6-2-5-指针运算" class="headerlink" title="6.2.5 指针运算"></a>6.2.5 指针运算</h4><p>*(pl + nl)表示pI当前所指位置后方第nl个数的内容，它也可以写作pI[nl],这与*(pl + nl)的写法是完全等价的，同样，*(pl - nl)也可以写作pI[-nl]。</p><p><img src="/images/cpp2/image-20210111181928035.png" alt="指针的算术运算"></p><p><strong>提示：</strong>指针算术运算的不慎使用会导致指针指向无法预期的地址，从而造成不确定的结果，因此指针的算术运算一定要慎用。</p><p>指针变量的关系运算指的是指向相同类型数据的指针之间进行的关系运算。如果两个相同类型的指针相等，就表示这两个指针是指向同一个地址。不同类型的指针之间或指针与非0整数之间的关系运算是毫无意义的。但是指针变量可以和整数0进行比较，0专用于表示空指针，也就是一个不指向任何有效地址的指针。</p><p><strong>细节：</strong>空指针也可以用NULL来表示，NULL是一个在很多头文件中都有定义的宏，被定义为0。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>习惯：</strong>如果不便于用一个有效地址给一个指针变量赋初值，那么应当用0作为它的初值，从而避免指向不确定地址的指针出现。</p><h4 id="6-2-6-用指针处理数组元素"><a href="#6-2-6-用指针处理数组元素" class="headerlink" title="6.2.6 用指针处理数组元素"></a>6.2.6 用指针处理数组元素</h4><p><strong>细节：</strong>把数组作为函数的形参，等价于把指向数组元素类型的指针作为形参。例如，下面3个写法，出现在形参列表中都是等价的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="6-2-7-指针数组"><a href="#6-2-7-指针数组" class="headerlink" title="6.2.7 指针数组"></a>6.2.7 指针数组</h4><p>如果一个数组的每个元素都是指针变量，这个数组就是指针数组。指针数组的每个元素都必须是同类型的指针。例如 int *pa[3];声明了一个int类型的指针数组pa，其中有3个元素，每个元素都是一个指向int类型数<br>据的指针。由于指针数组的每个元素都是一个指针，必须先赋值后引用，因此，声明数组之后，对指针元素赋初值是必不可少的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_8.cpp 利用指针数组输出单位矩阵</span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> line1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> line2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> line3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义整型指针数组并初始化</span><span class="token keyword">int</span><span class="token operator">*</span> pLine<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> line1<span class="token punctuation">,</span>line2<span class="token punctuation">,</span> line3 <span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Matrix test:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> pLine<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210111235748905.png" alt="指针数组与二维数组的区别"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_9.cpp 二维数组举例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> array2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">33</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>array2 <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><span style="color:blue;font-size:15px">2021/1/12</span></center><h4 id="6-2-8-用指针作为函数参数"><a href="#6-2-8-用指针作为函数参数" class="headerlink" title="6.2.8 用指针作为函数参数"></a>6.2.8 用指针作为函数参数</h4><p>例6-10：读入3个浮点数，将整数部分和小数部分分别输出。<br>程序由主函数和一个进行浮点数分解的子函数组成，浮点数在子函数中分解之后，将整数部分和小数部分传递回主函数中输出。可以想象，如果直接使用整型和浮点型变量，形参在子函数中的变化根本就无法传递到主函数，因此采用指针作为函数的参数。源代码如下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6 10.cpp 用指针作为函数参数</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//将实数x分成整数部分和小数部分，形参intPart、 fracPart是指针</span><span class="token keyword">void</span> <span class="token function">splitFloat</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> intPart<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span> fracPart<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>intPart <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//取x的整数部分</span><span class="token operator">*</span>fracPart <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token operator">*</span>intPart<span class="token punctuation">;</span><span class="token comment">//取x的小数部分</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter 3 float point numbers:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">float</span> x<span class="token punctuation">,</span>f<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> x<span class="token punctuation">;</span><span class="token function">splitFloat</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//变量地址作为实参</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Integer Part="</span><span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span><span class="token string">" Fraction Part="</span><span class="token operator">&lt;&lt;</span> f<span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个程序中，使用引用作为形参也可以达到同样目的。</p><h4 id="6-2-9-指针型函数"><a href="#6-2-9-指针型函数" class="headerlink" title="6.2.9 指针型函数"></a>6.2.9 指针型函数</h4><p>除了void 类型的函数之外，函数在调用结束之后都要有返回值，指针也可以是函数的返回值。当一个函数的返回值是指针类型时，这个函数就是指针型函数。使用指针型函数的最主要目的就是要在函数结束时把大量的数据从被调函数返回到主调函数中，而通常非指针型函数调用结束后，只能返回一个变量或者对象。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">funcion</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    函数体<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="6-2-10-指向函数的指针"><a href="#6-2-10-指向函数的指针" class="headerlink" title="6.2.10 指向函数的指针"></a>6.2.10 指向函数的指针</h4><p>在程序运行时，不仅数据要占据内存空间，执行程序的代码也被调入内存并占据一定的空间。每一个函数都有函数名，实际上这个函数名就表示函数的代码在内存中的起始地址。由此看来，调用函数的通常形式“函数名(参数表)”的实质就是“函数代码首地址(参数表)”。</p><p>函数指针就是专门用来存放函数代码首地址的变量。在程序中可以像使用函数名一样使用指向函数的指针来调用函数。也就是说一旦函数指针指向了某个函数，它与函数名便具有同样的作用。函数名在表示函数代码起始地址的同时，也包括函数的返回值类型和参数的个数、类型、排列次序等信息。因此在通过函数名调用函数时，编译系统能够自动检查实参与形参是否相符，用函数的返回值参与其他运算时，能自动进行类型一致性检查。</p><p>声明一个函数指针时，也需要说明函数的返回值、形式参数列表,其一般语法如下:<br>数据类型(*函数指针名) (形参表)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_11.cpp函数指针实例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">printStuff</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"This is the print stuff function."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token keyword">float</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The data to be listed is "</span> <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">printFloat</span><span class="token punctuation">(</span><span class="token keyword">float</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The data to be printed is "</span> <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> <span class="token keyword">float</span> PI <span class="token operator">=</span> <span class="token number">3.14159f</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">float</span> TWO_PI <span class="token operator">=</span> PI <span class="token operator">*</span> <span class="token number">2.0f</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>functionPointer<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printStuff</span><span class="token punctuation">(</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span>functionPointer <span class="token operator">=</span> printStuff<span class="token punctuation">;</span><span class="token function">functionPointer</span><span class="token punctuation">(</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span>functionPointer <span class="token operator">=</span> printMessage<span class="token punctuation">;</span><span class="token function">functionPointer</span><span class="token punctuation">(</span>TWO_PI<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">functionPointer</span><span class="token punctuation">(</span><span class="token number">13.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>functionPointer <span class="token operator">=</span> printFloat<span class="token punctuation">;</span><span class="token function">functionPointer</span><span class="token punctuation">(</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printFloat</span><span class="token punctuation">(</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-2-11-对象指针"><a href="#6-2-11-对象指针" class="headerlink" title="6.2.11 对象指针"></a>6.2.11 对象指针</h4><h5 id="1-对象指针的一般概念"><a href="#1-对象指针的一般概念" class="headerlink" title="1.对象指针的一般概念"></a>1.对象指针的一般概念</h5><p>和基本类型的变量一样，每一个对象在初始化之后都会在内存中占有一定的空间。因此，既可以通过对象名，也可以通过对象地址来访问一个对象。虽然对象同时包含了数虽然对象同时包含了数据和函数两种成员，但与一般变量略有不同，对象所占据的内存空间只是用于存放数据成员的，函数成员不在每一个对象中存储副本。对象指针就是用于存放对象地址的变量。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">对象指针名<span class="token operator">-&gt;</span>成员名<span class="token punctuation">(</span><span class="token operator">*</span>对象指针名<span class="token punctuation">)</span><span class="token punctuation">.</span>成员名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两种访问形式是等价的。</p><h5 id="2-this指针"><a href="#2-this指针" class="headerlink" title="2.this指针"></a>2.this指针</h5><p>this指针是一个隐含于每个类的非静态成员函数中的特殊指针(包括构造函数和析构函数)，它用于指向正在被成员函数操作的对象。</p><p><strong>细节：</strong>this指针实际上是类成员函数的一个隐含参数。 在调用类的成员函数时，目的对象的地址会自动作为该参数的值，传递给被调用的成员函数，这样被调函数就能够通过this指针来访问目的对象的数据成员。对于常成员函数来说，这个隐含的参数是常指针类型的。</p><p>this是一个指针常量，对于常成员函数，this同时又是一个指向常量的指针。在成员函数中， 可以使用*this来标识正在调用该函数的对象。</p><p><strong>提示：</strong>当局部作用域中声明了与类成员同名的标识符时，对该标识符的直接引用代表的是局部作用城中所声明的标识符，这时为了访问该类成员，可以通过this指针。</p><h5 id="3-指向类的非静态成员的指针"><a href="#3-指向类的非静态成员的指针" class="headerlink" title="3.指向类的非静态成员的指针"></a>3.指向类的非静态成员的指针</h5><p>类的成员自身也是一些变量、函数或者对象等，因此也可以直接将它们的地址存放到一个指针变量中，这样，就可以使指针直接指向对象的成员 ，进而可以通过这些指针访问对象的成员。</p><p>声明指针语句的一般形式为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">类型说明符 类名<span class="token operator">::</span><span class="token operator">*</span>指针名<span class="token punctuation">;</span>  <span class="token comment">//声明指向数据成员的指针</span>类型说明符 <span class="token punctuation">(</span>类名<span class="token operator">::</span> <span class="token operator">*</span>指针名<span class="token punctuation">)</span><span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//声明指向函数成员的指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对成员指针赋值的一般语法形式为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">指针名<span class="token operator">=</span><span class="token operator">&amp;</span>类名<span class="token operator">::</span>数据成员名<span class="token punctuation">;</span>   <span class="token comment">//对数据成员指针赋值</span>指针名<span class="token operator">=</span><span class="token operator">&amp;</span>类名<span class="token operator">::</span>函数成员名<span class="token punctuation">;</span>  <span class="token comment">//对函数成员赋值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意：</strong>对类成员取地址时，也要遵守访问权限的约定，也就是说，在一个类的作用域之外不能够对它的私有成员取地址。</p><p><strong>注意：</strong>常成员函数与普通成员函数具有不同的类型，因此能够被常成员函数赋值的指针，需要在声明时明确写出const关键字。</p><p>类是通过对象而实例化的，在声明类的对象时才会为具体的对象分配内存空间，这时只要将对象在内存中的起始地址与成员指针中存放的相对偏移结合起来就可以访问到对象的数据成员了。访问数据成员时，这种结合可通过以下两种语法形式实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">对象名<span class="token punctuation">.</span><span class="token operator">*</span>类成员指针名对象指针名<span class="token operator">-&gt;</span><span class="token operator">*</span>类成员指针名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一个普通函数的函数名就表示它的起始地址，将起始地址赋给指针，就可以通过指针调用函数。类的成员函数虽然并不在每个对象中复制一份副本，但是由于需要确定this指针，因而必须通过对象来调用非静态成员函数。因此经过上述对成员函数指针赋值以后，也还不能用指针直接调用成员函数，而是需要首先声明类的对象，然后用以下形式的语句利用指针调用成员函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">(</span>对象名<span class="token punctuation">.</span><span class="token operator">*</span>类成员指针名<span class="token punctuation">)</span><span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span class="token punctuation">(</span>对象指针名<span class="token operator">-&gt;</span><span class="token operator">*</span>类成员指针名<span class="token punctuation">)</span><span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_13.cpp 指向类的非静态成员的指针 &amp; 访问对象的共有函数的不同方法</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Point <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Point<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span>Point<span class="token operator">::</span> <span class="token operator">*</span> funcPtr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Point<span class="token operator">::</span>getX<span class="token punctuation">;</span><span class="token comment">//定义成员函数指针并初始化</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token operator">*</span>funcPtr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//(1)使用成员函数指针和对象名访问成员函数</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>p1<span class="token operator">-&gt;</span><span class="token operator">*</span>funcPtr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//(2)使用成员函数指针和对象指针访问成员函数</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//(3)使用对象名访问成员函数</span>cout <span class="token operator">&lt;&lt;</span> p1<span class="token operator">-&gt;</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//(4)使用对象指针访问成员函数</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-指向类的静态成员的指针"><a href="#4-指向类的静态成员的指针" class="headerlink" title="4.指向类的静态成员的指针"></a>4.指向类的静态成员的指针</h5><p>对类的静态成员的访问是不依赖于对象的，因此可以用普通的指针来指向和访问静态成员。</p><center><span style="color:blue;font-size:15px">2021/1/13</span></center><h3 id="6-3-动态内存分配"><a href="#6-3-动态内存分配" class="headerlink" title="6.3 动态内存分配"></a>6.3 动态内存分配</h3><p>在C++中，动态内存分配技术可以保证程序在运行过程中按照实际需要申请适量的内存，使用结束后还可以释放，这种在程序运行过程中申请和释放的存储单元也称为堆对象，申请和释放过程一般称为建立和删除。<br>在C++程序中建立和删除堆对象使用两个运算符: new和delete。<br>运算符new的功能是动态分配内存，或者称为动态创建堆对象,语法形式为:<br>new 数据类型(初始化参数列表);<br>该语句在程序运行过程中申请分配用于存放指定类型数据的内存空间，并根据初始化参数列表中给出的值进行初始化。如果内存申请成功，new运算便返回一个指向新分配内存首地址的类型的指针，可以通过这个指针对堆对象进行访问；如果申请失败，会抛出异常(有关异常,将在第12章介绍)。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> point<span class="token punctuation">;</span>point<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>细节：</strong>在用new 建立一个类的对象时，如果该类存在用户定义的默认构造函数，则“new T”和“new T()”这两种写法的效果是相同的，都会调用这个默认构造函数。但若用户未定义默认构造函数,使用“new T”创建对象时，会调用系统生成的隐含的默认构造函数;使用“new T()”创建对象时，系统除了执行默认构造函数会执行的那些操作外，还会为基本数据类型和指针类型的成员用0赋初值，而且这一过程是递归的。 也就是说，如果该对象的某个成员对象也没有用户定义的默认构造函数，那么对该成员对象的基本数据类型和指针类型的成员，同样会被以0赋初值。(基本数据类型和数组也一样)</p><p>运算符delete用来删除由new建立的对象，释放指针所指向的内存空间。格式为:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">delete</span> 指针名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：</strong>用new分配的内存，必须用delete 加以释放，否则会导致动态分配的内存无法回收，使得程序占据的内存越来越大，这叫做“内存泄漏”。</p><p>使用运算符new也可以创建<strong>数组类型</strong>的对象，创建一维数组的语法形式为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">new</span> 类型名 <span class="token punctuation">[</span>数组长度<span class="token punctuation">]</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是用new建立的数组,用delete删除时在指针名前面要加“[]”,格式如下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> 指针名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><center><span style="color:blue;font-size:15px">2021/1/14</span></center><p>在动态数组类中，通过类的成员函数访问数组元素，可以在每次访问之前检查一下下标是否越界，使得使得数组下标越界的错误能够及早被发现<strong><span style="color:green;font-size:15px">(实际应用可直接使用vector)</span></strong> 。这种检查，可以通过C++的assert来进行。assert 只在调试模式下生效，一般用assert 只是检查程序本身的逻辑错误，而用户的不当输入造成的错误，则应当用其他方式加以处理。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_18.cpp 动态数组类   将动态数组封装成一个类</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cassert&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Default Constructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Constructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Destructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">int</span> newX<span class="token punctuation">,</span> <span class="token keyword">int</span> newY<span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> newX<span class="token punctuation">;</span>y <span class="token operator">=</span> newY<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ArrayOfPoints</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">ArrayOfPoints</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">size</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>points <span class="token operator">=</span> <span class="token keyword">new</span> Point<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">ArrayOfPoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Deleting..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> points<span class="token punctuation">;</span><span class="token punctuation">}</span>Point <span class="token operator">&amp;</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//返回一个对象的引用，确保正确更改</span><span class="token function">assert</span><span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果数组下标越界，程序终止</span><span class="token keyword">return</span> points<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>Point<span class="token operator">*</span> points<span class="token punctuation">;</span><span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> count<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please enter the count of points: "</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> count<span class="token punctuation">;</span>ArrayOfPoints <span class="token function">points</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建对象数组</span>points<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问数组元索的成员</span>points<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问数组元素的成员</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210114012043817.png" alt="运行结果"></p><p>创建和删除对象数组的过程都由ArrayOfPoints类的构造函数和析构函数完成。这虽然使main()函数更为简洁，但是对数组元素的访问形式“points.element(0)”却显得啰嗦。如果希望像使用普通数组样,通过下标操作符“[ ]”来访问数组元素，就需要对下标操作符进行重载，这将在第9章详细介绍。</p><p>用new操作也可以创建多维数组，其中第1维长度可以是任何结果为正整数的表达式，而其他各维数组长度必须是结果为正整数的常量表达式。如果内存申请成功.new运算返回一个指向新分配内存的首地址的指针。例如，下列语句</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span><span class="token operator">*</span> fp<span class="token punctuation">;</span>fp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>会产生错误，正确的写法应该是：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span><span class="token punctuation">(</span><span class="token operator">*</span>cp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>cp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如此得到的指针cp，既可以作为指针使用，也可以像一个三维数组名一样使用。</p><h3 id="6-4-用vector创建数组对象"><a href="#6-4-用vector创建数组对象" class="headerlink" title="6.4 用vector创建数组对象"></a>6.4 用vector创建数组对象</h3><p>无论是静态数组，还是用new动态创建的数组，都难以检测下标越界的错误，在实际应用中常常造成困扰。例6-18 提供了一个很好的例子，它通过将动态数组封装成-一个类，允许在调试状态下访问数组元素时检查下标越界的错误。然而，它只能表示Point类型的动态数组，若要处理其他类型的动态数组，还需创建新的动态数组类，这是很烦琐的重复性工作，事实上,C++标准库也提供了被封装的动态数组一vector，而且这种被封装的数组可以具有各种类型，这就使我们免去了那些重复性工作。vector不是一个类，而是个类模板。模板的概念将在第9章详细介绍，读者通过本章的学习，只需在形式上记住vector的使用方式。</p><p>向量 <strong>vector</strong> 是一种对象实体, 能够容纳许多其他类型相同的元素, 因此又被称为容器。 与string相同，vector 同属于STL(Standard Template Library，标准模板库)中的一种自定义的数据类型，可以广义上认为是数组的增强版。用vector定义动态数组的形式为:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>元素类型<span class="token operator">&gt;</span>数组对象名<span class="token punctuation">(</span>数组长度，元素初值<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>细节：</strong>与普通数组不同的是，用vector定义的数组对象的所有元素都会被初始化。如果数组的元素类型为基本数据类型，则所有元素都会被以0初始化；如果数组元素为类类型，则会调用类的默认构造函数初始化。因此如果以此形式定义的vector动态数组，需要保证作为数组元素的类具有默认构造函数。另外,初值也可以自己指定，但只能为所有元素指定相同初值。</p><p>对vector数组对象元素的访问方式，与普通数组具有相同的形式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">数组对象名<span class="token punctuation">[</span>下标表达式<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是vector数组对象的名字表示的就是一个数组对象，而非数组的首地址，因为数组对象不是数组，而是封装了数组的对象。vector定义的数组对象具有个重要的成员函数size()，它会返回数组的大小。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_20.cpp vector应用举例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//计算数组arr中元素的平均值</span><span class="token keyword">double</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>sum <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> sum <span class="token operator">/</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">unsigned</span> n<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"n= "</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token function">arr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please input "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">" real numbers:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>cin <span class="token operator">&gt;&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Average="</span> <span class="token operator">&lt;&lt;</span> <span class="token function">average</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vector还具有很多其他强大的功能，例如它的大小可以扩展，这些特性都将在第10章详细介绍。</p><center><span style="color:blue;font-size:15px">2021/1/15</span></center><h3 id="6-5-深复制和浅复制"><a href="#6-5-深复制和浅复制" class="headerlink" title="6.5 深复制和浅复制"></a>6.5 深复制和浅复制</h3><p>虽然第4章已经介绍过复制构造函数，但是在此前大多数简单例题中都不需要特别编写复制构造函数，隐含的复制构造函数足以实现对象间数据元素的一一对应复制。因此，读者对于编写复制构造函数的必要性，可能一直存在疑问。其实隐含的复制构造的数并不总是适用的，因为它完成的只是浅复制。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_21.cpp 对象的浅复制</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Default Constructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Constructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Destructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">int</span> newX<span class="token punctuation">,</span> <span class="token keyword">int</span> newY<span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> newX<span class="token punctuation">;</span>y <span class="token operator">=</span> newY<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ArrayOfPoints</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">ArrayOfPoints</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">size</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>points <span class="token operator">=</span> <span class="token keyword">new</span> Point<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">ArrayOfPoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Deleting..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> points<span class="token punctuation">;</span><span class="token punctuation">}</span>Point<span class="token operator">&amp;</span> <span class="token function">element</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//返回一个对象的引用，确保正确更改</span><span class="token function">assert</span><span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果数组下标越界，程序终止</span><span class="token keyword">return</span> points<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>Point<span class="token operator">*</span> points<span class="token punctuation">;</span><span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> count<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please enter the count of points:"</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> count<span class="token punctuation">;</span>ArrayOfPoints <span class="token function">pointsArray1</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建对象数组</span>pointsArray1<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pointsArray1<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ArrayOfPoints pointsArray2 <span class="token operator">=</span> pointsArray1<span class="token punctuation">;</span><span class="token comment">//创建对象数组副本</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Copy of pointsArrayl:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Point 0 of array2: "</span> <span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Point 1 of array2: "</span> <span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>pointsArray1<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pointsArray1<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"After the moving of pointsArrayl:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Point 0 of array2: "</span> <span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Point 1 of array2: "</span> <span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个程序会出现异常，也就是运行错误。</p><p><img src="/images/cpp2/image-20210115130448555.png" alt="6_21"></p><p>这里建立对象pointsArray2时调用的是默认的复制构造函数，实现对应数据项的直接复制。默认的复制构造函数将两个对象的对应数据项简单复制后，pointsArray1的成员points和pointsArray2的成员points 具有相同的值，也就是说两个指针指向的是同一内存地址，表面上好像完成了复制，但是并没有形成真正的副本。因此当程序中移动pointsArray1中的点时，也影响到了pointsArray2。 这种效果就是“浅复制”。<br>浅复制还有更大的弊病，在程序结束之前pointsArray1和pointsArray2 的析构函数会自动被调用，动态分配的内存空间会被释放。由于两个对象共用了同一块内存空间，因此该空间被两次释放，于是导致运行错误。解决这一问题的方法是编写复制构造函数，实现“深复制”。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_22.cpp  对象的深复制</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token comment">//类的定义同6_21</span><span class="token comment">//...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ArrayOfPoints</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">ArrayOfPoints</span><span class="token punctuation">(</span><span class="token keyword">const</span> ArrayOfPoints<span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//其他成员同6_21</span><span class="token punctuation">}</span><span class="token class-name">ArrayOfPoints</span><span class="token operator">::</span><span class="token function">ArrayOfPoints</span><span class="token punctuation">(</span><span class="token keyword">const</span> ArrayOfPoints<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>size<span class="token operator">=</span>v<span class="token punctuation">.</span>size<span class="token punctuation">;</span>points <span class="token operator">=</span> <span class="token keyword">new</span> Point<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">.</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//同6_21</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210115131228658.png" alt="6_22"></p><p>从这次的运行结果可以看出，程序实现的是深复制：移动pointsArray1中的点不再影响pointsArray2中的点，而且程序结束前分别释放pointsArray1和pointsArray2中的内存空间，也不再引起错误。</p><h3 id="6-6-字符串"><a href="#6-6-字符串" class="headerlink" title="6.6 字符串"></a>6.6 字符串</h3><p>与C语言一样，在C++的基本数据类型变量中没有字符串变量。在C语言中是使用字符型数组来存放字符串的，C++程序中也仍然可以沿用这种办法。不仅如此，标准 C++库中还预定义了string 类。本节就来介绍这两种方法。</p><h4 id="6-6-1-用字符数组存储和处理字符串"><a href="#6-6-1-用字符数组存储和处理字符串" class="headerlink" title="6.6.1 用字符数组存储和处理字符串"></a>6.6.1 用字符数组存储和处理字符串</h4><p>第2章中介绍过，字符串常量是用一对双引号括起来的字符序列。它在内存中的存放形式是，按串中字符的<br>排列次序顺序存放，每个字符占一个字节，并在末尾添加\0作为结尾标记。这实际上是一个隐含创建的类型为char的数组，一个字符串常量就表示这样一个数组的首地址，因此，可以把字符串常量赋给字符串针，由于常量值是不能改的，应将字符串常量赋给指向常量的指针，例如:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> STRING1 <span class="token operator">=</span> <span class="token string">"This is a string."</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span> STRING1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>字符变量也可以用类似方式来表示。 如果创建一个char数组，每个元素存放字符串的一个字符，在末尾放置一个\0，便构成了C++字符串。它的存储方式与字符串常量无异，但由于它是程序员创建的数组，因此可以改写其内容，因而这就是字符串变量而非常量了。这时要注意，用于存放字符串的数组其元素个数应该不小于字符串的长度(字符个数)加1。对字符数组进行初始化赋值时，初值的形式可以是以逗号分隔的ASCII码或字符常量，也可以是整体的字符串常量(这时末尾的\0是隐含的)。 下面列出的语句都可以创建一个初为”program” 的字符串变量，3种写法是等价的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'g'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'m'</span>，<span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"program"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"program"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>尽管对用字符数组表示的字符串进行初始化还比较容易、直观，但进行许多其他字符串操作时却比较麻烦。执行很多字符串操作需要借助cstring头文件中的字符串处理函数。例如将一个字符串的内容复制到另一个字符串需要用strcpy函数，按辞典顺序比较两个的大小需要用strcmp函数，将两个字符串连接起来需要用strcat函数。另外，当字符串长度很不确定时，需要用new来动态创建字符数组。最后还要用delete释放，这些都相当烦琐。C++对这些烦琐的操作进行了封装，形成了string类，可以更加方便地操作字符串。</p><h4 id="6-6-2-string类"><a href="#6-6-2-string类" class="headerlink" title="6.6.2 string类"></a>6.6.2 string类</h4><p>C++标准类库将面向对象的串的概念加入到C++语言中，预定义了字符串类(string类)。string类提供了对字符串进行处理所需要的操作。使用string类需要包含头文件string。string类封装了串的属性并提供了一系列允许访问这此属性的函数。</p><p><strong>细节：</strong>严格地说，string 并非一个独立的类，而是类模板basic_ string的一个特化实例。不过对于string的使用者来说，它的特点与一个类无异，因此可以把它当作一个类来看待。有关模板，将在第9章详细介绍。</p><center><span style="color:blue;font-size:15px">2021/1/18</span></center><p>下面简要介绍一下string 类的构造函数、几个常用的成员函数和操作。为了简明起见，函数原型是经过简化的，与头文件中的形式不完全一样。 </p><p><strong>1.构造函数的原型</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string();//默认构造函数,建立一个长度为0的串string (const string&amp; rhs) ;//复制构造函数string (const char* s);//用指针s所指向的字符申常量初始化string类的对象string (const string&amp; rhs, unsigned int pos, unsigned int n) ;//将对象rhs中的串从位置pos开始取n个字符,用来初始化string类的对象//注:申中的第一个字符的位置为0string (const char* s, unsigned int n);//用指针s所指向的字符串中的前n个字符初始化string类的对象string (unsigned int n, char c);//将参数c中的字符重复n次,用来初始化string类的对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong>由于string类具有接收const char*类型的构造函数，因此字符串常量和用字符数组表示的字符串变量都可以隐含地转换为string对象。<br>例如，可以直接使用字符串常量对string对象初始化:<br><code>string str= "Hello world!";</code></p><p><strong>2.string类的操作符</strong></p><p><img src="/images/cpp2/image-20210118183703493.png" alt="string类的操作符"></p><p><strong>提示：</strong>之所以能够通过上面的操作符来操作string对象，是因为string类对这些操作符进行了重载。操作符的重载将在第8章详细介绍。</p><p><strong>3.常用成员函数功能简介</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">append</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//append(在文章后面)附加，增补; 将字符串s添加在本串尾</span>string <span class="token function">assign</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//赋值,将s所指向的字符串赋值给本对象</span><span class="token keyword">int</span> <span class="token function">compare</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//比较本串与str中串的大小，当本串&lt;str串时,返回负数;当本串&gt;str串时，返回正数;两串相等时,返回0</span>string <span class="token operator">&amp;</span> <span class="token function">insert</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> p0<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将s所指向的字符串插人在本串中位置p0之前</span>string <span class="token function">substr</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//取子串,取本串中位置pos开始的n个字符,构成新的string类对象作为返回值</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">find</span> <span class="token punctuation">(</span><span class="token keyword">const</span> basic_string <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//在找并返回str在本串中第一次出现的位置</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//返回串的长度(字符个数)</span>vold <span class="token function">swap</span> <span class="token punctuation">(</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将本串与str中的字符串进行交换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面看一个string类应用的例子</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_23.cpp    string类应用举例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//根据value的值输出true或false,title为提示文字</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> title<span class="token punctuation">,</span> <span class="token keyword">bool</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> title <span class="token operator">&lt;&lt;</span> <span class="token string">" returns "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>value <span class="token operator">?</span> <span class="token string">"true"</span> <span class="token operator">:</span> <span class="token string">"false"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>string s1 <span class="token operator">=</span> <span class="token string">"DEF"</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s1 1s "</span> <span class="token operator">&lt;&lt;</span> s1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>string s2<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please enter s2: "</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> s2<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"length of s2: "</span> <span class="token operator">&lt;&lt;</span> s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//比较运算符的测试</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"s1&lt;= \"ABC\""</span><span class="token punctuation">,</span> s1 <span class="token operator">&lt;=</span> <span class="token string">"ABC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"\"DEF\"&lt;=s1"</span><span class="token punctuation">,</span> <span class="token string">"DEF"</span> <span class="token operator">&lt;=</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//连接运算符的测试</span>s2 <span class="token operator">+=</span> s1<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s2=s2+s1: "</span> <span class="token operator">&lt;&lt;</span> s2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"length of s2: "</span> <span class="token operator">&lt;&lt;</span> s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210118191532246.png" alt=""></p><p>如果希望从键盘读入字符串，直到行末为止，不以中间的空格作为输入的分隔符，可以使用头文件string中定义的getline。例如，如果将上面的代码中输人s2的语句改为下列语句，就能达到这一目的。<br><code>getline(cin, s2);</code><br>这时，如果从键盘输入字符串“123 ABC” ，那么整个字符串都会被赋给s2。这实际表示输入字符串时只以换行符作为分隔符。getline还允许在输人字符串时增加其他分隔符，使用方法是把可以作为分隔符的字符作为第3个参数传递给getline。例如，使用下面的语句，可以把逗号作为分隔符。<br><code>getline(cin, s2, ',');</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6.24.cpp  用getline输入字符串</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>string city<span class="token punctuation">,</span> state<span class="token punctuation">;</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> city<span class="token punctuation">,</span> <span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"City:"</span> <span class="token operator">&lt;&lt;</span> city <span class="token operator">&lt;&lt;</span> <span class="token string">" state:"</span> <span class="token operator">&lt;&lt;</span> state <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><span style="color:blue;font-size:15px">2021/1/19</span></center><h3 id="6-7-综合实例——个人银行账户管理系统"><a href="#6-7-综合实例——个人银行账户管理系统" class="headerlink" title="6.7 综合实例——个人银行账户管理系统"></a>6.7 综合实例——个人银行账户管理系统</h3><p>在第4章和第5章中，以一个银行账户管理程序为例，说明了类和成员函数的设计和应用，以及类的静态成员的应用和程序结构的组织问题。在本节中，将在第5章综合实例的基础上对银行账户管理程序进步 加以完善。<br>（1）第4章和第5章中，都是用一个整数来表示银行账号，但这并不是完美的方案，例如，如果银行账以“0”开头，或账号超过整数的表示范围，或账号中包括其他字符，这种表示方式都不能胜任。本章学习了字符串后，可以改<strong>用字符串来表示银行账号</strong>，这样以上问题得到了解决。另外，第4章和第5章的程序中所输出的账目列表，每笔账目都没有说明，<strong>使用字符串可以为各笔账目增加说明文字</strong>。此外，我们SavingsAccount类专门<strong>增加了一个用来报告错误的函数</strong>，当其他丽数需要输出错误信息时，直接把信息以字符串形式传递给该函数即可，简化了错误信息的输出。<br>（2）第4章和第5章中，主程序创建的两个账户为两个独立的变量，只能用名字去引用它们，在主程序末尾分别对两个账户进行结算(settle)和显示(show)时，需要将几乎相同的代码书写两遍，如果账户数量增多将会带来更大麻烦。本章学习了数组后，可以<strong>将多个账户组织在一个数组中</strong>，这样可以把需要对各个账户做的事情放在循环中，避免了代码的冗余。<br>（3）第4章和第5章的程序中，日期都是用一个整数来表示的，这样计算两个日期相距天数时非常方便，但这种表示很不直观，对用户很不友好。事实上，<strong>日期可以用一个类来表示</strong>，内含年、月、日三个数据成员，但这又给计算两个日期相差天数带来了麻烦。为了计算日期间相差的天数，可以先选取一个比较规整的基准日期，在构造日期对象时将该日期到这个基准日期的相对天数计算出来，我们将这个相对天数称为“相对日期”。这样在计算两个日期相差的天数时，只需将二者的相对日期相减即可。假设将公元元年1月1日作为公共的基准日期，将y年m月d日相距这一天的天数记为 f(y/m/d,1/1/1)，可以将其分解为3部分:</p><script type="math/tex; mode=display">f(y / m / d, 1 / 1 / 1)=f(y / 1 / 1,1 / 1 / 1)+f(y / m / 1, y / 1 / 1)+f(y / m / d, y / m / 1)</script><p>f(y/1/1,1/1/1)表示当年的1月1日与公元元年1月1日相距的天数，即公元元年到公元y-1年的总天数。平年每年有365天,闰年多一天，因此该值为365(y-1)加上公元元年到y-1年之间的闰年数。由于4年一闰，100的倍数免闰，400的倍数再闰，故有:</p><script type="math/tex; mode=display">f(y / 1 / 1,1 / 1 / 1)=365(y-1)+\left\lfloor\frac{y-1}{4}\right\rfloor-\left\lfloor\frac{y-1}{100}\right\rfloor+\left\lfloor\frac{y-1}{400}\right\rfloor</script><p>f(y/m/1,y/1/1)表示 y年的m月1日与1月1日相距天数。可以把每月1日到1月1日的天数放在一个数组中，计算时只要查询该数组，便可得到f(y/m/1,y/1/1)的值。而对于闰年，仍可通过数组查询，只需在m&gt;2时将查得的值加1。该值只依赖于T和y，将它记为g(m,y)。此外:</p><script type="math/tex; mode=display">f(y/m/d,y/m/1) =d- 1</script><p>如果把公元元年1月1日的相对日期定为1,那么公元y年m月d日的相对日期就是:</p><script type="math/tex; mode=display">\begin{aligned}f(y / m / d, 1 / 1 / 1)+1=& 365(y-1)+\left\lfloor\frac{y-1}{4}\right\rfloor \\&-\left\lfloor\frac{y-1}{100}\right\rfloor+\left\lfloor\frac{y-1}{400}\right\rfloor+g(m+y)+d\end{aligned}</script><p>相对日期得出后，计算两日期相差天数的难题就迎刃而解了。</p><p><img src="/images/cpp2/image-20210119130403132.png" alt="UML图"></p><p>以后，假定银行对活期储蓄账户的结算日期是每年的1月1日。</p><p>例6-25个 人银行账户管理程序改进。<br>整个程序分为5个文件: <strong>date. h</strong>是日期类头文件，<strong>date. cpp</strong>是日期类实现文件，<strong>account.h</strong>是储蓄账户类定义头文件，<strong>account. cpp</strong>是储蓄账户类实现文件，<strong>6_25. cpp</strong>是主函数文件。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//date.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__DATE_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__DATE_H__</span></span><span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span><span class="token comment">//日期类</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> year<span class="token punctuation">;</span><span class="token comment">//年</span><span class="token keyword">int</span> month<span class="token punctuation">;</span><span class="token comment">//月</span><span class="token keyword">int</span> day<span class="token punctuation">;</span><span class="token comment">//日</span><span class="token keyword">int</span> totalDays<span class="token punctuation">;</span><span class="token comment">//该日期是从公元元年1月1日开始的第儿天</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用年、月、日构造日期</span><span class="token keyword">int</span> <span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> year<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> month<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> day<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getMaxDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//获得当月有多少天</span><span class="token keyword">bool</span> <span class="token function">isLeapYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token comment">//判断当年是否为闰年</span><span class="token keyword">return</span> year <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> year <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> year <span class="token operator">%</span> <span class="token number">400</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//输出当前日期</span><span class="token keyword">int</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token comment">//计算两个日期之间差多少天</span><span class="token comment">//常成员函数保护目的对象，常引用保护所引用的对象</span><span class="token keyword">return</span> totalDays <span class="token operator">-</span> date<span class="token punctuation">.</span>totalDays<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span><span class="token comment">// __DATE_H__</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//date.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"date.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdlib&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">namespace</span> <span class="token punctuation">{</span><span class="token comment">//namespace使下面的定义只在当前文件中有效</span><span class="token comment">//存储平年中的某个月1日之前有多少天，为便于getMaxDay函数的实现，该数组多出一项</span><span class="token keyword">const</span> <span class="token keyword">int</span> DAYS_BEFORE_MONTH<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">,</span><span class="token number">59</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token number">120</span><span class="token punctuation">,</span><span class="token number">151</span><span class="token punctuation">,</span><span class="token number">181</span><span class="token punctuation">,</span><span class="token number">212</span><span class="token punctuation">,</span><span class="token number">243</span><span class="token punctuation">,</span><span class="token number">273</span><span class="token punctuation">,</span><span class="token number">304</span><span class="token punctuation">,</span><span class="token number">334</span><span class="token punctuation">,</span><span class="token number">365</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Date</span><span class="token operator">::</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">year</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">month</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">day</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//只验证天数不验证年月？</span><span class="token keyword">if</span> <span class="token punctuation">(</span>day <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> day <span class="token operator">&gt;</span> <span class="token function">getMaxDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Invalid date: "</span><span class="token punctuation">;</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//exit（1）：非正常运行导致退出程序；</span><span class="token punctuation">}</span><span class="token keyword">int</span> years <span class="token operator">=</span> year <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>totalDays <span class="token operator">=</span> years <span class="token operator">*</span> <span class="token number">365</span> <span class="token operator">+</span> years <span class="token operator">/</span> <span class="token number">4</span> <span class="token operator">-</span> years <span class="token operator">/</span> <span class="token number">100</span> <span class="token operator">+</span> years <span class="token operator">/</span> <span class="token number">400</span> <span class="token operator">+</span> DAYS_BEFORE_MONTH<span class="token punctuation">[</span>month <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> day<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLeapYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> month <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> totalDays<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token class-name">Date</span><span class="token operator">::</span><span class="token function">getMaxDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLeapYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> month <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">29</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> DAYS_BEFORE_MONTH<span class="token punctuation">[</span>month<span class="token punctuation">]</span> <span class="token operator">-</span> DAYS_BEFORE_MONTH<span class="token punctuation">[</span>month <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">Date</span><span class="token operator">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-"</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-"</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//account.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__ACCOUNT_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__ACCOUNT_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"date.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">SavingsAccount</span> <span class="token punctuation">{</span><span class="token comment">//储蓄账户类</span><span class="token keyword">private</span><span class="token operator">:</span>std<span class="token operator">::</span>string id<span class="token punctuation">;</span><span class="token comment">//账号</span><span class="token keyword">double</span> balance<span class="token punctuation">;</span><span class="token comment">//余额</span><span class="token keyword">double</span> rate<span class="token punctuation">;</span><span class="token comment">//存款的年利率</span>Date lastDate<span class="token punctuation">;</span><span class="token comment">//上次变更余额的时期</span><span class="token keyword">double</span> accumulation<span class="token punctuation">;</span><span class="token comment">//余额按日累加之和</span><span class="token keyword">static</span> <span class="token keyword">double</span> total<span class="token punctuation">;</span><span class="token comment">//所有账户的总金额</span><span class="token comment">//记录一笔账,date为日期，amount为金额，desc为说明</span><span class="token keyword">void</span> <span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//报告错误信息</span><span class="token keyword">void</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> msg<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//获得到指定日期为止的存款金额按日累积值</span><span class="token keyword">double</span> <span class="token function">accumulate</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> accumulation <span class="token operator">+</span> balance <span class="token operator">*</span> date<span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span>lastDate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//构造函数</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> rate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> id<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">//返回值是string类型的引用，也就是id本身</span><span class="token keyword">double</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> balance<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">getRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rate<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> total<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//存入现金</span><span class="token keyword">void</span> <span class="token function">deposit</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//取出现金</span><span class="token keyword">void</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结算利息,每年1月1日调用一次该函数</span><span class="token keyword">void</span> <span class="token function">settle</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date <span class="token operator">&amp;</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示账户信息</span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span><span class="token comment">//__ACCOUNT_H__</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//account.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"account.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">double</span> SavingsAccount<span class="token operator">::</span>total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//SacingsAccount类相关函数的实现</span><span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> rate<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">balance</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">rate</span><span class="token punctuation">(</span>rate<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">lastDate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">accumulation</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>date<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\t#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">" create"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date <span class="token operator">&amp;</span>date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> desc<span class="token punctuation">)</span><span class="token punctuation">{</span>accumulation <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>lastDate <span class="token operator">=</span> date<span class="token punctuation">;</span>amount <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>amount <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//保留小数点后两位</span>balance <span class="token operator">+=</span> amount<span class="token punctuation">;</span>total <span class="token operator">+=</span> amount<span class="token punctuation">;</span>date<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\t# "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> amount <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> balance <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> desc <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> msg<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error(# "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"): "</span> <span class="token operator">&lt;&lt;</span> msg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> desc<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> desc<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">&gt;</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"not enough money"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token operator">-</span>amount<span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//计算年息</span><span class="token keyword">double</span> interest <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span> <span class="token operator">*</span> rate <span class="token operator">/</span> date<span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token function">Date</span><span class="token punctuation">(</span>date<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>interest <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> interest<span class="token punctuation">,</span> <span class="token string">"interest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>accumulation <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"\tBalance: "</span> <span class="token operator">&lt;&lt;</span> balance<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_25.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"account.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Date <span class="token function">date</span><span class="token punctuation">(</span><span class="token number">2008</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//起始日期</span><span class="token comment">//建立几个账户</span>SavingsAccount accounts<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token string">"03755217"</span><span class="token punctuation">,</span> <span class="token number">0.015</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token string">"02342342"</span><span class="token punctuation">,</span> <span class="token number">0.015</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>accounts<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>SavingsAccount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//11月份的几笔账目</span>accounts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2008</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">,</span> <span class="token string">"salary"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>accounts<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2008</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token string">"sell stock 0323"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//12月份的几笔账目</span>accounts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2008</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5500</span><span class="token punctuation">,</span> <span class="token string">"salary"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>accounts<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2008</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">,</span> <span class="token string">"buy a laptop"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结算所有账户并输出各个账户信息</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>accounts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2009</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>accounts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Total: "</span> <span class="token operator">&lt;&lt;</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210119143650821.png" alt="运行结构"></p><p><strong>细节：</strong>以上程序的Date类的构造函数中使用了exit 函数，该函数的原型声明在cstdlib头文件中。它用来立即终止当前程序的执行，并且将一个整数返回给系统，该整数的作用与由主函数main返回的整数相同，如果是0表示程序正常退出，如果非0表示程序异常退出。</p><p>上面的程序中增加了Date类，把对日期的表示均替换为Date类型。从输出结果明以看出，用“年-月-日”的形式所表示的日期与整数相比要直观得多。此外，本例广泛应用了字符串，这样在银行账号中可以出现字母，而且为每笔账目增加了说明文字，使得程序输出的信息更加丰富。 在主程序中，两个银行账户是用数组表示的，这样最后所执行的账户结算和输出账户信息的操作可以在一个循环中进行，无须把同样的代码书写多遍。</p><h3 id="6-8-深度探索"><a href="#6-8-深度探索" class="headerlink" title="6.8 深度探索"></a>6.8 深度探索</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> C++语言设计指南（第4版） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github使用学习</title>
      <link href="2021/01/04/github/"/>
      <url>2021/01/04/github/</url>
      
        <content type="html"><![CDATA[<center><span style="color:blue;font-size:15px">2021/1/4</span></center><h2 id="什么是-Github"><a href="#什么是-Github" class="headerlink" title="什么是 Github?"></a>什么是 Github?</h2><p> GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。Github 由Chris Wanstrath, PJ Hyett 与Tom Preston-Werner三位开发者在2008年4月创办，除了Git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。 </p><h2 id="1-基本功能"><a href="#1-基本功能" class="headerlink" title="1.基本功能"></a>1.基本功能</h2><p><strong>协同修改</strong><br>多人并行不悖的修改服务器端的同一个文件。<br><strong>数据备份</strong><br>不仅保存目录和文件的当前状态， 还能够保存每一个提交过的历史状态。<br><strong>版本管理</strong><br>在保存每一个版本的文件信息的时候要做到不保存重复数据， 以节约存储空<br>间， 提高运行效率。 这方面 SVN 采用的是增量式管理的方式， 而 Git 采取了文<br>件系统快照的方式。<br><strong>权限控制</strong><br>对团队中参与开发的人员进行权限控制。<br>对团队外开发者贡献的代码进行审核——Git 独有。<br><strong>历史记录</strong><br>查看修改人、 修改时间、 修改内容、 日志信息。<br>将本地文件恢复到某一个历史状态。<br><strong>分支管理</strong><br>允许开发团队在工作过程中多条生产线同时推进任务， 进一步提高效率</p><h2 id="2-git的优势"><a href="#2-git的优势" class="headerlink" title="2.git的优势"></a>2.git的优势</h2><p><strong>版本控制简介</strong>工程设计领域中使用版本控制管理工程蓝图的设计过程。在 IT 开发过程中也可以使用版本控制思想管理代码的版本迭代。<br><strong>版本控制工具</strong><br>集中式版本控制工具：<br>CVS、SVN、VSS……<br>分布式版本控制工具：<br>Git、Mercurial、Bazaar、Darcs……</p><p><strong>Git 的优势</strong><br>大部分操作在本地完成，不需要联网<br>完整性保证<br>尽可能添加数据而不是删除或修改数据<br>分支操作非常快捷流畅<br>与 Linux 命令全面兼容</p><h2 id="3-git简介"><a href="#3-git简介" class="headerlink" title="3.git简介"></a>3.git简介</h2><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104145617035.png" alt="git结构"></p><p><strong>Git 和代码托管中心</strong><br>代码托管中心的任务：维护远程库<br> 局域网环境下： GitLab 服务器<br> 外网环境下 ： GitHub 、 码云</p><h2 id="4-Git-命令行操作"><a href="#4-Git-命令行操作" class="headerlink" title="4.Git 命令行操作"></a>4.Git 命令行操作</h2><h3 id="4-1-本地库初始化"><a href="#4-1-本地库初始化" class="headerlink" title="4.1 本地库初始化"></a>4.1 本地库初始化</h3><p>命令：</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：.git 目录中存放的是本地库相关的子目录和文件，不要删除，也不要胡乱修改</p><h3 id="4-2-设置签名"><a href="#4-2-设置签名" class="headerlink" title="4.2 设置签名"></a>4.2 设置签名</h3><p>用户名：xxxxx<br>Email 地址：zzzz@yyy.com（可以没有）<br>作用：区分不同开发人员的身份<br>辨析：这里设置的签名和登录远程库(代码托管中心)的账号、密码没有任何关系。<br><strong>命令</strong> :<br>项目级别/仓库级别：仅在当前本地库范围内有效 </p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git config user.name xxxxgit config user.email zzzz@yyy.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>信息保存位置：./.git/config 文件</p><p>系统用户级别：登录当前操作系统的用户范围</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git config --global user.name xxxx_glbgit config --global zzzz@yyy.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>信息保存位置：~/.gitconfig 文件</p><p><strong>级别优先级</strong><br>就近原则：项目级别优先于系统用户级别，二者都有时采用项目级别的签名<br>如果只有系统用户级别的签名，就以系统用户级别的签名为准<br>二者都没有不允许<br>实际开发中一般只设置一个系统签名就行了</p><h3 id="4-3-基本操作"><a href="#4-3-基本操作" class="headerlink" title="4.3 基本操作"></a>4.3 基本操作</h3><h4 id="4-3-1状态查看"><a href="#4-3-1状态查看" class="headerlink" title="4.3.1状态查看"></a>4.3.1状态查看</h4><pre class="line-numbers language-git" data-language="git"><code class="language-git">git status <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看工作区、暂存区状态</p><h4 id="4-3-2-添加"><a href="#4-3-2-添加" class="headerlink" title="4.3.2 添加"></a>4.3.2 添加</h4><pre class="line-numbers language-git" data-language="git"><code class="language-git">git add [file name] <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将工作区的“新建/修改”添加到暂存区</p><h4 id="4-3-3-提交"><a href="#4-3-3-提交" class="headerlink" title="4.3.3 提交"></a>4.3.3 提交</h4><pre class="line-numbers language-git" data-language="git"><code class="language-git">git commit -m <span class="token string">"备注你的版本记录"</span> [file name] <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将暂存区的内容提交到本地库</p><h4 id="4-3-4-查看历史记录"><a href="#4-3-4-查看历史记录" class="headerlink" title="4.3.4 查看历史记录"></a>4.3.4 查看历史记录</h4><pre class="line-numbers language-none"><code class="language-none">git log//显示完整记录git log --pretty=oneline//显示简化的记录，但有完整的哈希值git log --oneline//显示简化的哈希值(只显示过去的)git reflog//显示变更任意版本需要移动的指针次数(过去未来全部显示)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>多屏显示控制方式： 空格向下翻页；b 向上翻页；q 退出</p><h4 id="4-3-5-前进后退"><a href="#4-3-5-前进后退" class="headerlink" title="4.3.5 前进后退"></a>4.3.5 前进后退</h4><p>基于索引值操作[推荐]</p><pre class="line-numbers language-none"><code class="language-none">git reset --hard [局部索引值] git reset --hard a6ace91<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用^符号：只能后退<br>注：一个^表示后退一步，n 个表示后退 n 步</p><pre class="line-numbers language-none"><code class="language-none">git reset --hard HEAD^<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用~符号：只能后退<br>注：表示后退 n 步</p><pre class="line-numbers language-none"><code class="language-none">git reset --hard HEAD~n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-3-6-reset-命令的三个参数对比"><a href="#4-3-6-reset-命令的三个参数对比" class="headerlink" title="4.3.6 reset 命令的三个参数对比"></a>4.3.6 reset 命令的三个参数对比</h4><p>—soft 参数：仅在本地库移动 HEAD 指针<br>—mixed 参数：在本地库移动 HEAD 指针；重置暂存区<br>—hard 参数：在本地库移动 HEAD 指针 ； 重置暂存区 ； 重置工作区</p><h4 id="4-3-7-删除文件并找回"><a href="#4-3-7-删除文件并找回" class="headerlink" title="4.3.7 删除文件并找回"></a>4.3.7 删除文件并找回</h4><p>前提：删除前，文件存在时的状态提交到了本地库。<br>操作：git reset —hard [指针位置]<br>删除操作已经提交到本地库：指针位置指向历史记录<br>删除操作尚未提交到本地库：指针位置使用 HEAD</p><h4 id="4-3-8-比较文件差异"><a href="#4-3-8-比较文件差异" class="headerlink" title="4.3.8 比较文件差异"></a>4.3.8 比较文件差异</h4><pre class="line-numbers language-none"><code class="language-none">git diff [文件名] <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将工作区中的文件和暂存区进行比较</p><pre class="line-numbers language-none"><code class="language-none">git diff [本地库中历史版本] [文件名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将工作区中的文件和本地库历史记录比较<br>不带文件名比较多个文件</p><h3 id="4-4-分支管理"><a href="#4-4-分支管理" class="headerlink" title="4.4 分支管理"></a>4.4 分支管理</h3><h4 id="4-4-1-什么是分支？"><a href="#4-4-1-什么是分支？" class="headerlink" title="4.4.1 什么是分支？"></a>4.4.1 什么是分支？</h4><p>在版本控制过程中，使用多条线同时推进多个任务。</p><h4 id="4-4-2-分支的好处？"><a href="#4-4-2-分支的好处？" class="headerlink" title="4.4.2 分支的好处？"></a>4.4.2 分支的好处？</h4><p>同时并行推进多个功能开发，提高开发效率<br>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p><h4 id="4-4-3-分支操作"><a href="#4-4-3-分支操作" class="headerlink" title="4.4.3 分支操作"></a>4.4.3 分支操作</h4><p><strong>创建分支</strong> </p><pre class="line-numbers language-none"><code class="language-none">git branch [分支名] <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看分支</strong> </p><pre class="line-numbers language-none"><code class="language-none">git branch -v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>切换分支</strong></p><pre class="line-numbers language-none"><code class="language-none">git checkout [分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>合并分支</strong><br>第一步：切换到要接受修改的分支上 </p><pre class="line-numbers language-none"><code class="language-none">git checkout [原来的分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二步：执行 merge 命令 </p><pre class="line-numbers language-none"><code class="language-none">git merge [有新内容分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>解决冲突</strong></p><p>第一步：编辑文件，删除特殊符号<br>第二步：把文件修改到满意的程度，保存退出<br>第三步：git add [文件名]<br>第四步：git commit -m “日志信息”（后面不带文件名）</p><h2 id="5-Git-基本原理"><a href="#5-Git-基本原理" class="headerlink" title="5.Git 基本原理"></a>5.Git 基本原理</h2><h3 id="5-1-哈希"><a href="#5-1-哈希" class="headerlink" title="5.1 哈希"></a>5.1 哈希</h3><p>哈希是一个系列的加密算法，各个不同的哈希算法虽然加密强度不同，但是有以下 几个共同点：<br> ①不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定。<br>②哈希算法确定，输入数据确定，输出数据能够保证不变<br>③哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大<br>④哈希算法不可逆 Git 底层采用的是 SHA-1 算法。（MD5也是哈希算法的一种）<br>哈希算法可以被用来验证文件，Git 就是靠这种机制来从根本上保证数据完整性的。</p><h3 id="5-2-Git-保存版本的机制"><a href="#5-2-Git-保存版本的机制" class="headerlink" title="5.2 Git 保存版本的机制"></a>5.2 Git 保存版本的机制</h3><h4 id="5-2-1-集中式版本控制工具的文件管理机制"><a href="#5-2-1-集中式版本控制工具的文件管理机制" class="headerlink" title="5.2.1 集中式版本控制工具的文件管理机制"></a>5.2.1 集中式版本控制工具的文件管理机制</h4><p>以文件变更列表的方式存储信息。这类系统将它们保存的信息看作是一组基本 文件和每个文件随时间逐步累积的差异。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210105000016196.png" alt=""></p><h4 id="5-2-2-Git-的文件管理机制"><a href="#5-2-2-Git-的文件管理机制" class="headerlink" title="5.2.2 Git 的文件管理机制"></a>5.2.2 Git 的文件管理机制</h4><p>Git 把数据看作是小型文件系统的一组快照。每次提交更新时 Git 都会对当前 的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改， Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。所以 Git 的 工作方式可以称之为快照流。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210105000029275.png" alt=""></p><h4 id="5-2-3-Git-文件管理机制细节"><a href="#5-2-3-Git-文件管理机制细节" class="headerlink" title="5.2.3 Git 文件管理机制细节"></a>5.2.3 Git 文件管理机制细节</h4><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104235138752.png" alt=""></p><p>提交对象及其父对象形成的链条</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104235208324.png" alt=""></p><h3 id="5-3-Git-分支管理机制"><a href="#5-3-Git-分支管理机制" class="headerlink" title="5.3 Git 分支管理机制"></a>5.3 Git 分支管理机制</h3><h4 id="5-3-1-分支的创建"><a href="#5-3-1-分支的创建" class="headerlink" title="5.3.1 分支的创建"></a>5.3.1 分支的创建</h4><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104235624280.png" alt=""></p><h4 id="5-3-2-分支的切换"><a href="#5-3-2-分支的切换" class="headerlink" title="5.3.2 分支的切换"></a>5.3.2 分支的切换</h4><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104235717453.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104235729611.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104235745003.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/github/image-20210104235758253.png" alt=""></p><h2 id="6-GitHub"><a href="#6-GitHub" class="headerlink" title="6.GitHub"></a>6.GitHub</h2><h3 id="6-2-创建远程库"><a href="#6-2-创建远程库" class="headerlink" title="6.2 创建远程库"></a>6.2 创建远程库</h3><h3 id="6-3-创建远程库地址别名"><a href="#6-3-创建远程库地址别名" class="headerlink" title="6.3 创建远程库地址别名"></a>6.3 创建远程库地址别名</h3><pre class="line-numbers language-none"><code class="language-none">git remote -v 查看当前所有远程地址别名git remote add [别名] [远程地址]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-4-推送"><a href="#6-4-推送" class="headerlink" title="6.4 推送"></a>6.4 推送</h3><pre class="line-numbers language-none"><code class="language-none">git push [别名] [分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-5-克隆"><a href="#6-5-克隆" class="headerlink" title="6.5 克隆"></a>6.5 克隆</h3><pre class="line-numbers language-none"><code class="language-none">git clone [远程地址]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果：<br>完整的把远程库下载到本地<br>创建远程地址别名<br>初始化本地库</p><h3 id="6-6-团队成员邀请"><a href="#6-6-团队成员邀请" class="headerlink" title="6.6 团队成员邀请"></a>6.6 团队成员邀请</h3><h3 id="6-7-拉取"><a href="#6-7-拉取" class="headerlink" title="6.7 拉取"></a>6.7 拉取</h3><pre class="line-numbers language-none"><code class="language-none">git pull [远程库地址别名] [远程分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>pull=fetch+merge</p><pre class="line-numbers language-none"><code class="language-none">git fetch [远程库地址别名] [远程分支名]git merge [远程库地址别名/远程分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-8-解决冲突"><a href="#6-8-解决冲突" class="headerlink" title="6.8 解决冲突"></a>6.8 解决冲突</h3><p>要点<br>如果不是基于 GitHub 远程库的最新版所做的修改，不能推送，必须先拉取。<br>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。</p><h3 id="6-9-跨团队协作"><a href="#6-9-跨团队协作" class="headerlink" title="6.9 跨团队协作"></a>6.9 跨团队协作</h3><p>Fork<br>本地修改，然后推送到远程<br>Pull Request</p><p>主人：<br>审核代码<br>合并代码<br>将远程库修改拉取到本地</p><h3 id="6-10-SSH-登录"><a href="#6-10-SSH-登录" class="headerlink" title="6.10 SSH 登录"></a>6.10 SSH 登录</h3><p>进入当前用户的家目录<br>$ cd ~<br>删除.ssh 目录<br>$ rm -rvf .ssh<br>运行命令生成.ssh 密钥目录<br>$ ssh-keygen -t rsa -C xxx@yyy.com<br>进入.ssh 目录查看文件列表<br>$ cd .ssh<br>$ ls -lF<br>查看 id_rsa.pub 文件内容<br>$ cat id_rsa.pub<br>复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys<br>New SSH Key<br>输入复制的密钥信息<br>回到 Git bash 创建远程地址别名<br>git remote add origin_ssh 网页上复制的ssh地址<br>推送文件进行测试</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++语言程序设计（1-5章）</title>
      <link href="2021/01/01/cpp/"/>
      <url>2021/01/01/cpp/</url>
      
        <content type="html"><![CDATA[<p><span style="color: #c31887;">第一次学是在2017上半年，大一的第二个学期，虽然当时学的挺不错，但是已经忘了许多，重新学一下。</span></p><p>使用的教材：C++语言程序设计（第4版）郑莉等</p><center><span style="color:blue;font-size:15px">2021/1/1</span></center><h2 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h2><h3 id="1-2-面向对象的方法"><a href="#1-2-面向对象的方法" class="headerlink" title="1.2 面向对象的方法"></a>1.2 面向对象的方法</h3><p><strong>对象</strong>：用来描述客观事物的一个实体，用来构成系统的一个基本单位，由<strong>一组属性</strong>和<strong>一组行为</strong>构成</p><p><strong>类</strong>：具有相同属性和服务的<strong>一组对象的集合</strong></p><p><strong>封装</strong>：把对象的属性和服务结合成一个独立的系统单位，并尽可能隐藏对象的内部细节</p><p><strong>继承</strong>：继承类的对象拥有其一般类的全部属性和服务，称作特殊类对一般类的继承</p><p><strong>多态性</strong>：在一般类中定义的属性或行为，被特殊可继承之后，可以具有不同的数据类型或表现出不同的行为</p><h3 id="1-4-信息的表示与存储"><a href="#1-4-信息的表示与存储" class="headerlink" title="1.4 信息的表示与存储"></a>1.4 信息的表示与存储</h3><h4 id="1-4-2-进制的转换"><a href="#1-4-2-进制的转换" class="headerlink" title="1.4.2 进制的转换"></a>1.4.2 进制的转换</h4><p>十进制转换2（或x）进制：</p><p>整数部分：除2取余</p><p>小数部分：乘2取整</p><p>然后拼在一起</p><h4 id="1-4-3-信息的存储单位"><a href="#1-4-3-信息的存储单位" class="headerlink" title="1.4.3 信息的存储单位"></a>1.4.3 信息的存储单位</h4><p><strong>位</strong>（bit）：1位二进制信息</p><p><strong>字节</strong>（Byte）：由8位二进制数字组成，是信息存储中最常用的基本单位</p><p><strong>字</strong>（Word）:字是位的组合，并作为一个独立的信息单位处理。常用的固定字长有8位、16位、32位等。</p><p><strong>机器字长</strong>：机器字长一般是指参加运算的寄存器所含有的二进制数的位数，它代表了机器的精度，如32位、64位等。</p><h4 id="1-4-4-二进制数的编码表示"><a href="#1-4-4-二进制数的编码表示" class="headerlink" title="1.4.4 二进制数的编码表示"></a>1.4.4 二进制数的编码表示</h4><p><strong>原码</strong>：符号数字位化为0（正）和1（负）</p><p><strong>反码</strong>：作为补码的中间码，正数不变，负数符号位不变，其余各位取反</p><p><strong>补码</strong>：正数不变，负数由反码的最末位加1</p><p>补码符号位可以作为数值参加运算，补码运算的结果仍为补码</p><h4 id="1-4-5-浮点数的表示"><a href="#1-4-5-浮点数的表示" class="headerlink" title="1.4.5 浮点数的表示"></a>1.4.5 浮点数的表示</h4><p>N：要表示的浮点数，用科学计数法写就是</p><script type="math/tex; mode=display">N=M*R^E</script><p>R：基数，计算机用2做基数</p><p>E：N的阶码</p><p>M：N的全部有效数字，称为N的尾数</p><p><img src="/images/cpp/123.png" alt="浮点数"></p><h4 id="1-4-6-数的表示范围（补码）"><a href="#1-4-6-数的表示范围（补码）" class="headerlink" title="1.4.6 数的表示范围（补码）"></a>1.4.6 数的表示范围（补码）</h4><p>8位整数的无符号数可以表示0 ~ +255</p><p>8位整数的有符号数可以表示-128 ~ +127（因为0占正数一个空间）</p><p>n位小数范围为 -$1$ ~ +$(1-2^{-n})$</p><p>为了同时满足对浮点数的范围和精度的要求，往往采用<strong>双倍字长</strong>甚至<strong>更多个字长</strong>来表示一个浮点数</p><h4 id="1-4-8-汉字英文信息的表示"><a href="#1-4-8-汉字英文信息的表示" class="headerlink" title="1.4.8 汉字英文信息的表示"></a>1.4.8 汉字英文信息的表示</h4><p>西文使用ASCII码来表示，使用一个字节中的7位来表示128个字符，剩下一位作为校验码</p><p>汉字可以使用GB2312（国标码），2字节码，用两个7位二进制数编码表示一个汉字（还有其他的编码方式）</p><h3 id="1-5-程序开发的基本概念"><a href="#1-5-程序开发的基本概念" class="headerlink" title="1.5 程序开发的基本概念"></a>1.5 程序开发的基本概念</h3><h4 id="1-5-1-基本术语"><a href="#1-5-1-基本术语" class="headerlink" title="1.5.1 基本术语"></a>1.5.1 基本术语</h4><p><strong>源程序</strong>：源代码</p><p><strong>目标程序</strong>：是源程序经过翻译加工后生成的程序，目标程序可以用机器语言或者汇编语言来表示</p><p><strong>翻译程序</strong>：把源程序翻译为目标程序的程序<br>                -汇编程序：把汇编语言翻译成机器语言形式的目标程序<br>                -编译程序：把高级语言翻译成目标程序<br>                -解释程序：也是把高级语言翻译成机器指令，但是不生成整个的目标程序，边翻译边执行，需要重复解释循环语句，效率较低</p><h4 id="1-5-2-完整的程序过程"><a href="#1-5-2-完整的程序过程" class="headerlink" title="1.5.2 完整的程序过程"></a>1.5.2 完整的程序过程</h4><div class="table-container"><table><thead><tr><th>编辑</th><th>编译</th><th>连接</th><th>运行</th></tr></thead><tbody><tr><td>.cpp</td><td>.obj</td><td>.exe</td></tr></tbody></table></div><p>连接是将多个目标文件以及库中的某些文件放在一起，生成exe</p><center><span style="color:blue;font-size:15px">2021/1/2</span></center><h2 id="第2章-C-简单程序设计"><a href="#第2章-C-简单程序设计" class="headerlink" title="第2章 C++简单程序设计"></a>第2章 C++简单程序设计</h2><h3 id="2-2-基本数据类型和表达式"><a href="#2-2-基本数据类型和表达式" class="headerlink" title="2.2 基本数据类型和表达式"></a>2.2 基本数据类型和表达式</h3><h4 id="2-2-1-基本数据类型"><a href="#2-2-1-基本数据类型" class="headerlink" title="2.2.1 基本数据类型"></a>2.2.1 基本数据类型</h4><p>变量的大小会根据编译器和所使用的电脑而有所不同</p><p>我电脑上的基本数据类型大小：</p><p><img src="/images/cpp/image-20210102143445587.png" alt="数据大小"></p><h4 id="2-2-2-常量"><a href="#2-2-2-常量" class="headerlink" title="2.2.2 常量"></a>2.2.2 常量</h4><p>八进制以0开头<br>十六进制以0x开头<br>字符常量用ASCII码存储，可以用转义字符’\‘输入<br>字符串常量末尾需要添加’\0’作为结尾标记</p><h4 id="2-2-3-变量"><a href="#2-2-3-变量" class="headerlink" title="2.2.3 变量"></a>2.2.3 变量</h4><p>16进制和指数形式的表示:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0x123</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"hex:"</span><span class="token operator">&lt;&lt;</span> hex <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">0.24E+2</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp/image-20210102145702550.png" alt="16进制"></p><h4 id="2-2-5-运算符与表达式"><a href="#2-2-5-运算符与表达式" class="headerlink" title="2.2.5 运算符与表达式"></a>2.2.5 运算符与表达式</h4><p>“%”的优先级与”/“相同</p><p>赋值表达式运算”=”的结合性为从右往左<br>    例：a=b=c=5</p><p><u><strong>复合的赋值运算符</strong></u>有10种，优先级与”=”相同，结合性也是从右往左<br>    例：a+=a-=a*a </p><p><strong><u>逗号运算符</u></strong>为”,”逗号表达式形式为 “表达式1,表达式2” ，求解顺序是先1后2，最终结果为表达式2的值<br>    例：a=3*5,a*4    最终结果为60</p><p><strong><u>关系运算符</u></strong>的优先级：<br>关系表达式的结果类型为bool，值只能是true或false<img src="/images/cpp/image-20210102151756711.png" alt="关系运算符"></p><p><strong><u>逻辑运算符</u></strong>的优先级：”!”&gt;”&amp;&amp;”&gt;”||”<br>    注意：“&amp;&amp;”和“||”运算具有短路特性<br>    “&amp;&amp;”的第一个值为false就不对第二个求值，“||”的第一个值为true就不对第二个求值</p><p><u><strong>条件运算符</strong></u>“?”是c++中唯一的一个三元运算符</p><p><strong><u>sizeof运算符</u></strong>用来计算<strong>某种类型</strong>的对象在内存中所占的字节数（是计算类型的，不对表达式求值）</p><p><u><strong>位运算</strong></u>：<br>c++提供了6个位运算符<br>（1）按位与（&amp;）：<br><img src="/images/cpp/image-20210102153802519.png" alt=""><br>可以将操作数中的任意位置0，其他位不变（如和11110111与）<br>也可以取出一个数的低字节（如和00001111与）<br>（2）按位或（|）：可以将操作数中的任意位置1，其他位不变（如和00001000或）<br>（3）按位异或（^）：可以将操作数中的若干位置翻转（取反）<br>（4）按位取反（~）：单目运算符，对每一位都取反<br>（5）移位（&lt;&lt;）（&gt;&gt;）：左移低位补0，高位舍弃，右移低位舍弃，高位补符号位（有符号的话）<br>        注意：移位运算的结果是表达式的值，不改变变量本身的值，如a&gt;&gt;2不改变a</p><p><strong><u>混合运算时数据类型的转换</u></strong>：<br>（1）隐含转换：操作数类型不一致时，编译系统会自动对数据进行转换（由低类型到高类型）<img src="/images/cpp/image-20210102160055384.png" alt="隐含转换"><br>（2）显式转换：如a=（int）b</p><h3 id="2-3-数据的输入与输出"><a href="#2-3-数据的输入与输出" class="headerlink" title="2.3 数据的输入与输出"></a>2.3 数据的输入与输出</h3><p>在C++中，<strong>将数据从一个对象到另一个对象的流动抽象为“<u>流</u>”。流在使用前要被建立，使用后要被删除。数据的输入与输出是通过I/O流来实现的</strong>，cin和cout是预定义的流类对象。cin用来处理标准输入，即键盘输入。cout用来处理标准输出，即屏幕输出。</p><h3 id="2-4-算法的基本控制结构"><a href="#2-4-算法的基本控制结构" class="headerlink" title="2.4 算法的基本控制结构"></a>2.4 算法的基本控制结构</h3><p>顺序结构，选择结构和循环结构</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//2_2.cpp 判断闰年</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> year<span class="token punctuation">;</span><span class="token keyword">bool</span> isLeapYear<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter the year:"</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> year<span class="token punctuation">;</span>isLeapYear <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>year <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> year <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>year <span class="token operator">%</span> <span class="token number">400</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isLeapYear<span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> year <span class="token operator">&lt;&lt;</span> <span class="token string">"is a leap year"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span>cout <span class="token operator">&lt;&lt;</span> year <span class="token operator">&lt;&lt;</span> <span class="token string">"is not a leap year"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>goto 语句</strong>允许把控制无条件转移到同一函数内的被标记的语句，goto 语句一个很好的作用是退出深嵌套例程。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">goto</span> label<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>label<span class="token operator">:</span> statement<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-自定义数据结构"><a href="#2-5-自定义数据结构" class="headerlink" title="2.5 自定义数据结构"></a>2.5 自定义数据结构</h3><p><strong>枚举</strong>（enumerate）类型 enum：<br>例：enum Weekday{SUN,MON,TUE,WED,THU,FRI,SAT};<br>对枚举元素按常量处理，不能对它们赋值<br>枚举元素具有默认值，依次为：0,1,2,···<br>也可以在声明时另行定义枚举元素的值，<br>如：enum Weekday{SUN=7,MON=1,TUE,WED,THU,FRI,SAT};<br>定义SUN为7，MON为1，以后顺序加1，SAT为6</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 2_11.cpp 枚举</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">GameResult</span> <span class="token punctuation">{</span> WIN<span class="token punctuation">,</span> LOST<span class="token punctuation">,</span> TIE<span class="token punctuation">,</span> CANAEL <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>GameResult result<span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">GameResult</span> omit <span class="token operator">=</span> CANAEL<span class="token punctuation">;</span><span class="token comment">//也可以在类型名前写enum     </span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> count <span class="token operator">=</span> WIN<span class="token punctuation">;</span> count <span class="token operator">&lt;=</span> CANAEL<span class="token punctuation">;</span> count<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//隐式类型转换</span>result <span class="token operator">=</span> <span class="token function">GameResult</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显式类型转换</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> omit<span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the game was cancelled"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the game was played"</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> WIN<span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"and we won!"</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> LOST<span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"and we lost."</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-深度探索"><a href="#2-6-深度探索" class="headerlink" title="2.6 深度探索"></a>2.6 深度探索</h3><h4 id="2-6-1-变量的实现机制"><a href="#2-6-1-变量的实现机制" class="headerlink" title="2.6.1 变量的实现机制"></a>2.6.1 变量的实现机制</h4><p>编译器需要根据变量的数据类型选择适当的指令，CPU所执行的指令并不对操作数的类型加以区分。<br>（因为两个不同类型的数，值不一样，但是他们的二进制形式可能一样）</p><h4 id="2-6-2-C-表达式的执行原理（汇编assembly）"><a href="#2-6-2-C-表达式的执行原理（汇编assembly）" class="headerlink" title="2.6.2 C++表达式的执行原理（汇编assembly）"></a>2.6.2 C++表达式的执行原理（汇编assembly）</h4><p>CPU的大部分读写操作都是对寄存器进行的，IA-32的通用寄存器有eax,ebx,ecx,edx,esp,ebp,esi,edi八个，都是32位寄存器。<br>例：$d=(a+b)*c$</p><pre class="line-numbers language-wasm" data-language="wasm"><code class="language-wasm">mov <span class="token number">0x80495dc</span>,%eax//将 <span class="token number">0x80495dc</span> 地址内的<span class="token number">32</span>位整数装入eax寄存器（<span class="token number">0x80495dc</span>为内存地址，在cpu处理需放入寄存器）mov <span class="token number">0x80495d8</span>,%ecx//将 <span class="token number">0x80495d8</span> 地址内的<span class="token number">32</span>位整数装入ecx寄存器add %eax,%ecx//将 eax 和 ecx 两寄存器内的数相加，结果放在ecx寄存器中mov <span class="token number">0x80495e4</span>,%eax//将 <span class="token number">0x80495e4</span> 地址内的<span class="token number">32</span>位证书装入eax寄存器imul %ecx,%eax//将 eax 和 ecx 寄存器中的两个<span class="token number">32</span>位有符号整数相乘,得到一个<span class="token number">64</span>//位整数,结果的低<span class="token number">32</span>位放入 eax 寄存器,高<span class="token number">32</span>位放入 edx 寄存器（d也是<span class="token number">32</span>位整数，所以只取低<span class="token number">32</span>位）mov %eax,<span class="token number">0x80495e4</span>//将 eax 寄存器中的<span class="token number">32</span>位证书存入 <span class="token number">0x80495e4</span> 地址中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>2-1 C++语言有哪些主要特点和优点？<br>答：<br>优点：性能优势，触碰底层；<br>缺点：难学，开发时间慢成本高，大型项目或者图形编程更需要，垃圾处理不如java，指针操作会带来不安全；</p><center><span style="color:blue;font-size:15px">2021/1/3</span></center><h2 id="第3章-函数"><a href="#第3章-函数" class="headerlink" title="第3章 函数"></a>第3章 函数</h2><h3 id="3-1-函数的定义与使用"><a href="#3-1-函数的定义与使用" class="headerlink" title="3.1 函数的定义与使用"></a>3.1 函数的定义与使用</h3><h4 id="3-1-2-函数的调用"><a href="#3-1-2-函数的调用" class="headerlink" title="3.1.2 函数的调用"></a>3.1.2 函数的调用</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 3_2.cpp 将八位二进制数转换为十进制</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//计算x的n次方</span><span class="token keyword">double</span> <span class="token function">power</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter an 8 bit binary number:"</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">char</span> ch<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> ch<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span>value <span class="token operator">+=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">power</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Decimal value is "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">power</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">double</span> val <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>val <span class="token operator">*=</span> x<span class="token punctuation">;</span><span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//3_4.cpp 寻找并输出11~999之间的数m，它满足m,m^2,m^3均为回文数。</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">symm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">unsigned</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token keyword">unsigned</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>m <span class="token operator">=</span> m <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> i <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>i <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> m <span class="token operator">==</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> m <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span> m <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> m<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">symm</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">symm</span><span class="token punctuation">(</span>m <span class="token operator">*</span> m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">symm</span><span class="token punctuation">(</span>m <span class="token operator">*</span> m <span class="token operator">*</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"m="</span> <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" m*m="</span> <span class="token operator">&lt;&lt;</span> m <span class="token operator">*</span> m<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" m*m*m="</span> <span class="token operator">&lt;&lt;</span> m <span class="token operator">*</span> m <span class="token operator">*</span> m <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>递归调用：</strong><br>递归算法的实质是将原有的问题分解为新的问题，而解决新问题时又用到了原来问题的解法。按照这一原则分解下去，每次出现的新问题都是原有问题的简化的子集，而最终分解出来的问题，是一个已知解的问题，这便是有限的递归调用。只有有限的递归调用才是有意义的。<br>递归的过程有两个阶段:<br><strong>第一阶段：递推</strong> 将原问题不断分解为新的子问题，逐渐从未知向已知推进，最终到达已知的条件。<br><strong>第二阶段：回归</strong> 从已知的问题出发，按照递推的逆过程，逐一求值回归，最后达到递推的开始处。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//3_9.cpp 计算从n个人里选k个人的组合数</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">comn</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> n<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> k <span class="token operator">||</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">comn</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">comn</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please enter two integers n and k:"</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> n <span class="token operator">&gt;&gt;</span> k<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"C(n,k)="</span> <span class="token operator">&lt;&lt;</span> <span class="token function">comn</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//3_10.cpp 汉诺塔问题</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> movecount<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//把src针的最上面一个盘子移动到dest针上</span><span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">char</span> src<span class="token punctuation">,</span> <span class="token keyword">char</span> dest<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> src <span class="token operator">&lt;&lt;</span> <span class="token string">"--&gt;"</span> <span class="token operator">&lt;&lt;</span> dest <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>movecount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//把n个盘子从src针移动到dest针，以medium针为中介</span><span class="token keyword">void</span> <span class="token function">hanoi</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> src<span class="token punctuation">,</span> <span class="token keyword">char</span> medium<span class="token punctuation">,</span> <span class="token keyword">char</span> dest<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token function">move</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">hanoi</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> src<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> medium<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">move</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">hanoi</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> medium<span class="token punctuation">,</span> src<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> m<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter the number of diskes: "</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> m<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the steps to moving "</span> <span class="token operator">&lt;&lt;</span> m <span class="token operator">&lt;&lt;</span> <span class="token string">" diskes:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">hanoi</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"total move number: "</span> <span class="token operator">&lt;&lt;</span> movecount<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-3-函数的参数传递"><a href="#3-1-3-函数的参数传递" class="headerlink" title="3.1.3 函数的参数传递"></a>3.1.3 函数的参数传递</h4><p>在函数未被调用时，函数的形参并不占有实际的内存空间，也没有实际的值。只有在函数被调用时才为形参分配粗存储单元，并将实参与形参结合。</p><p><strong>1.值传递</strong>：（直接将实参的值传递给形参）<br>这一过程是参数值的单向传递过程，一旦形参获得了值便与实参脱离关系，以后形参的变化不会影响实参。</p><p><strong>2.引用传递：</strong><br>引用是一种特殊类型的变量，可以被认为是另一个变量的别名，声明一个引用时，必须同时对它进行初始化，使他指向一个已存在的对象，一旦一个引用被初始化后，就不能改为指向其他对象。将引用作为形参，在调用表达式时，才为形参分配内存空间，同时用实参来初始化形参。这样引用类型的形参就通过形实结合，成为了实参的一个别名，对形参的任何操作也就会直接作用于实参。</p><h3 id="3-2-内联函数"><a href="#3-2-内联函数" class="headerlink" title="3.2 内联函数"></a>3.2 内联函数</h3><p>对于一些功能简单，规模较小而又使用频繁的函数，可以设计为内联函数。内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌在每一个调用处。这样就节省了参数传递，控制转移等开销。<br>内联函数的定义只需要使用关键字inline</p><p><strong>注意</strong>：内联只是一个请求，编译器并不承诺将inline修饰的函数作为内联，多数编译器会自动判断处理，如递归函数编译器会只内联到一定深度或根本不内联</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//3_14.cpp 内联函数应用举例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> PI <span class="token operator">=</span> <span class="token number">3.14159265358979</span><span class="token punctuation">;</span><span class="token comment">//内联函数，根据圆的半径计算其面积</span><span class="token keyword">inline</span> <span class="token keyword">double</span> <span class="token function">calArea</span><span class="token punctuation">(</span><span class="token keyword">double</span> radius<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> PI <span class="token operator">*</span> radius <span class="token operator">*</span> radius<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">//调用内联函数求圆面积，编译时此处被替换为calArea函数体语句</span><span class="token keyword">double</span> area <span class="token operator">=</span> <span class="token function">calArea</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> area <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-带默认形参值的函数"><a href="#3-3-带默认形参值的函数" class="headerlink" title="3.3 带默认形参值的函数"></a>3.3 带默认形参值的函数</h3><p>函数在定义时可以预先声明默认的形参值。调用时如果给出实参，则用实参初始化形参，如果没有给出实参，则采用预先声明的默认形参值。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有默认值的形参必须在形参列表的最后，也就是说，在有默认值的形参右面，不能出无默认值的形参。</p><p><strong>在相同的作用域内</strong>，不允许在同一个函数的多个声明中对同一个参数的默认值重复定义，即使前后定义的值相同也不行。</p><h3 id="3-4-函数重载"><a href="#3-4-函数重载" class="headerlink" title="3.4 函数重载"></a>3.4 函数重载</h3><p>两个以上的函数，具有相同的函数名，但形参的个数或者类型不同，编译器根据实参和形参的类型及个数的最佳匹配，自动确定调用哪一个函数，这就是函数的重载</p><p><img src="/images/cpp/image-20210104011010905.png" alt="函数重载"></p><h3 id="3-5-系统函数"><a href="#3-5-系统函数" class="headerlink" title="3.5 系统函数"></a>3.5 系统函数</h3><p>可以访问zh.cppreference.com查阅常用的C++函数的原型，头文件和用法</p><h3 id="3-6-深度探索"><a href="#3-6-深度探索" class="headerlink" title="3.6 深度探索"></a>3.6 深度探索</h3><h4 id="3-6-1-运行栈与函数调用的执行"><a href="#3-6-1-运行栈与函数调用的执行" class="headerlink" title="3.6.1 运行栈与函数调用的执行"></a>3.6.1 运行栈与函数调用的执行</h4><p>嵌套调用使用运行栈来存储数据，执行过程见课本p91</p><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//t3_9.cpp 编写函数判别一个数是否是质数（素数），在主程序中实现输入输出</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cmath&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">is_prime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>is_prime<span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">"是素数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span>cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">"不是素数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//t3_10 编写函数求两个整数的最大公约数和最小公倍数</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//辗转相除法</span><span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">%</span> b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">lcm</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">*</span> b <span class="token operator">/</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最大公约数："</span> <span class="token operator">&lt;&lt;</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最小公倍数："</span> <span class="token operator">&lt;&lt;</span> <span class="token function">lcm</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//t3_13.cpp 用递归的方式编写函数求Fibonacci(斐波那契)级数，观察调用的过程</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第4章-类与对象"><a href="#第4章-类与对象" class="headerlink" title="第4章 类与对象"></a>第4章 类与对象</h2><h3 id="4-1-面向对象程序设计的基本特点"><a href="#4-1-面向对象程序设计的基本特点" class="headerlink" title="4.1 面向对象程序设计的基本特点"></a>4.1 面向对象程序设计的基本特点</h3><h4 id="4-1-1-抽象"><a href="#4-1-1-抽象" class="headerlink" title="4.1.1 抽象"></a>4.1.1 抽象</h4><p>抽象是对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程。<br>首先注意的是问题的本质及描述，其次是解决问题的具体过程<br>对一个问题的抽象应该包括两个方面:数据抽象和行为抽象（或称为功能抽象、代码抽象）<br>前者描述某类对象的属性或状态，后者描述某类对象的共同行为或功能特征<br>例：一个时钟<br>数据抽象：int hour,int minute,int second<br>功能抽象：showTime（）,setTime（）</p><h4 id="4-1-2-封装"><a href="#4-1-2-封装" class="headerlink" title="4.1.2 封装"></a>4.1.2 封装</h4><p>封装就是将抽象得到的数据和行为相结合，形成一个有机的整体，也就是将数据与操作数据的函数代码进行有机的结合，形成”类“，其中的数据和函数都是类的成员</p><p><img src="/images/cpp/image-20210104012147193.png" alt="时钟类"></p><h4 id="4-1-3-继承"><a href="#4-1-3-继承" class="headerlink" title="4.1.3 继承"></a>4.1.3 继承</h4><p>C++语言中提供了类的继承机制，允许程序员在保持原有类特性的基础上，进行更具体更详细的说明。<br>——详见第7章</p><h4 id="4-1-4-多态"><a href="#4-1-4-多态" class="headerlink" title="4.1.4 多态"></a>4.1.4 多态</h4><p>从广义上说，多态性是指一段程序能够处理多种类型对象的能力。在C++语言中，这种多态性可以通过强制多态、重载多态、类型参数化多态、包含多态4种形式来实现。<br>包含多态和类型参数化多态属于一般多态性，是真正的多态性。C++中采用虚函数实现包含多态。虚函数是多态性的精华，将在第8章介绍。模板是C++实现参数化多态性的工具，将在第9章介绍。</p><center><span style="color:blue;font-size:15px">2021/1/4</span></center><h3 id="4-2-类和对象"><a href="#4-2-类和对象" class="headerlink" title="4.2 类和对象"></a>4.2 类和对象</h3><h4 id="4-2-2-类成员的访问控制"><a href="#4-2-2-类成员的访问控制" class="headerlink" title="4.2.2 类成员的访问控制"></a>4.2.2 类成员的访问控制</h4><p>对类成员的访问权限的控制，是通关设置成员的访问控制属性而实现的。访问控制性可以有以下3种：公有类型（public）私有类型（private）和保护类型（protected）<br>公有类型成员定义了类的外部接口<br>私有成员只能被本类的成员函数访问，来自类外部的任何访问都是非法的<br>保护类型成员的性质和私有成员的性质相似，其差别在于继承过程中对产生的新类影响不同（详见第7章）<br>在类中，对于未指定任何访问控制属性的成员，其访问控制属性为私有类型<br>习惯：在书写时通畅将公有类型放在最前面，这样便于阅读，因为它们是外部访问时所要了解的</p><center><span style="color:blue;font-size:15px">2021/1/5</span></center><h4 id="4-2-3-对象"><a href="#4-2-3-对象" class="headerlink" title="4.2.3 对象"></a>4.2.3 对象</h4><p>类实际上是一种抽象机制，它描述了一类事物的共同属性和行为。在C++中，类的对象就是该类的某一特定实体（也称实例）</p><p><strong>注意</strong>：对象所占据的内存空间只是用于存放数据成员，函数成员不在每一个对象中存储副本，每个函数的代码在内存中只占据一份空间。</p><p>在类的外部只能访问到类的共有成员；在类的成员函数中，可以访问到类的全部成员</p><h4 id="4-2-4-类的成员函数"><a href="#4-2-4-类的成员函数" class="headerlink" title="4.2.4 类的成员函数"></a>4.2.4 类的成员函数</h4><h5 id="1-成员函数的实现"><a href="#1-成员函数的实现" class="headerlink" title="1.成员函数的实现"></a>1.成员函数的实现</h5><p>函数的原型声明要写在类体中，原型说明了函数的参数表和返回值类型。而函数的具体实现是写在类定义外的。</p><p>类的成员函数需要用类名来限制，例如”Clock::ShowTime”</p><h5 id="2-成员函数中的目的对象"><a href="#2-成员函数中的目的对象" class="headerlink" title="2.成员函数中的目的对象"></a>2.成员函数中的目的对象</h5><p>调用一个成员函数与调用普通函数的差异在于，需要使用“.”操作符指出调用所针对的对象，这一对象在本次调用中称为目的对象。例如使用myClock.showTime（）调用showTime函数时，myClock就是这一调用过程中的目的对象。</p><p><strong>注意</strong>：在类的成员函数中，既可以访问目的对象的私有成员，又可以访问当前类的其他对象的私有成员</p><h5 id="3-带默认形参值的成员函数"><a href="#3-带默认形参值的成员函数" class="headerlink" title="3.带默认形参值的成员函数"></a>3.带默认形参值的成员函数</h5><p>类的成员函数也可以有默认形参值，其调用规则与普通函数相同</p><h5 id="4-内联成员函数"><a href="#4-内联成员函数" class="headerlink" title="4.内联成员函数"></a>4.内联成员函数</h5><p>要在权衡利弊的基础上慎重选择，只有对相对简单的成员函数才可以声明为内联函数。</p><p>内联函数的声明有两种方法：隐式声明和显式声明</p><p>隐式声明：将函数体直接放在类体内</p><p><img src="/images/cpp/image-20210105124151720.png" alt="隐式声明"></p><p>显式声明：在函数体实现时，在函数返回值类型前加上inline</p><p>显式声明和隐式声明的效果是完全相同的</p><h4 id="4-2-5-程序实例"><a href="#4-2-5-程序实例" class="headerlink" title="4.2.5 程序实例"></a>4.2.5 程序实例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//4_1.cpp 时钟类的完整程序</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Clock</span> <span class="token punctuation">{</span><span class="token comment">//时钟类的定义</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//外部接口，公有成员函数</span><span class="token keyword">void</span> <span class="token function">setTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> newH <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> newM <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> newS <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token comment">//私有数据成员</span><span class="token keyword">int</span> hour<span class="token punctuation">,</span> minute<span class="token punctuation">,</span> second<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//时钟类成员函数的具体实现</span><span class="token keyword">void</span> <span class="token class-name">Clock</span><span class="token operator">::</span><span class="token function">setTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> newH<span class="token punctuation">,</span> <span class="token keyword">int</span> newM<span class="token punctuation">,</span> <span class="token keyword">int</span> newS<span class="token punctuation">)</span> <span class="token punctuation">{</span>hour <span class="token operator">=</span> newH<span class="token punctuation">;</span>minute <span class="token operator">=</span> newM<span class="token punctuation">;</span>second <span class="token operator">=</span> newS<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">Clock</span><span class="token operator">::</span><span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> hour <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> minute <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Clock myclock<span class="token punctuation">;</span><span class="token comment">//定义对象myclock</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"First time set and output:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>myclock<span class="token punctuation">.</span><span class="token function">setTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myclock<span class="token punctuation">.</span><span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Second time set and output"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>myclock<span class="token punctuation">.</span><span class="token function">setTime</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myclock<span class="token punctuation">.</span><span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-构造函数和析构函数"><a href="#4-3-构造函数和析构函数" class="headerlink" title="4.3 构造函数和析构函数"></a>4.3 构造函数和析构函数</h3><h4 id="4-3-1-构造函数"><a href="#4-3-1-构造函数" class="headerlink" title="4.3.1 构造函数"></a>4.3.1 构造函数</h4><p>构造函数的作用是在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的状态。<br>只要有了构造函数，编译器就会在建立新对象的地方自动插入对构造函数调用的代码。<br>调用时无需提供参数的构造函数称为<strong>默认构造函数</strong>，如果类中没有写构造函数，编译器会自动生成一个隐含的默认构造函数，该构造函数的参数列表和函数体皆为空。如果在类中声明了构造函数，编译器便不会生成默认构造函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">/*编译系统生成的隐含的默认构造函数*/</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>构造函数</strong>的函数名与类名相同，而且没有返回值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Clock</span><span class="token punctuation">(</span><span class="token keyword">int</span> NewH<span class="token punctuation">,</span> <span class="token keyword">int</span> NewM<span class="token punctuation">,</span> <span class="token keyword">int</span> NewS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造函数</span>    <span class="token keyword">void</span> <span class="token function">SetTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> NewH<span class="token punctuation">,</span> <span class="token keyword">int</span> NewM<span class="token punctuation">,</span> <span class="token keyword">int</span> NewS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">ShowTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> Hour<span class="token punctuation">,</span> Minute<span class="token punctuation">,</span> Second<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//构造函数的实现：</span><span class="token class-name">Clock</span><span class="token operator">::</span><span class="token function">Clock</span><span class="token punctuation">(</span><span class="token keyword">int</span> NewH<span class="token punctuation">,</span> <span class="token keyword">int</span> NewM<span class="token punctuation">,</span> <span class="token keyword">int</span> NewS<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Hour <span class="token operator">=</span> NewH<span class="token punctuation">;</span>    Minute <span class="token operator">=</span> NewM<span class="token punctuation">;</span>    Second <span class="token operator">=</span> NewS<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作为类的成员函数，构造函数可以直接访问类的所有数据成员，可以是内联函数，可以带有参数表，可以带默认的形参值，也可以重载</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Clock</span> <span class="token punctuation">(</span><span class="token keyword">int</span> newH<span class="token punctuation">,</span> <span class="token keyword">int</span> newM<span class="token punctuation">,</span> <span class="token keyword">int</span> newS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造函数</span>    <span class="token function">Clock</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//构造函数</span>         hour<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>         minute<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>         second<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> newH<span class="token punctuation">,</span> <span class="token keyword">int</span> newM<span class="token punctuation">,</span> <span class="token keyword">int</span> newS<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">void</span> <span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> hour<span class="token punctuation">,</span>minute<span class="token punctuation">,</span>second<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//其他函数实现略</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Clock <span class="token function">c1</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用有参数的构造函数</span>    Clock c2<span class="token punctuation">;</span> <span class="token comment">//调用无参数的构造函数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-2-复制构造函数"><a href="#4-3-2-复制构造函数" class="headerlink" title="4.3.2 复制构造函数"></a>4.3.2 复制构造函数</h4><p>复制构造函数是一种特殊的构造函数，其形参为本类的对象的引用。<br>其作用是使用一个已经存在的对象（由复制构造函数的参数指定），去初始化同类的一个新对象。<br>如果没有定义类的复制构造函数，系统就会在必要时自动生成一个隐含的复制构造函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>   <span class="token keyword">public</span><span class="token operator">:</span>       <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> xx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span> yy<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//构造函数</span>          X<span class="token operator">=</span>xx<span class="token punctuation">;</span> Y<span class="token operator">=</span>yy<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token function">Point</span><span class="token punctuation">(</span>Point <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//复制构造函数</span>       <span class="token keyword">int</span> <span class="token function">GetX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> X<span class="token punctuation">;</span><span class="token punctuation">}</span>       <span class="token keyword">int</span> <span class="token function">GetY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> Y<span class="token punctuation">;</span><span class="token punctuation">}</span>   <span class="token keyword">private</span><span class="token operator">:</span>       <span class="token keyword">int</span>  X<span class="token punctuation">,</span>Y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//复制构造函数的实现</span><span class="token class-name">Point</span><span class="token operator">::</span><span class="token function">Point</span><span class="token punctuation">(</span>Point <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>      X<span class="token operator">=</span>p<span class="token punctuation">.</span>X<span class="token punctuation">;</span>      Y<span class="token operator">=</span>p<span class="token punctuation">.</span>Y<span class="token punctuation">;</span>      cout<span class="token operator">&lt;&lt;</span><span class="token string">"Calling the copy constructor"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通构造函数是在对象创建时被调用，而复制构造函数在以下3种情况下都会被调用。</p><p>（1）当用类的一个对象去初始化该类的另一个对象时。例如</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Point <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Point <span class="token function">b</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//用对象a初始化对象b，复制构造函数被调用</span>    Point c<span class="token operator">=</span>a<span class="token punctuation">;</span>   <span class="token comment">//用对象a初始化对象c，复制构造函数被调用</span>    cout<span class="token operator">&lt;&lt;</span>b<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细节:以上对b和c的初始化都能够调用复制构造函数，两种写法只是形式上有所不同，执行的操作完全相同。</p><p>（2）如果函数的形参是类的对象，调用函数时，进行形参和实参结合时。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>Point p<span class="token punctuation">)</span><span class="token punctuation">{</span>   cout<span class="token operator">&lt;&lt;</span>p<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   Point <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//函数的形参为类的对象，当调用函数时，复制构造函数被调用</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提示：只有把对象用值传递时，才会调用复制构造函数，如果传递引用，则不会调用复制构造函数。<br>由于这一原因，传递比较大的对象时，传递引用会比传值的效率高很多。</p><p>（3）如果函数的返回值是类的对象，函数执行完成返回调用者时。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Point <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       Point <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token comment">//函数的返回值是类对象，返回函数值时，调用复制构造函数</span><span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   Point b<span class="token punctuation">;</span>    b<span class="token operator">=</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//       </span><span class="token punctuation">}</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么在这种情况下，返回函数值时，会调用复制构造函数呢？表面上函数g将a返回给了主函数，但是a是g（）的局部对象，离开建立它的函数g以后就消亡了，不可能在返回主函数后继续生存，所以在处理这种情况时编译系统会在主函数中创建一个无名临时对象，该临时对象的生存期只在函数调用所处的表达式中，也就是表达式”b=g（）”中。执行语句”return a，”时，实际上是调用复制构造函数将a的值复制到临时对象中。函数g运行结束时对象a消失，但临时对象会存在于表达式”b=g（）”中。计算完这个表达式后，临时对象的使命也就完成了，该临时对象便自动消失。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//4_2.cpp 复制构造函数的3种情况</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> xx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> yy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> xx<span class="token punctuation">;</span>y <span class="token operator">=</span> yy<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Point</span><span class="token punctuation">(</span>Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">gety</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Point</span><span class="token operator">::</span><span class="token function">Point</span><span class="token punctuation">(</span>Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> p<span class="token punctuation">.</span>x<span class="token punctuation">;</span>y <span class="token operator">=</span> p<span class="token punctuation">.</span>y<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Calling the copy constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//形参为Point类对象的函数</span><span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span>Point p<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">getx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//返回值为Point类对象的函数</span>Point <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Point <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Point <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Point b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//情况一，用a初始化b。第一次调用复制构造函数</span>cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span><span class="token function">getx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">fun1</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//情况二，对象b作为fun1的实参。第二次调用复制构造函数</span>cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span><span class="token function">getx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//情况三，函数的返回值是类对象，函数返回时，调用复制构造函数</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-3-析构函数"><a href="#4-3-3-析构函数" class="headerlink" title="4.3.3 析构函数"></a>4.3.3 析构函数</h4><p>简单来说，析构函数与构造函数的作用几乎正好相反，它用来完成对象被删除前的一些清理工作，也就是专门做扫尾工作的。析构函数是在对象的生存期即将结束的时刻被<strong>自动调用</strong>的。它的调用完成之后，对象也就消失了，相应的内存空间也被释放。<br>与构造函数一样，析构函数通常也是类的一个公有函数成员，它的名称是由<strong>类名前面加“~”</strong>构成，没有返回值。和构造函数不同的是析构函数不接收任何参数，但可以是虚函数（将在第8章介绍）。如果不进行显式说明，系统也会生成一个函数体为空的隐含析构函数。<br>如果希望程序在对象被删除之前的时刻自动（不需要人为进行函数调用）完成某些事情，就可以把它们写到析构函数中。</p><h4 id="4-3-4-程序实例"><a href="#4-3-4-程序实例" class="headerlink" title="4.3.4 程序实例"></a>4.3.4 程序实例</h4><p>例题：游泳池改造预算，Circle类<br>一圆型游泳池如图所示，现在需在其周围建一圆型过道，并在其四周围上栅栏。栅栏价格为35元/米，过道造价为20元/平方米。过道宽度为3米，游泳池半径由键盘输入。要求编程计算并输出过道和栅栏的造价。<br><img src="/images/cpp/862591-20200301235232229-39158544.png" alt=""></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//4_3.cpp 游泳池改造预算</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">float</span> PI <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">float</span> FENCE_PRICE <span class="token operator">=</span> <span class="token number">35</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">float</span> CONCRETE_PRICE <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>                              <span class="token comment">//声明类Circle 及其数据和方法</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">float</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//构造函数</span>    <span class="token keyword">float</span> <span class="token function">circumference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">//圆周长</span>    <span class="token keyword">float</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//园面积</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">float</span> radius<span class="token punctuation">;</span>                           <span class="token comment">//圆半径</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 类的实现</span><span class="token comment">// 构造函数初始化数据成员radius</span><span class="token class-name">Circle</span><span class="token operator">::</span><span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">float</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    radius <span class="token operator">=</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 计算圆的周长</span><span class="token keyword">float</span> <span class="token class-name">Circle</span><span class="token operator">::</span><span class="token function">circumference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> PI <span class="token operator">*</span> radius<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 计算圆的面积</span><span class="token keyword">float</span> <span class="token class-name">Circle</span><span class="token operator">::</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> PI <span class="token operator">*</span> radius <span class="token operator">*</span> radius<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">float</span> radius<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter the radius of the pool: "</span><span class="token punctuation">;</span>    cin <span class="token operator">&gt;&gt;</span> radius<span class="token punctuation">;</span>    Circle <span class="token function">Pool</span><span class="token punctuation">(</span>radius<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//游泳池边界对象</span>    Circle <span class="token function">PoolRim</span><span class="token punctuation">(</span>radius <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">//栅栏对象</span>    <span class="token comment">// 计算栅栏造价并输出</span>    <span class="token keyword">float</span> fenceCost <span class="token operator">=</span> PoolRim<span class="token punctuation">.</span><span class="token function">circumference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> FENCE_PRICE<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Fencing Cost is $"</span> <span class="token operator">&lt;&lt;</span> fenceCost <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">//  计算过道造价并输出</span>    <span class="token keyword">float</span> concreteCost <span class="token operator">=</span> <span class="token punctuation">(</span>PoolRim<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> Pool<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span>CONCRETE_PRICE<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Concrete Cost is $"</span> <span class="token operator">&lt;&lt;</span> concreteCost <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-类的组合"><a href="#4-4-类的组合" class="headerlink" title="4.4 类的组合"></a>4.4 类的组合</h3><p>在面向对象程序设计中，可以对复制对象进行分解，抽象，把一个复制对象分解为简单对象的组合</p><h4 id="4-4-1-组合"><a href="#4-4-1-组合" class="headerlink" title="4.4.1 组合"></a>4.4.1 组合</h4><p>当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建。在创建对象时既要对本类的基本类型数据进行初始化，又要对内嵌对象成员进行初始化。<br>构造函数的调用顺序如下：<br>（1）调用内嵌对象的构造函数，调用顺序按照内嵌对象在组合类的定义中出现的次序<br>（2）执行本类构造函数的函数体<br>析构函数的调用执行顺序与构造函数刚好相反</p><center><span style="color:blue;font-size:15px">2021/1/6</span></center><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//4_4.cpp 类的组合，线段（line）类</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cmath&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//Point类定义</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> xx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> yy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> xx<span class="token punctuation">;</span>y <span class="token operator">=</span> yy<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Point</span><span class="token punctuation">(</span>Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Point</span><span class="token operator">::</span><span class="token function">Point</span><span class="token punctuation">(</span>Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> p<span class="token punctuation">.</span>x<span class="token punctuation">;</span>y <span class="token operator">=</span> p<span class="token punctuation">.</span>y<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Calling the copy constructor of Point"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//类的组合</span><span class="token keyword">class</span> <span class="token class-name">Line</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Line</span><span class="token punctuation">(</span>Point xp1<span class="token punctuation">,</span> Point xp2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Line</span><span class="token punctuation">(</span>Line<span class="token operator">&amp;</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>Point p1<span class="token punctuation">,</span> p2<span class="token punctuation">;</span><span class="token keyword">double</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//组合类的构造函数</span><span class="token class-name">Line</span><span class="token operator">::</span><span class="token function">Line</span><span class="token punctuation">(</span>Point xp1<span class="token punctuation">,</span> Point xp2<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p1</span><span class="token punctuation">(</span>xp1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p2</span><span class="token punctuation">(</span>xp2<span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Calling constructor of Line"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> p2<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> p2<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>len <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x <span class="token operator">+</span> y <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//组合类的复杂构造函数</span><span class="token class-name">Line</span><span class="token operator">::</span><span class="token function">Line</span><span class="token punctuation">(</span>Line<span class="token operator">&amp;</span> l<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">p1</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>p1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p2</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Callint the copy constructor of Line"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>len <span class="token operator">=</span> l<span class="token punctuation">.</span>len<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Point <span class="token function">myp1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">myp2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Line <span class="token function">line</span><span class="token punctuation">(</span>myp1<span class="token punctuation">,</span> myp2<span class="token punctuation">)</span><span class="token punctuation">;</span>Line <span class="token function">line2</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The length of the line is: "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> line<span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The length of the line2 is: "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> line2<span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp/image-20210106101543263.png" alt="运行结果"></p><h4 id="4-4-2-向前引用声明"><a href="#4-4-2-向前引用声明" class="headerlink" title="4.4.2 向前引用声明"></a>4.4.2 向前引用声明</h4><p>如果遇到两个类相互引用的情况，应使用前向引用声明</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Fred</span><span class="token punctuation">;</span><span class="token comment">//前向引用声明</span>  <span class="token keyword">class</span> <span class="token class-name">Barney</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     x<span class="token punctuation">.</span><span class="token function">yabbaDabbaDo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//错误：Fred类的对象在定义之前被使用</span>   <span class="token punctuation">}</span> <span class="token keyword">private</span><span class="token operator">:</span>   Fred <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>   <span class="token comment">//正确，经过前向引用声明，可以声明Fred类的对象指针</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">class</span> <span class="token class-name">Fred</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">void</span> <span class="token function">yabbaDabbaDo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">private</span><span class="token operator">:</span>   Barney <span class="token operator">&amp;</span>y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器在编译时会指出错误，因为在类Barney的内联函数中使用了由x所指向的Fred类的对象，而此时Fred类尚未被完整地定义。解决这个问题的方法是，更改这两个类的定义次序，或者将函数method()改为非内联形式，并且在类Fred的完整定义之后，再给出函数的定义。</p><p><strong>注意</strong>：当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。</p><h3 id="4-5-UML图形标识"><a href="#4-5-UML图形标识" class="headerlink" title="4.5 UML图形标识"></a>4.5 UML图形标识</h3><p>UML语言是一个复杂、庞大的系统建模语言，其目标是希望能够解决整个面向对象软件开发过程中的可视化建模。</p><h4 id="4-5-1-UML简介"><a href="#4-5-1-UML简介" class="headerlink" title="4.5.1 UML简介"></a>4.5.1 UML简介</h4><p>统一建模语言UML ( Unified Modeling Language)</p><p>UML语言是一种典型的面向对象建模语言，而不是一种编 程语言，在UMI语言中用符号描述概念，概念间的关系描述为连接符号的线。</p><p>标准建模语言UML的重要内容是各种类型的图形，分别描述软件模型的静态结构、动态行为及模块组织和管理。本书主要使用UML中的图形来描述软件中类和对象以及它们的静态关系，使用了最基本的类图(classdiagram)，它属于静态结构图(staticstructure diagrams)的一种。</p><h4 id="4-5-2-UML类图"><a href="#4-5-2-UML类图" class="headerlink" title="4.5.2 UML类图"></a>4.5.2 UML类图</h4><p>1.类和对象</p><p><img src="/images/cpp/image-20210106124232727.png" alt="UML类图例"></p><p>2.几种关系的图形标识</p><p>（1）依赖关系</p><p><img src="/images/cpp/image-20210106124626064.png" alt="依赖关系"></p><p>（2）作用关系——关联</p><p><img src="/images/cpp/image-20210106124647931.png" alt="关联关系"></p><p>（3）包含关系——聚集和组合</p><p><img src="/images/cpp/image-20210106125143796.png" alt="包含关系"></p><p>（4）继承关系——泛化</p><p><img src="/images/cpp/image-20210106125427699.png" alt="继承关系"></p><h3 id="4-6-结构和结构体"><a href="#4-6-结构和结构体" class="headerlink" title="4.6 结构和结构体"></a>4.6 结构和结构体</h3><h4 id="4-6-1-结构体"><a href="#4-6-1-结构体" class="headerlink" title="4.6.1 结构体"></a>4.6.1 结构体</h4><p>结构体是一种特殊的类。结构体和类的唯一区别在于：在类中，对于未指定任何访问控制属性的成员，其访问控制属性为私有类型；在结构体中，对于未指定任何访问控制属性的成员，其访问控制属性为公有类型；</p><p>类和结构体的并存，是由历史原因（保持和c程序的兼容性）造成的，如果完全不使用结构体，也丝毫不会影响程序的表达能力。</p><h4 id="4-6-2-联合体"><a href="#4-6-2-联合体" class="headerlink" title="4.6.2 联合体"></a>4.6.2 联合体</h4><p>联合体是一种特殊形态的类，它的默认控制属性也是公共类型的，联合体的全部数据成员共享同一组内存单元。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">union</span> Mark <span class="token punctuation">{</span>    <span class="token keyword">char</span> grade<span class="token punctuation">;</span>    <span class="token keyword">bool</span> pass<span class="token punctuation">;</span>    <span class="token keyword">int</span> percent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp/image-20210106190029141.png" alt="联合体"></p><p>正是由于联合体的成员共用同样的内存单元，联合体变量中的成员同时至多只有一个是有意义的</p><p>联合体也可以补声明名称，称为无名联合体，可以由成员项的名字直接访问。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//4_8.cpp 使用联合体保存成绩信息，并且输出</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ExamInfo</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">ExamInfo</span><span class="token punctuation">(</span>string name<span class="token punctuation">,</span> <span class="token keyword">char</span> grade<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mode</span><span class="token punctuation">(</span>GRADE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">grade</span><span class="token punctuation">(</span>grade<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">ExamInfo</span><span class="token punctuation">(</span>string name<span class="token punctuation">,</span> <span class="token keyword">bool</span> psss<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mode</span><span class="token punctuation">(</span>PASS<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pass</span><span class="token punctuation">(</span>pass<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">ExamInfo</span><span class="token punctuation">(</span>string name<span class="token punctuation">,</span> <span class="token keyword">int</span> percent<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mode</span><span class="token punctuation">(</span>PERCENTAGE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">percent</span><span class="token punctuation">(</span>percent<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>string name<span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token punctuation">{</span>GRADE<span class="token punctuation">,</span>PASS<span class="token punctuation">,</span>PERCENTAGE<span class="token punctuation">}</span>mode<span class="token punctuation">;</span><span class="token keyword">union</span> <span class="token punctuation">{</span><span class="token keyword">char</span> grade<span class="token punctuation">;</span><span class="token keyword">bool</span> pass<span class="token punctuation">;</span><span class="token keyword">int</span> percent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token class-name">ExamInfo</span><span class="token operator">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>mode<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> GRADE<span class="token operator">:</span> cout <span class="token operator">&lt;&lt;</span> grade<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> PASS<span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>pass <span class="token operator">?</span> <span class="token string">"PASS"</span> <span class="token operator">:</span> <span class="token string">"FAIL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> PERCENTAGE<span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> percent<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ExamInfo <span class="token function">course1</span><span class="token punctuation">(</span><span class="token string">"English"</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ExamInfo <span class="token function">course2</span><span class="token punctuation">(</span><span class="token string">"Calculus"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ExamInfo <span class="token function">course3</span><span class="token punctuation">(</span><span class="token string">"C++ Programming"</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">)</span><span class="token punctuation">;</span>course1<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> course2<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>course3<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp/image-20210106192518724.png" alt="运行结果"></p><h3 id="4-7-综合实例——个人银行账户管理系统"><a href="#4-7-综合实例——个人银行账户管理系统" class="headerlink" title="4.7 综合实例——个人银行账户管理系统"></a>4.7 综合实例——个人银行账户管理系统</h3><p><img src="/images/cpp/image-20210119130143620.png" alt="UML图"></p><h4 id="4-7-2-源程序及说明"><a href="#4-7-2-源程序及说明" class="headerlink" title="4.7.2 源程序及说明"></a>4.7.2 源程序及说明</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//4_9.cpp 个人银行账户管理系统</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cmath&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SavingsAccount</span> <span class="token punctuation">{</span><span class="token comment">//储蓄账户类</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token comment">//账户</span><span class="token keyword">double</span> balance<span class="token punctuation">;</span><span class="token comment">//余额</span><span class="token keyword">double</span> rate<span class="token punctuation">;</span><span class="token comment">//存款的年利率</span><span class="token keyword">int</span> lastDate<span class="token punctuation">;</span><span class="token comment">//上次变更余额的时间</span><span class="token keyword">double</span> accumulation<span class="token punctuation">;</span><span class="token comment">//余额按日累加之和</span><span class="token comment">//记录一笔账，date为日期，amount为金额，desc为说明</span><span class="token keyword">void</span> <span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获得到指定日期为止的存款金额按日累积值</span><span class="token keyword">double</span> <span class="token function">accumulate</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> accumulation <span class="token operator">+</span> balance <span class="token operator">*</span> <span class="token punctuation">(</span>date <span class="token operator">-</span> lastDate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> rate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> id<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> balance<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">getRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rate<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">deposit</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//存入现金</span><span class="token keyword">void</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//取出现金</span><span class="token comment">//结算利息，每年1月1日调用一次该函数</span><span class="token keyword">void</span> <span class="token function">settle</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示账户信息</span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> rate<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">balance</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rate</span><span class="token punctuation">(</span>rate<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lastDate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">accumulation</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> date <span class="token operator">&lt;&lt;</span> <span class="token string">"\t#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"is created"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>accumulation <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>lastDate <span class="token operator">=</span> date<span class="token punctuation">;</span>amount <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>amount <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//保留小数点后两位</span>balance <span class="token operator">+=</span> amount<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> date <span class="token operator">&lt;&lt;</span> <span class="token string">"\t#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> amount <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> balance <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">&gt;</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error:not enough money"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token operator">-</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">double</span> interest <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span> <span class="token operator">*</span> rate <span class="token operator">/</span> <span class="token number">365</span><span class="token punctuation">;</span><span class="token comment">//计算年息</span><span class="token keyword">if</span> <span class="token punctuation">(</span>interest <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> interest<span class="token punctuation">)</span><span class="token punctuation">;</span>accumulation <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"\tBalance:"</span> <span class="token operator">&lt;&lt;</span> balance<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>SavingsAccount <span class="token function">sa0</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">21325302</span><span class="token punctuation">,</span> <span class="token number">0.015</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SavingsAccount <span class="token function">sa1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">58320212</span><span class="token punctuation">,</span> <span class="token number">0.015</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa0<span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa0<span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">5500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开户后第90天到了银行的计息日，结算所有账户的年息</span>sa0<span class="token punctuation">.</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出各个账户信息</span>sa0<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp/image-20210106201828486.png" alt="输出结果"></p><center><span style="color:blue;font-size:15px">2021/1/7</span></center><h3 id="4-8-深度探索"><a href="#4-8-深度探索" class="headerlink" title="4.8 深度探索"></a>4.8 深度探索</h3><h4 id="4-8-1-位域"><a href="#4-8-1-位域" class="headerlink" title="4.8.1 位域"></a>4.8.1 位域</h4><p>位域是一种允许将类的多个数据成员打包，从而使不同的成员可以共享相同的字节的机制<br>只有bool、char、int、enum的成员才能被定义为位域<br>位域虽然节省了内存空间，但由于打包和解包的过程中需要耗费额外的操作，所以运行时间可能会增加</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Level</span><span class="token punctuation">{</span>FRTSHMEN<span class="token punctuation">,</span>SOPHOMORE<span class="token punctuation">,</span>JUNIOR<span class="token punctuation">,</span>SENIOR<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">Grade</span><span class="token punctuation">{</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>C<span class="token punctuation">,</span>D<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">unsigned</span> number <span class="token operator">:</span> <span class="token number">27</span><span class="token punctuation">;</span>Level level <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>Grade grade <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果用整型存储学号（占用4字节）用枚举型存储年级和等级（各至少占用1字节）<br>而用位域，则需要27+2+2=31个二进制位看，只需要4个字节就能放下</p><h4 id="4-8-2-用构造函数定义类型转换"><a href="#4-8-2-用构造函数定义类型转换" class="headerlink" title="4.8.2 用构造函数定义类型转换"></a>4.8.2 用构造函数定义类型转换</h4><h5 id="1-用构造函数定义的类型转换"><a href="#1-用构造函数定义的类型转换" class="headerlink" title="1.用构造函数定义的类型转换"></a>1.用构造函数定义的类型转换</h5><p>2.2.5小节已经介绍了基本数据类型的类型转换。事实上，用户也可以为类类型定义类型转换。</p><p>4.3.2小节曾经介绍，当一个函数的返回类型为类类型时，函数调用返回后，一个无名的临时对象会被创建,这种创建不是由用户显式指定的，而是隐含发生的，事实上，临时对象也可以显式创建,方法是直接使用类名调用这个类的构造函数。例如，如果希望使用例4-4中定义的Point 和Line两个类计算一个线段的长度，可以不创建有名的点对象和线段对象，而使用这种方式:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout<span class="token operator">&lt;&lt;</span><span class="token function">Line</span><span class="token punctuation">(</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>其实这正是类型转换——将整型数据类型转换为Point型对象的显式类型转换</strong><br>C++中可以通过构造函数，来自定义类型之间的转换。一个构造函数，只要可以用一个参数调用，那么它就设定了一种从参数类型到这个类类型的类型转换。由于是类型转换，所以上面一行代码，还可以写成下面两种等效形式:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout<span class="token operator">&lt;&lt;</span><span class="token function">Line</span><span class="token punctuation">(</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>Point<span class="token punctuation">)</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout<span class="token operator">&lt;&lt;</span><span class="token function">Line</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Point<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Point<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的类型转换操作符可以省去，因为默认情况下，类的构造函数所规定的类型转换，允许通过隐含类型转换进行。也就是说，可以写成这种形式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout<span class="token operator">&lt;&lt;</span><span class="token function">Line</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-只允许显式执行的类型转换"><a href="#2-只允许显式执行的类型转换" class="headerlink" title="2.只允许显式执行的类型转换"></a>2.只允许显式执行的类型转换</h5><p>只要在构造函数前加上explicit关键字，以这个构造函数定义的类型转换，只能通过显式转换的方式完成。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">explicit</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> xx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span> yy<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-8-3-对象作为函数参数和返回值的传递方法"><a href="#4-8-3-对象作为函数参数和返回值的传递方法" class="headerlink" title="4.8.3 对象作为函数参数和返回值的传递方法"></a>4.8.3 对象作为函数参数和返回值的传递方法</h4><p>函数调用时传递基本类型的数据是通过运行栈，传递对象也一样是通过运行栈。运行栈中，在主调函数和被调函数之间，有一块二者都要访问的公共区域，主调函数把实参值写入其中，函数调用发生后，被调函数通过读取这段区域就可得到形参值。需要传递的对象，只要建立在运行栈的这段区域上即可。传递基本类型数据与传递对象的不同之处在于，将实参值复制到这段区域上时，对于基本数据类型的参数，做一般的内存写操作即可，但对于对象参数，则需要调用复制构造函数。例如，例4-2之中，在main函数中调用下面这个函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">fun1</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用它时，就需要调用Point的复制构造函数，使用对象b在运行栈的传参区域上构造一个临时对象。</p><p><img src="/images/cpp/image-20210107131230507.png" alt="传递方法"></p><h2 id="第5章-数据的共享与保护"><a href="#第5章-数据的共享与保护" class="headerlink" title="第5章 数据的共享与保护"></a>第5章 数据的共享与保护</h2><h3 id="5-1-标识符的作用域与可见性"><a href="#5-1-标识符的作用域与可见性" class="headerlink" title="5.1 标识符的作用域与可见性"></a>5.1 标识符的作用域与可见性</h3><h4 id="5-1-1-作用域"><a href="#5-1-1-作用域" class="headerlink" title="5.1.1 作用域"></a>5.1.1 作用域</h4><p>作用域是一个标识符在程序正文中有效的区域</p><p><strong>1.函数原型作用域</strong><br>C++程序中最小的作用域，在函数原型声明时形式参数的作用范围就是函数原型作用域。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token keyword">double</span> radius<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>标识符radius的作用范围就这函数area形参列表的左右括号之间</p><p><strong>2.局部作用域</strong><br>具有局部作用域的变量也称为局部变量</p><p><strong>3.类作用域</strong></p><p>类可以被看成是一组有名成员的集合，类X的成员m具有类作用域，对m的访向式有如下3种。<br>（1）如果在x的成员函数中没有声明同名的局部作用域标识符,那么在该函数内可以直接访问成员m。也就是说m在这样的函数中都起作用。<br>（2）通过表达式义X.m或者X::m。这正是程序中访间对象成员的最基本方法。X::m的方式用于访问类的静态成员，相关内容将在5.3节介绍。<br>（3）通过ptr-&gt;m这样的表达式，其中ptr为指向X类的一个对象的指针。关于指针将在第6章详细介绍。</p><p><strong>4.命名空间作用域</strong><br>不同模块的类和函数之间可能发生重名，这样就会引发错误，命名空间用来消除歧义。<br>在命名空间内可以直接引用当前命名空间中声明的标识符，如果需要引用其他命名空间的标识符，需要使用下面的语法：</p><pre class="line-numbers language-none"><code class="language-none">命名空间名::标识符名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有时这样使用会过于冗长，为了解决这一问题，C++又提供了using语句：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> 命名空间名<span class="token operator">::</span>标识符名<span class="token keyword">using</span> <span class="token keyword">namespace</span> 命名空间名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>前一种形式将指定的标识符暴露在当前的作用域内；<br>后一种形式将指定命名空间内的所有标识符暴露在当前的作用域内。<br>C++标准程序库的所有标识符都被声明在std命名空间内，如果去掉了using namespace std这条语句，则引用相应的标识符需要使用std::cin、std::cout、std::endl这样的语法。<br>命名空间也允许嵌套。<br>此外，还有两类特殊的命名空间——全局命名空间和匿名命名空间。全局命名空间空间是默认的命名空间，在显式命名空间之外的标识符都在一个全局命名空间中，匿名命名空间是一个需要显式声明的没有名字的命名空间，声明方法如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span><span class="token punctuation">{</span>匿名命名空间内的各种声明（函数声明、类声明）<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在包含多个源文件的工程中，匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符，这是因为每个源文件的匿名命名空间是彼此不同的，在一个源文件中没有办法访问其他源文件的匿名命名空间。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//5_1.cpp 作用域实例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//在全局命名空间内的全局变量</span><span class="token keyword">namespace</span> Ns <span class="token punctuation">{</span><span class="token keyword">int</span> j<span class="token punctuation">;</span><span class="token comment">//在Ns命名空间中的全局变量</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>Ns<span class="token operator">::</span>j <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token punctuation">{</span><span class="token comment">//子块1</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> Ns<span class="token punctuation">;</span><span class="token comment">//使得在当然块中可以直接引用Ns命名空间的标识符</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//局部变量，局部作用域</span>i <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i="</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出7</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"j="</span> <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出6</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i="</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出5</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量j也具有命名空间作用域，他被声明在命名空间Ns中；<br><strong>具有命名空间作用域的变量也称为全局变量</strong></p><h4 id="5-1-2-可见性"><a href="#5-1-2-可见性" class="headerlink" title="5.1.2 可见性"></a>5.1.2 可见性</h4><p> 程序运行到某一点，能够引用到的标识符，就是该处可见的标识符。</p><h3 id="5-2-对象的生存期"><a href="#5-2-对象的生存期" class="headerlink" title="5.2 对象的生存期"></a>5.2 对象的生存期</h3><p>对象从诞生到结束的这段时间就是它的生存期</p><h4 id="5-2-1-静态生存期"><a href="#5-2-1-静态生存期" class="headerlink" title="5.2.1 静态生存期"></a>5.2.1 静态生存期</h4><p>如果对象的生存期与程序的运行期相同，则称它具有静态生存期。在命名空间作用域中声明的对象都是具有静态生存期的。如果在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字<strong>static</strong><br>在定义静态变量的同时也可以为它赋初值，例如</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这表示i会被赋值5初始化，而非每次执行函数时都将i赋值为5</p><h4 id="5-2-2-动态生存期"><a href="#5-2-2-动态生存期" class="headerlink" title="5.2.2 动态生存期"></a>5.2.2 动态生存期</h4><p>除了上述两种情况，其余的对象都具有动态生存期</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//5_2.cpp 变量的生存期与可见性</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//i为全局变量,具有静态生存期</span><span class="token keyword">void</span> <span class="token function">other</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//a, b为静态局部变量,具有全局寿命,局都可见,只第一次进入函数时被初始化</span><span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token comment">//c为局部变量,具有动态生存期，每次进入函数时都初始化</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>a <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>i <span class="token operator">+=</span> <span class="token number">32</span><span class="token punctuation">;</span>c <span class="token operator">+=</span> <span class="token number">5</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"--- OTHER---"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" i: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" b: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" c: "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//a为静态局都变量,具有全局寿命,局都可见</span><span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token comment">//b, c为局都变量，具有动态生存期</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"---MAIN---"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" i: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" b: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" c: "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>c <span class="token operator">+=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token function">other</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"---MAIN---"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" i: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" b: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" c: "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>i <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">other</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-类的静态成员"><a href="#5-3-类的静态成员" class="headerlink" title="5.3 类的静态成员"></a>5.3 类的静态成员</h3><h4 id="5-3-1-静态数据成员"><a href="#5-3-1-静态数据成员" class="headerlink" title="5.3.1 静态数据成员"></a>5.3.1 静态数据成员</h4><p>面向对象方法中还有“类属性”的概念。如果某个属性为整个类所共有，不属于任何个具体对象，则采用static 关键字来声明为静态成员。<br>静态数据成员具有静态生存期，由于静态数据成员不属于任何一个对象，因此可以通过类名对它进行访问，一般的用法息”类名::标识特”。在类的定义中仅仅对静态数据成员进行引用性声明，必须在命名空同作用域的某个地方使用类名限定性声明，这时也可以进行初始化。<br><strong>提示：</strong>之所以类的静态数据成员需要在类定义之外再加以定义，是因为需要以这种方式专门为它们分配空间。非静态数据成员无须以此方式定义，因为它们的空间是与它们所属对象的空间同时分配的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>count<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x，y<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Point<span class="token operator">::</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//静态数据成员定义和初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-2-静态函数成员"><a href="#5-3-2-静态函数成员" class="headerlink" title="5.3.2 静态函数成员"></a>5.3.2 静态函数成员</h4><p>所谓静态成员函数就是使用static关键字声明的函数成员。同静态数据成员一样，静态成员函数也属于整个类，由同一个类的所有对象共同拥有，为这些对象所共享。<br>静态成员函数可以通过类名或对象名调用，而非静态成员函数只能通过对象名来调用。<br>静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名。</p><h3 id="5-4-类的友元"><a href="#5-4-类的友元" class="headerlink" title="5.4 类的友元"></a>5.4 类的友元</h3><p>友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。<br>在一个类中,可以利用关键字friend 将其他函数或类声明为友元。如果友元是一般函数或类的成员函数，称为友元函数；如果友元是一个类 ，则称为友元类，友元类的所有成员函数都自动成为友元函数。</p><h4 id="5-4-1-友元函数"><a href="#5-4-1-友元函数" class="headerlink" title="5.4.1 友元函数"></a>5.4.1 友元函数</h4><p>友元函数是在类中用关键字friend修饰的非成员函数。友元函数可以是一个普通的函数，也可以是其他类的成员函数。虽然它不是本类的成员函数，但是在它的函数体中可以通过对象名访问类的私有和保护成员。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//5_6.cpp 使用友元函数计算两点间的距离</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token comment">//Point类定义</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">friend</span> <span class="token keyword">float</span> <span class="token function">dist</span><span class="token punctuation">(</span>Point<span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> Point<span class="token operator">&amp;</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//友元函数声明</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">float</span> <span class="token function">dist</span><span class="token punctuation">(</span>Point<span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> Point<span class="token operator">&amp;</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//友元函数实现</span><span class="token keyword">double</span> x <span class="token operator">=</span> p1<span class="token punctuation">.</span>x <span class="token operator">-</span> p2<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token comment">//通过对象访问私有数据成员</span><span class="token keyword">double</span> y <span class="token operator">=</span> p1<span class="token punctuation">.</span>y <span class="token operator">-</span> p2<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x <span class="token operator">+</span> y <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Point <span class="token function">myp1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">myp2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The distance is: "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">dist</span><span class="token punctuation">(</span>myp1<span class="token punctuation">,</span> myp2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-2-友元类"><a href="#5-4-2-友元类" class="headerlink" title="5.4.2 友元类"></a>5.4.2 友元类</h4><p>同友元函数一样，一个类可以将另一个类声明为友元类。若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员。声明友元类的语法形式为:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">;</span>       <span class="token comment">//声明A为B的友元类  </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关于友元，还有几点需要往意：<br><strong>第一</strong>，友元关系是不能传递的，B类是 A类的友元，C类是B类的友元，C类和A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享。<br><strong>第二</strong>，友元关系是单向的。<br><strong>第三</strong>，友元关系是不被继承的，如果类B是类A的友元，类B的派生类并不会自动成为类A的友元。</p><h3 id="5-5-共享数据的保护"><a href="#5-5-共享数据的保护" class="headerlink" title="5.5 共享数据的保护"></a>5.5 共享数据的保护</h3><h4 id="5-5-1-常对象"><a href="#5-5-1-常对象" class="headerlink" title="5.5.1 常对象"></a>5.5.1 常对象</h4><p>常对象的数据成员值在对象的整个生存期间内不能被改变。也就是说，常对象必须进行初始化，而且不能被更新。</p><h4 id="5-5-2-用const修饰的类成员"><a href="#5-5-2-用const修饰的类成员" class="headerlink" title="5.5.2 用const修饰的类成员"></a>5.5.2 用const修饰的类成员</h4><p><strong>1.常成员函数</strong><br>使用const关键字修饰的函数为常成员函数，常成员函数声明的格式如下:<br>类型说明符 函数名(参数表) const;<br><strong>注意</strong>：<br>(1)const是函数类型的一个组成部分，因此在函数的定义部分也要带const关键字，<br>(2)如果将一个对象说明为常对象，则通过该常对象只能调用它的常成员函数，而不能调用其他成员函数(这就是C++从语法机制上对常对象的保护，也是常对象唯一的对外接口方式)。<br>(3)无论是否通过常对象调用常成员函数，在常成员函数调用期间，<span style="color:green;font-size:15px"><strong>目的对象</strong></span><strong>都被视同为常对象</strong>，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有用const 修饰的成员函数(这就保证了在常成员函数中不会更改目的对象的数据成员的值)。<br>(4)const关键字可以用于对重载函数的区分。<br><strong>提示</strong>：<br>如果仅以const关键字为区分对成员函数重载，那么通过非const 的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的重载函数——不带const关键字的函数。<br><strong>习惯</strong>：<br>在适当的地方使用const关键字，是能够提高程序质量的一个好习惯。对于无须改变对象状态的成员函数，都应当使用const。</p><p><strong>2.常数据成员</strong></p><p>就像一般数据一样，类的成员数据也可以是常量，使用const说明的数据成员为常数据成员。如果在一个类中说明了常数据成员，那么任何函数中都不能对该成员赋值。构造函数对该数据成员进行初始化，就只能通过初始化列表。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//5_8.cpp 常数据成员举例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token comment">//静态常数据成员</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> A<span class="token operator">::</span>b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//静态常数据成员在类外说明和初始化</span><span class="token comment">//常数据成员只能通过初始化列表来获得初值</span><span class="token class-name">A</span><span class="token operator">::</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">A</span><span class="token operator">::</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>A <span class="token function">a1</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">a2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp/image-20210107224500388.png" alt="运行结果"></p><h4 id="5-5-3-常引用"><a href="#5-5-3-常引用" class="headerlink" title="5.5.3 常引用"></a>5.5.3 常引用</h4><p>如果在声明中引用const修饰，被声明的引用就是常引用。常引用所引用的对象不能被更新。<br>非const的引用只能绑定到普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象。一个常引用，无论是绑定到一个普通的对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象。这意味着，对于基本数据类型的引用，则不能为数据赋值，对于类类型的引用，则不能修改它的数据成员，也不能调用它的非const的成员函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//5_9.cpp  在例5-6的基础上修改，使其中的dist函数的形参以常引用方式传递</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cmath&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">friend</span> <span class="token keyword">float</span> <span class="token function">dist</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point <span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">float</span> <span class="token function">dist</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point <span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">double</span> x <span class="token operator">=</span> p1<span class="token punctuation">.</span>x <span class="token operator">-</span> p2<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token keyword">double</span> y <span class="token operator">=</span> p1<span class="token punctuation">.</span>y <span class="token operator">-</span> p2<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x <span class="token operator">+</span> y <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> Point <span class="token function">myp1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">myp2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The distance is: "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">dist</span><span class="token punctuation">(</span>myp1<span class="token punctuation">,</span> myp2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>习惯：</strong>对于在函数中无须改变其值的参数，不宜使用普通引用方式传递，因为那会使得常对象无法被传入，因此传递常引用为宜。复制构造函数的参数一般也宜采用常引用传递。</p><h3 id="5-6-多文件结构和编译预处理指令"><a href="#5-6-多文件结构和编译预处理指令" class="headerlink" title="5.6 多文件结构和编译预处理指令"></a>5.6 多文件结构和编译预处理指令</h3><h4 id="5-6-1-C-程序的一般组织结构"><a href="#5-6-1-C-程序的一般组织结构" class="headerlink" title="5.6.1 C++程序的一般组织结构"></a>5.6.1 C++程序的一般组织结构</h4><p>到现在为止，已经学习了很多完整的C++源程序实例,分析它们的结构，基本上都是由3个部分来构成，类的定义、类的成员的实现和主函数，因为所举的例子都比较小，所有这3个部分都写在同一个文件中。在规模较大的项目中，往往需要多个源程序文件，每个源程序文件称为一个编译单元。这时C++语法要求一个类的定义必须出现在所有使用该类的编译单元中。比较好的，也是惯用的做法是将类的定义写在头文件中，使用该类的编译单元则包含这个头文件。通常一个项目至少划分为3个文件; 类定义文件(*.h文件)、类实现文件(*.cpp文件)和类的使用文件(*. cpp，主函数文件)。对于更为复杂的程序，每一个类都有单独的定义和实现文件。采用这样的组织结构，可以对不同的文件进行单独编写、编译，最后再连接，同时可以充分利用类的封装特性，在程序的调试、修改时只对其中某一个类的定义和实现进行修改，而其余部分不用改动。</p><p>分析整个源程序的结构，由3个单独的源文件构成，它们的相互关系和编译、连接过程可以用图5-8表示(这里是Windows操作系统的情形，UNIX操作系统中生成文件的后缀会有所不同)。</p><p><img src="/images/cpp/image-20210107234218610.png" alt="多文件组织结构图"></p><p>从图5-8可以看到，两个. cpp的文件被分别编译生成各自的目标文件. obj，然后再与系统的运行库共同连接生成可执行文件. exe。如果只修改了类的成员函数的实现部分，则只重新编译point. cpp并连接即可，其余的文件几乎可以连看都不用看。 如果是一个语句很多、规模特大的程序，效率就会得到显著的提高。</p><p>决定一个声明放在源文件中还是头文件中的一般原则是 ，将需要分配空间的定义放在源文件中，例如函数的定义(需要为函数代码分配空间)、命名空间作用域中变量的定义(需要为变量分配空间)等；而将不需要分配空间的声明放在头文件中，例如类声明、外部函数的原型声明、外都变量的声明(外部函数和外部变量将在5.6.2节中详细讨论、基本数据类型常量的声明等。内联函数比较特殊，由于它的内容需要嵌入到每个调用它的函数之中，所以对于那些需要被多个编译单元调用的内联函数，它们的代码应该被各个编译单元可见，这些内联函数的定义应当出现在头文件中。</p><h4 id="5-6-2-外部变量与外部函数"><a href="#5-6-2-外部变量与外部函数" class="headerlink" title="5.6.2 外部变量与外部函数"></a>5.6.2 外部变量与外部函数</h4><p><strong>1.外部变量</strong><br>如果一个变量除了在定义它的源文件中可以使用外。还能被其他文件使用，那么就称这个变成是外部变量。命名空间作用域中定义的变量，默认情况下都是外部变量，但在其他文件中如果需要使用这一变量，需要用extern关键字加以声明。</p><p>在命名空间作用域中，不用extern关键字声明的变量，都是定义性声明；用extern关键字声明的变量，如果同时指定了初值，则是定义性声明，否则是引用性声明。外部变量可以有多处声明，但是定义性声明只能是唯一的。</p><p><strong>2.外部函数</strong><br>在所有类之外声明的函数(也就是非成员函数)，都是具有命名空间作用域的，如果没有特殊说明，这样的函数都可以在不同的编译单元中被调用，只要在调用之前进行引用性声明(即声明函数原型)即可。当然，也可以在声明函数原型或定义函数时用extern修饰，其效果与不加修饰的默认状态是一样的。</p><p><strong>习惯：</strong>通常情况下 ,变量和函数的定义都放在源文件中，而对外部变量和外部函数的引用性声明则放在头文件中。</p><p><strong>3.将变量和函数限制在编译单元内</strong><br>命名空间作用域中声明的变量和函数，在默认情况下都可以被其他编译单元访问,但有时不希望一个源文件中定义的命名空间作用域的变量和函数被其他源文件引用。这种需求主要是出于两个原因，一是出于安全性考虑，不希望将—个只会在文件内使用的内部变量或函数暴露给其他编译单元，就像不希望暴露一个类的私有成员一样；二是,对于大工程来说，不同文件之中的、只在文件内使用的变量名很容易重名，如果将它们都暴露出来，在连接时很容易发生名字冲突。<br>对这问题，曾经的解决办法是，在定义这些变量和函数时使用static关键字。static关键字用来修饰命名空间作用域的变量或函数时， 和extern关键字起相反的作用，它会使得被static修饰的变此和函数无法被其他编译单元引用。</p><p><strong>提示：</strong>目前已经介绍了static 关键字的3种用法，当它用在局部作用域、类作用域和命名空间作用域时，具有不尽相同的作用。一个共同点是，凡是被static修饰的变量，都具有静态生存期(不管未使用static关键字时它们的生存期如何)。</p><p>现在取而代之的方式是使用匿名的命名空间。在匿名命名空间中定义的变量和函数都不会暴露给其他编译单元。</p><p><strong>习惯：</strong>应当将不希望被其他编译单元引用的函数和变量放在匿名的命名空间中。</p><center><span style="color:blue;font-size:15px">2021/1/8</span></center><h4 id="5-6-3-标准C-库"><a href="#5-6-3-标准C-库" class="headerlink" title="5.6.3 标准C++库"></a>5.6.3 标准C++库</h4><p>在C语言中，系统函数、系统的外部变量和一些宏定义都放置在运行库(run-timelibrary)中。C++的库中除继续保留了大部分c语言系统函数外，还加入了预定义的模板和类。标准C++ 类库是一个极为灵活并可扩展的可亚用软件模块的集合。标准C++类与组件在逻辑上分为如下6种类型。<br>。输入输出类;<br>。容器类与ADT(抽象数据类型);<br>。存储管理类;<br>。算法;<br>。错误处理;<br>。运行环境支持。</p><p>使用标准C++库时，还需要加入下面这一条语句来将指定命名空间中的名称引入到当前作用域中:<br>using namespace std;<br>如果不使用上述方法.就需要在使用srd命名空间中的标识符时冠以命名空间名’std::”。</p><p><strong>习惯：</strong>通常情况下，using namespace 语句不宜放在头文件中，因为这会使一个命名空间不被察觉地对一个源文件开放。</p><h4 id="5-6-4-编译预处理"><a href="#5-6-4-编译预处理" class="headerlink" title="5.6.4 编译预处理"></a>5.6.4 编译预处理</h4><p>在编译器对源程序进行编译之前。首先要由预处理器对程序文本进行预处理。所有的预处理指令在程序中都是以“#”来引导，每一条预处理指令单独占用一行，不要用分号结束。预处理指令可以根据需要出现在程序中的任何位置。</p><p><strong>1.#include 指令</strong></p><p><strong>2.#define 和 #undef指令</strong><br>在C++中虽然仍可以用#define定义符号常量，但是更好的方法是在类型说明语句中用const进行修饰。<br>在C语言中，还可以用#define来定义带参数宏，以实现简单的函数计算，但是在C++中这一功能已被内联函数取代。<br>用#define还可以定义空符号，目的是配合条件编译指令一起使用。<br>#undef的作用是删除由#undef定义的宏，使之不再起作用。</p><p><strong>3.条件编译指令</strong><br>使用条件编译指令，可以限定程序中的某些内容要在满足一定条件的情况下才参与编译。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression"><span class="token operator">/</span> #ifndef</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>4.defined操作符</strong><br>defined是一个预处理操作符，而不是指令，因此不要以#开头。<br>#ifndef MYHEAD_H 与 #if!defined(MYHEAD_H) 完全等价</p><p>由于文件包含指令可以嵌套使用，在设计程序时要避免多次重复包含同一个文件，否则会引起变量及类的重复定义。可以在可能被重复包含的头文件中使用条件编译指令。用一个唯一的标识符来标记文件是否已参加过编译。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//head.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HEAD_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">HEAD_H</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><span style="color:blue;font-size:15px">2021/1/9</span></center><h3 id="5-7-综合实例——个人银行账户管理系统"><a href="#5-7-综合实例——个人银行账户管理系统" class="headerlink" title="5.7 综合实例——个人银行账户管理系统"></a>5.7 综合实例——个人银行账户管理系统</h3><p>对第四章的改进：<br>（1）在SavingsAccount类中增加了一个静态数据成员total，用来记录各个账户的总金额，并为其增加相应的静态成员函数getTotal用来对其进行访问。<br>（2）诸如getBalance，accumulate这些不需要改变对象状态的成员函数声明为常成员函数。<br>（3）将SavingAccount类从主函数所在的源文件中分开，建立两个新的文件account.h和account.cpp分别存放SavingAccount类的定义和实现。</p><p><img src="/images/cpp/image-20210119130237279.png" alt="UML图"></p><p>例5-11 个人银行账户管理。<br>整个程序分为3个文件：account.h是类定义头文件，account.cpp是类实现文件，5_11.cpp是主函数文件</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//account.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__ACCOUNT_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__ACCOUNT_H__</span></span><span class="token keyword">class</span> <span class="token class-name">SavingsAccount</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token keyword">double</span> balance<span class="token punctuation">;</span><span class="token keyword">double</span> rate<span class="token punctuation">;</span><span class="token keyword">int</span> lastDate<span class="token punctuation">;</span><span class="token keyword">double</span> accumulation<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">double</span> total<span class="token punctuation">;</span><span class="token comment">//static所有账户的总金额</span><span class="token keyword">void</span> <span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token function">accumulate</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token comment">//const</span><span class="token keyword">return</span> accumulation <span class="token operator">+</span> balance <span class="token operator">*</span> <span class="token punctuation">(</span>date <span class="token operator">-</span> lastDate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> rate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> id<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//const</span><span class="token keyword">double</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> total<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//const</span><span class="token keyword">double</span> <span class="token function">getRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rate<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//const</span><span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> total<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//静态函数</span><span class="token keyword">void</span> <span class="token function">deposit</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">settle</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//const</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">//__ACCOUNT_H__</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//account.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"account.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">double</span> SavingsAccount<span class="token operator">::</span>total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//给total赋初值</span><span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> rate<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">balance</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rate</span><span class="token punctuation">(</span>rate<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lastDate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">accumulation</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> date <span class="token operator">&lt;&lt;</span> <span class="token string">"\t#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"is created"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>accumulation <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>lastDate <span class="token operator">=</span> date<span class="token punctuation">;</span>amount <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>amount <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//保留小数点后两位</span>balance <span class="token operator">+=</span> amount<span class="token punctuation">;</span>total <span class="token operator">+=</span> amount<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> date <span class="token operator">&lt;&lt;</span> <span class="token string">"\t#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> amount <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> balance <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">&gt;</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error:not enough money"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token operator">-</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">double</span> interest <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span> <span class="token operator">*</span> rate <span class="token operator">/</span> <span class="token number">365</span><span class="token punctuation">;</span><span class="token comment">//计算年息</span><span class="token keyword">if</span> <span class="token punctuation">(</span>interest <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> interest<span class="token punctuation">)</span><span class="token punctuation">;</span>accumulation <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"\tBalance:"</span> <span class="token operator">&lt;&lt;</span> balance<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"account.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>SavingsAccount <span class="token function">sa0</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">21325302</span><span class="token punctuation">,</span> <span class="token number">0.015</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SavingsAccount <span class="token function">sa1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">58320212</span><span class="token punctuation">,</span> <span class="token number">0.015</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa0<span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa0<span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">5500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开户后第90天到了银行的计息日，结算所有账户的年息</span>sa0<span class="token punctuation">.</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出各个账户信息</span>sa0<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Total: "</span> <span class="token operator">&lt;&lt;</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-8-深度探索"><a href="#5-8-深度探索" class="headerlink" title="5.8 深度探索"></a>5.8 深度探索</h3><h4 id="5-8-1-常成员函数的声明原则"><a href="#5-8-1-常成员函数的声明原则" class="headerlink" title="5.8.1 常成员函数的声明原则"></a>5.8.1 常成员函数的声明原则</h4><p>“对于那些不会改变<strong>对象状态</strong>的函数，都应定义为常函数”<br>这并不意味着不会改变非静态成员对象的成员函数，都不会改变对象状态。<br>如果有一个函数会改变某个成员的值，但它也未必会改变对象状态。<br>详情见课本p181<br>被mutable修饰的成员对象在任何时候都不会被视为常对象</p><h4 id="5-8-2-代码的编译连接与执行过程"><a href="#5-8-2-代码的编译连接与执行过程" class="headerlink" title="5.8.2 代码的编译连接与执行过程"></a>5.8.2 代码的编译连接与执行过程</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//a.cpp</span><span class="token keyword">extern</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> z<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    y<span class="token operator">=</span><span class="token function">func</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//b.cpp</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> v<span class="token operator">+</span>x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.编译</strong><br>编译是对一个个源文件分别处理的，每个源文件构成了独立的编译单元，编译过程中不同的编译单元互不影响。目标文件主要描述程序在运行过程中需要放在内存中的内容，包括两大类——代码和数据。</p><p>代码段（.text）a.o中应当包含main函数的目标代码；b.o中应当包含func函数的代码；<br>数据段中包含对源文件中定义的各个<strong>静态生存期</strong>对象的描述，数据段又分为初始化的数据段（.data）和未初始化的数据段（.bss）</p><p>几个段的内容，都是该源文件中有定义的内容，那些只声明而未经定义的全局变量或函数并不在这几个段中。例如a.cpp中的y没有出现在a.o的数据段中，而func也没有出现在a.o的代码段中。<br>a.cpp的main函数改写了变量y的值，但y是在b.cpp中定义的，这种联系要通过变量或函数的名字来建立，他们存放在目标代码的符号表中。</p><p><img src="/images/cpp/image-20210109233258524.png" alt=""></p><p><strong>2.连接</strong></p><p>在连接期间，需要将各个编译单元的目标文件和运行库当中被调用的单元加以合并。结果合并后，不同编译单元的代码段和数据段就分别合并到一起了，程序在运行时代码和静态数据需要占据的内存空间就全部已知了，因此所有代码和数据都可以背分配确定的地址了。</p><p><strong>3.执行</strong></p><p>程序的执行，是以进程为单位的。程序只有在执行时才会生成进程，执行结束后进程会消失。<br>程序是存储在磁盘上的，在执行前，操作系统需要首先将它载入到内存中，并为它分配足够大的内存空间来容纳代码段和数据段，然后把文件中存放的代码段和初始化的数据段的内容载入其中。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> C++语言设计指南（第4版） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好2021</title>
      <link href="2021/01/01/hi2021/"/>
      <url>2021/01/01/hi2021/</url>
      
        <content type="html"><![CDATA[<h3 id="triangular-flag-on-post-2021到了，去年留下了诸多遗憾，今年有更多的任务在等待，希望在新的一年可以得到提升，祝所有人新年快乐！！！"><a href="#triangular-flag-on-post-2021到了，去年留下了诸多遗憾，今年有更多的任务在等待，希望在新的一年可以得到提升，祝所有人新年快乐！！！" class="headerlink" title=":triangular_flag_on_post: 2021到了，去年留下了诸多遗憾，今年有更多的任务在等待，希望在新的一年可以得到提升，祝所有人新年快乐！！！"></a><span class="github-emoji"><span>🚩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f6a9.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 2021到了，去年留下了诸多遗憾，今年有更多的任务在等待，希望在新的一年可以得到提升，祝所有人新年快乐！！！</h3>]]></content>
      
      
      <categories>
          
          <category> 随心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora &amp; Mathjax使用文档</title>
      <link href="2020/12/31/typora-mathjax/"/>
      <url>2020/12/31/typora-mathjax/</url>
      
        <content type="html"><![CDATA[<p>Typora里面直接编写html代码，对hexo生效，但是如果直接改动Typora本身的css和html，则对hexo不生效</p><p>Mathjax语法总结 <a href="https://blog.csdn.net/ajacker/article/details/80301378">https://blog.csdn.net/ajacker/article/details/80301378</a></p><h2 id="1-字体编辑"><a href="#1-字体编辑" class="headerlink" title="1. 字体编辑"></a>1. 字体编辑</h2><h3 id="1-1-标题"><a href="#1-1-标题" class="headerlink" title="1.1 标题"></a>1.1 标题</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 一级标题        快捷键Ctrl+1</span><span class="token comment">## 二级标题       快捷键Ctrl+2</span><span class="token comment">### 三级标题      快捷键Ctrl+3</span><span class="token comment">#### 四级标题     快捷键Ctrl+4</span><span class="token comment">##### 五级标题    快捷键Ctrl+5</span><span class="token comment">###### 六级标题   快捷键Ctrl+6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-字体大小"><a href="#1-2-字体大小" class="headerlink" title="1.2 字体大小"></a>1.2 字体大小</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：Ctrl+数字  或 Ctrl+加减号  或  ### （几个#表示几级标题，同上）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-字体加粗"><a href="#1-3-字体加粗" class="headerlink" title="1.3 字体加粗"></a>1.3 字体加粗</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：Ctrl+b示 例：**加粗内容**<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>加粗内容</strong></p><h3 id="1-4-斜体"><a href="#1-4-斜体" class="headerlink" title="1.4 斜体"></a>1.4 斜体</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：ctrl+i示 例：*斜体*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示 例：<em>斜体</em></p><h3 id="1-5-删除线"><a href="#1-5-删除线" class="headerlink" title="1.5 删除线"></a>1.5 删除线</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：alt+shift+5示 例：~~删除的内容~~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示 例：<del>删除的内容</del></p><h3 id="1-6-下划线"><a href="#1-6-下划线" class="headerlink" title="1.6 下划线"></a>1.6 下划线</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：Ctrl+u示 例：&lt;u&gt;下划线内容&lt;/u&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示 例：<u>下划线内容</u></p><h3 id="1-7-文本居中"><a href="#1-7-文本居中" class="headerlink" title="1.7 文本居中"></a>1.7 文本居中</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：&lt;center&gt;居中内容&lt;/center&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>操作：</p><center>居中内容</center><p></p><h3 id="1-8-脚注"><a href="#1-8-脚注" class="headerlink" title="1.8 脚注"></a>1.8 脚注</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：这块有个脚注[^脚注]     [^脚注]:填写脚注的内容示例：有一个github网址[^1]     [^1]:https://github.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例：有一个github网址<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h2><h3 id="2-1-有序列表"><a href="#2-1-有序列表" class="headerlink" title="2.1 有序列表"></a>2.1 有序列表</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：数字+英文小数点(.)+空格示例：1. list1     2. list2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>list1<ol><li>list2</li></ol></li></ol><h3 id="2-2-无序列表"><a href="#2-2-无序列表" class="headerlink" title="2.2 无序列表"></a>2.2 无序列表</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：- +空格 或 * + 空格示例： - list1      - list2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>list1<pre><code>- list2</code></pre></li></ul><h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h2><h3 id="3-1-插入代码块"><a href="#3-1-插入代码块" class="headerlink" title="3.1 插入代码块"></a>3.1 插入代码块</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：shift+~~~（或直接```)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">,</span>num<span class="token punctuation">;</span>  <span class="token keyword">int</span> loopcnts <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"input:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>begin <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loopcnts<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>res <span class="token operator">=</span> <span class="token function">SqrtByBisection</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  end <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"mySqrt_binarysearch(%d) = %f, spent time is %f\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>end<span class="token operator">-</span>begin<span class="token punctuation">)</span><span class="token operator">/</span>CLOCKS_PER_SEC<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-插入数学公式"><a href="#3-2-插入数学公式" class="headerlink" title="3.2 插入数学公式"></a>3.2 插入数学公式</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：$$ + enter示例：$$ + enter后输入11+12，结果如下所示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><script type="math/tex; mode=display">11+12</script><h3 id="3-3-插入引用"><a href="#3-3-插入引用" class="headerlink" title="3.3 插入引用"></a>3.3 插入引用</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：&gt; + 空格示例：&gt; + 空格后，输入 引用的内容，结果如下所示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>引用的内容</p></blockquote><h3 id="3-4-插入链接"><a href="#3-4-插入链接" class="headerlink" title="3.4 插入链接"></a>3.4 插入链接</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操 作:Ctrl+k弹出后，输入 [输入标题名](输入链接地址) 即可示 例1：[百度一下，你就知道](https://www.baidu.com/)示 例2：这是 [百度一下，你就知道](https://www.baidu.com/ "百度") 的链接.  示 例3：这是 [github][1] 的链接.         [1]: https://github.com/ "github"ps：按住ctrl点击链接可直接打开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.zhihu.com/?target=https%3A//www.baidu.com/">百度一下，你就知道</a></p><p>这是 <a href="https://link.zhihu.com/?target=https%3A//www.baidu.com/">百度一下，你就知道</a> 的链接.</p><p>这是 <a href="https://link.zhihu.com/?target=https%3A//github.com/">github</a> 的链接.</p><h3 id="3-5-插入注释"><a href="#3-5-插入注释" class="headerlink" title="3.5 插入注释"></a>3.5 插入注释</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：[^文字]：文字示例：[^1]：文献1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>：文献1</p><h3 id="3-6-插入表格"><a href="#3-6-插入表格" class="headerlink" title="3.6 插入表格"></a>3.6 插入表格</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：ctrl+t示 例：按完快捷键后，弹出下图，选择对应的行和列，点击确定即可。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>2</td><td></td><td></td></tr><tr><td>3</td><td></td><td></td></tr><tr><td>4</td><td></td></tr></tbody></table></div><h3 id="3-7-插入图片"><a href="#3-7-插入图片" class="headerlink" title="3.7 插入图片"></a>3.7 插入图片</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：直接拖动  或 ctrl+shift+i(相对路径地址)示例：![](C:\1.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Typora &amp; Mathjax/v2-96d8a3b13676b08768ef4003478c0ade_720w.jpg" alt="img"></p><h3 id="3-8-插入分隔符"><a href="#3-8-插入分隔符" class="headerlink" title="3.8 插入分隔符"></a>3.8 插入分隔符</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：--- + enter  或者 *** + enter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="3-9-插入表情"><a href="#3-9-插入表情" class="headerlink" title="3.9 插入表情"></a>3.9 插入表情</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作： ：+ 单词 +:示例： :smile:      :cry:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="3-10-插入目录"><a href="#3-10-插入目录" class="headerlink" title="3.10 插入目录"></a>3.10 插入目录</h3><pre class="line-numbers language-none"><code class="language-none">操作：[toc]+enter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>[toc]</p><h3 id="3-11-公式内换行"><a href="#3-11-公式内换行" class="headerlink" title="3.11 公式内换行"></a>3.11 公式内换行</h3><pre class="line-numbers language-none"><code class="language-none">操作：\\<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-12-公式内左对齐"><a href="#3-12-公式内左对齐" class="headerlink" title="3.12 公式内左对齐"></a>3.12 公式内左对齐</h3><pre class="line-numbers language-none"><code class="language-none">操作：在公式最开始加\begin{aligned}，然后每个等号前加&amp;，即&amp;=，每一行用\\换行，然后最后一句输完后\end{aligned}实例：$\begin{aligned}d(x,y)&amp;=\sqrt{(x_1-y_1)^2+(x_2-y_2)^2+\dots+(x_n-y_n)^2}\\&amp;=\sqrt{\sum_{i=1}^{n}{(x_i-y_i)^2}} \end{aligned}$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><script type="math/tex; mode=display">\begin{aligned}d(x,y)&=\sqrt{(x_1-y_1)^2+(x_2-y_2)^2+\dots+(x_n-y_n)^2}\\&=\sqrt{\sum_{i=1}^{n}{(x_i-y_i)^2}} \end{aligned}</script><h3 id="3-13-矩阵表示"><a href="#3-13-矩阵表示" class="headerlink" title="3.13 矩阵表示"></a>3.13 矩阵表示</h3><pre class="line-numbers language-none"><code class="language-none">操作：`\begin{matrix}`和`\end{matrix}`说明在它们之间的是矩阵`1 &amp; 2 &amp; 3\\`表示第一行的元素，其中用`&amp;`来分割每一个元素，用`\\`来换行实例: \left[\begin{matrix} 1 &amp; 2 &amp; 3\\ 4 &amp; 5 &amp; 6 \end{matrix}\right]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>$\left[\begin{matrix} 1 &amp; 2 &amp; 3\\ 4 &amp; 5 &amp; 6 \end{matrix}\right]$</p><h3 id="3-14-希腊字母表示"><a href="#3-14-希腊字母表示" class="headerlink" title="3.14 希腊字母表示"></a>3.14 希腊字母表示</h3><p>$\partial$ \partial</p><p>$\infty$ \infty</p><p>$\forall$ \forall</p><p>$\exists$ \exists</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Typora &amp; Mathjax/v2-68922903c83e504e3e3e4efd5b7327fa_720w.jpg" alt=""></p><h3 id="3-15-箭头表示"><a href="#3-15-箭头表示" class="headerlink" title="3.15 箭头表示"></a>3.15 箭头表示</h3><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Typora &amp; Mathjax/v2-42ff8eb3a827056b16b2133f58009abe_720w.jpg" alt="img"></p><h3 id="3-16-公式大全"><a href="#3-16-公式大全" class="headerlink" title="3.16 公式大全"></a>3.16 公式大全</h3><p><a href="https://blog.csdn.net/fly0202/article/details/82534854">Mathjax 常用语法</a></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Typora &amp; Mathjax/v2-2f57dd9499cba748a39be06d2104fe21_720w.jpg" alt="img"></p><h3 id="3-17-二进制运算-相关符号"><a href="#3-17-二进制运算-相关符号" class="headerlink" title="3.17 二进制运算/相关符号"></a>3.17 二进制运算/相关符号</h3><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Typora &amp; Mathjax/v2-fd7827f7c554e1f2c6d9a356f868a0fe_720w.jpg" alt="img"></p><h3 id="3-18-空格表示"><a href="#3-18-空格表示" class="headerlink" title="3.18 空格表示"></a>3.18 空格表示</h3><p>在公式中如果需要有空格，可以用+空格的方式来实现</p><pre class="line-numbers language-none"><code class="language-none">实例：max \ a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>$max \ a$</p><hr><h2 id="4-杂项"><a href="#4-杂项" class="headerlink" title="4. 杂项"></a>4. 杂项</h2><h3 id="4-1-设置字体颜色大小等"><a href="#4-1-设置字体颜色大小等" class="headerlink" title="4.1 设置字体颜色大小等"></a>4.1 设置字体颜色大小等</h3><pre class="line-numbers language-none"><code class="language-none">由于Typora或者说markdown中没有直接的语法支持文字的颜色，大小，字体等属性的设置，就需要“曲线救国”，因为Typora支持内嵌html的语法，那么只要插入一条html代码即可:&lt;span style='color:文字颜色;background:背景颜色;font-size:文字大小;font-family:字体;'&gt;文字&lt;/span&gt;实例：&lt;span style='color:red;background:blue;font-size:30px;font-family:微软雅黑;'&gt;文字&lt;/span&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span style="color:red;background:blue;font-size:30px;font-family:微软雅黑;">文字</span></p><h3 id="4-2-某些数学图的插入"><a href="#4-2-某些数学图的插入" class="headerlink" title="4.2 某些数学图的插入"></a>4.2 某些数学图的插入</h3><p><a href="https://www.intmath.com/cg3/embed-desmos.php">https://www.intmath.com/cg3/embed-desmos.php</a></p><p>desmos：</p><iframe src="https://www.desmos.com/calculator/yx1lco5nog" width="100%" height="600"></iframe><p>ggb：</p><iframe src="https://ggb123.cn/classic/nfvqbwqt?embed" width="100%" height="600" allowfullscreen="" style="border: 1px solid #e4e4e4;border-radius: 4px;" frameborder="0"></iframe><iframe src="https://ggb123.cn/classic/n4aa6vgh?embed" width="100%" height="600" allowfullscreen="" style="border: 1px solid #e4e4e4;border-radius: 4px;" frameborder="0"></iframe>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathjax </tag>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/12/29/hello-world/"/>
      <url>2020/12/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
