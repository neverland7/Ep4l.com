---
title: 数据结构
date: 2021-04-11 19:01:07
img: images/Data-Structure/Data_Structure.png
mathjax: true
summary: 考研复习，随便补笔记
categories: 学习笔记
tags:
 - c语言
 - 数据结构
 - 考研
typora-root-url: ..
---

使用的教材：

数据结构（C语言版） 严蔚敏

王道数据结构考研复习指导

<center><span style='color:blue;font-size:15px'>2021/4/11</span></center>

## 考研大纲（408）

【408考查目标】

1. 掌握数据结构的基本概念、基本原理和基本方法。
2. 掌握数据的逻辑结构、存储结构及基本操作的实现，能够对算法进行基本的时间复杂度与空间复杂度的分析。
3. 能够运用数据结构基本原理和方法进行问题的分析与求解，具备采用 C 或 C++语言设计与实现算法的能力。

### 线性表

 (一)线性表的基本概念
 (二)线性表的实现（顺序存储、链式存储）
 (三).线性表的应用

### 栈、队列和数组

 (一)栈和队列的基本概念
 (二)栈和队列的顺序存储结构
 (三)栈和队列的链式存储结构
 (四)多维数组的存储
 (五)特殊矩阵的压缩存储
 (六)栈、队列和数组的应用

### 树与二叉树

(一)树的基本概念

(二)二叉树
 1.二叉树的定义及其主要特征
 2.二叉树的顺序存储结构和链式存储结构
 3.二叉树的遍历
 4.线索二叉树的基本概念和构造

(三)树、森林
 1.树的存储结构
 2.森林与二叉树的转换
 3.树和森林的遍历

(四)树与二叉树的应用
 1.二叉搜索树
 2.平衡二叉树
 3.哈夫曼(Huffman)树和哈夫曼编码

### 图

 (一)图的基本概念
 (二)图的存储及基本操作
 1.邻接矩阵法
 2.邻接表法
 3.邻接多重表、十字链表
 (三)图的遍历
 1.深度优先搜索
 2.广度优先搜索
 (四)图的基本应用
 1.最小(代价)生成树
 2.最短路径
 3.拓扑排序
 4.关键路径

### 查找

 (一)查找的基本概念
 (二)顺序查找法
 (三)分块查找法
 (四)折半查找法
 (五)B 树及其基本操作、B+树的基本概念
 (六)散列(Hash)表
 (七)字符串模式匹配
 (八)查找算法的分析及应用

### 排序

 (一)排序的基本概念
 (二)插入排序
 1.直接插入排序
 2.折半插入排序
 (三)起泡排序(bubble sort)
 (四)简单选择排序
 (五)希尔排序(shell sort)
 (六)快速排序
 (七)堆排序
 (八)二路归并排序(mergesort)
 (九)基数排序
 (十)外部排序
 (十一)各种内部排序算法的比较
 (十二)排序算法的应用



## 第1章 绪论

本章的内容是数据结构概述，不在考研大纲中，但是分析算法的时间复杂度和空间复杂度是本章的重点，属于必考内容，一定要熟练掌握。

### 1.1 基本概念和术语

- 数据：信息的载体，是对客观事物的符号表示
- 数据元素：数据的基本单位，一个数据元素可由若干个数据项组成。如：一个学生记录（学号、姓名、...）
- 数据对象：具有相同性质的数据元素的集合，是数据的一个子集。
- 数据结构：是相互存在一种或多种特点关系的数据元素的集合
- 数据类型：原子类型、结构类型
- 抽象数据类型：指一个数学模型以及定义在该模型上的一组操作
  - 通常用（数据对象，数据关系，基本操作集）这样的三元组来表示抽象数据类型。
  - ADT 抽象数据类型名{
    数据对象:<数据对象的定义>
    数据关系:<数据关系的定义>
    基本操作:<基本操作的定义>
    }ADT 抽象数据类型名

### 1.2 算法和算法分析

#### 1.2.1 算法效率的度量

**1.时间复杂度**

一般情况下，算法中基本操作重复执行的次数是问题规模n的**某个函数**f(n)，算法的时间量度记作
$$T(n)=O(f(n))$$

它表示随问题规模n的增大，算法执行时间的**增长率**和f(n)的增长率相同，称作算法的**渐进时间复杂度**，简称时**间复杂度**。

常见的渐进时间复杂度为

O(1)<O($log_2n$)<O(n)<O($nlog_2n$)<O($n^2$)<O($n^3$)<O($2^n$)<O(n!)<O($n^n$)

**2.空间复杂度**

算法的空间复杂度作为算法所需存储空间的量度，记作

$$S(n)=O(f(n))$$

<center><span style='color:blue;font-size:15px'>2021/4/12</span></center>

## 第2章 线性表

线性表是考研的重点，实现起来比较容易而且代码量较少，但却要求具有最优的性能才能获得满分。

### 408大纲

 (一)线性表的基本概念
 (二)线性表的实现（顺序存储、链式存储）
 (三).线性表的应用

### 2.1 线性表的定义和基本操作

#### 2.1.1 线性表的定义

线性表是具有**相同数据类型**的n个数据元素的有限序列，其中n为表长，当n=0时，是一个空表。
若将线性表记为
$$L=(a_1,a_2,...,a_n)$$
除第一个元素外，每一个元素有且仅有一个直接前驱，每个元素有且仅有一个直接后继。

**注意：**线性表是一种逻辑结构，顺序表和链表是指存储结构。

#### 2.1.2 线性表的基本操作

InitList(&L)：初始化表。构造一个空的线性表。
Length(L)：求表长。返回线性表I的长度，即L中数据元素的个数。
LocateElem(L,e)：按值查找操作。在表L中查找具有给定 关键字值的元素。
GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。
ListInsert(&L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e.
ListDelete(&L,i,&e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值
PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。
Empty(L)：判空操作。若L为空表，则返回true,否则返回false.
DestroyList(&L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。

### 2.2 线性表的顺序表示

#### 2.2.1 顺序表的定义

顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。因此，**顺序表的特点是表中元素的逻辑地址与其物理顺序相同。**

![](/images/Data-Structure/image-20210412091209532.png)

**注意：**线性表中元素的位序是从1开始的，而数组中元素的下标是从0开始的。

~~~cpp
#define InitSize 100
typedef struct{
    Elemtype *data;
    int maxSize;
    int length; 						//在进行增删操作后记得更改length
}Sqlist;

Sqlist L;
//动态分配语句
L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);
~~~

顺序表最主要的特点是随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素。
顺序表的存储密度高，每个结点只存储数据元素。
顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。

#### 2.2.2 顺序表上基本操作的实现

略

<center><span style='color:blue;font-size:15px'>2021/4/13</span></center>

### 2.3 线性表的链式表示

链式存储线性表时，不要求逻辑上相邻的两个元素在物理位置上也相邻，因此对线性表的插入、删除不需要移动元素，只需要修改指针。

#### 2.3.1 单链表的定义

线性表的链式存储又称单链表，它是指通过一组任意的存储单 元来存储线性表中的数据元素。对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。

单链表中结点类型的描述如下：

~~~cpp
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode,*LinkList;
~~~

利用单链表可以解决顺序表需要大量连续存储空间的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。单链表是**非随机存取**的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要**从表头开始遍历，依次查找**。通常用**头指针**来标识一个单链表，如单链表L，头指针为NULL时表示一个空表。 此外，为了操作上的方便，在单链表第一个结点之前附加一个结点，称为**头结点**。头结点的数据域可以不设任何信息，也可以记录表长等相关信息。头结点的指针域指向线性表的第一个元素结点。

![](/images/Data-Structure/image-20210413111617026.png)

可入头结点后，可以带来两个优点: 
①在链表的第一个位置上的操作和在表的其他位置上的操作一致， 无须进行特殊处理。
②无论链表是否为空，其头指针都指向头结点的非空指针(空表中头结点的指针域为空，因此空表和非空表的处理也就得到了统一。

#### 2.3.2 单链表上基本操作的实现

只写全一个例子

**1.采用头插法建立单链表**

![](/images/Data-Structure/image-20210413113850093.png)

~~~cpp
LinkList List_HeadInsert(LinkList &L){
	LNode *s,int x;
	L=(LinkList)malloc(sizeof(LNode));	//创建头结点
	L->next=NULL;
	scanf("%d",&x);
	while(x!=9999){
		s=(LinkList)malloc(sizeof(LNode));
		s->data=x;
		s->next=L->next
		L->next=s;
		scanf("%d",&x);
	} 
	return L;
} 
~~~

#### 2.3.3 双链表