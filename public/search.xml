<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一个python游戏迷你引擎(持续更新)</title>
      <link href="2022/03/26/pygame/"/>
      <url>2022/03/26/pygame/</url>
      
        <content type="html"><![CDATA[<p>生命不息，折腾不止v_v    </p><p><code>pip list</code>查看现有插件</p><p><code>pip install pygame</code>安装pygame库（不能连接vpn，否则会报错）</p><p><a href="https://github.com/neverland7/alien_invasion">项目地址</a>    #ps:我的素材图找的还是如此离谱</p><center><span style="color:blue;font-size:15px">2022/3/26</span></center><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/pygame/1.gif" alt="Demo_v0.01"></p><center><span style="color:blue;font-size:15px">2022/4/2</span></center><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/pygame/2.gif" alt="Demo_v0.05"></p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pygame </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="2021/06/22/linear-algebra/"/>
      <url>2021/06/22/linear-algebra/</url>
      
        <content type="html"><![CDATA[<center><span style="color:blue;font-size:15px">2021/6/22</span></center><h2 id="第一章-行列式"><a href="#第一章-行列式" class="headerlink" title="第一章 行列式"></a>第一章 行列式</h2><h3 id="第一节-全排列及其逆序数、对换"><a href="#第一节-全排列及其逆序数、对换" class="headerlink" title="第一节 全排列及其逆序数、对换"></a>第一节 全排列及其逆序数、对换</h3><h4 id="一、全排列的定义"><a href="#一、全排列的定义" class="headerlink" title="一、全排列的定义"></a>一、全排列的定义</h4><p>n个不同的元素排成一列， 叫做这n个元素的<strong>全排列</strong>，简称<strong>排列</strong>。</p><h4 id="二、排列的逆序数"><a href="#二、排列的逆序数" class="headerlink" title="二、排列的逆序数"></a>二、排列的逆序数</h4><p>对于n个不同的元素，规定各元素之间由小到大为<strong>标准次序</strong>。<br><span style="color:red;font-size:20px">定义：</span>当某两个元素的先后次序与标准次序不同时，就说有一个<strong>逆序</strong>，一个排列中所有逆序的总数叫做这个<strong>排列的逆序数</strong>。</p><p><strong>例：</strong>12345为标准次序，t(12345)=0；32145有3个逆序数，t(32145)=3 </p><p>$\displaystyle t\left(n(n-1)(n-2)\cdots21\right)=n-1+n-2+\cdots+2+1=\frac{n(n-1)}{2}$</p><h4 id="三、排列的奇偶性"><a href="#三、排列的奇偶性" class="headerlink" title="三、排列的奇偶性"></a>三、排列的奇偶性</h4><p>逆序数为奇数的排列称为奇排列；逆序数为偶数的排列称为偶排列</p><h4 id="四、对换"><a href="#四、对换" class="headerlink" title="四、对换"></a>四、对换</h4><p><span style="color:blue;font-size:20px">定理：</span>一个排列中任意两个元素对换，排列改变奇偶性</p><p><span style="color:green;font-size:20px">推论：</span>奇排列对换成标准排列的对换次数为奇数，偶排列对换成标准排列的对换次数为偶数</p><h3 id="第二节-行列式的定义"><a href="#第二节-行列式的定义" class="headerlink" title="第二节 行列式的定义"></a>第二节 行列式的定义</h3><h4 id="一、二元线性方程组"><a href="#一、二元线性方程组" class="headerlink" title="一、二元线性方程组"></a>一、二元线性方程组</h4><p><strong>例1：</strong>用消元法解二元线性方程组</p><script type="math/tex; mode=display">\begin{cases}a_{11} x_{1}+a_{12} x_{2}=b_{1}\qquad (1) \\a_{21} x_{1}+a_{22} x_{2}=b_{2}\qquad (2)\end{cases}\\(1) \times a_{22}: a_{11} a_{22} x_{1}+a_{12} a_{22} x_{2}=b_{1} a_{22}\\(2) \times a_{12}: a_{11} a_{21} x_{1}+a_{12} a_{22} x_{2}=b_{2} a_{12}</script><p>两式相减消去$x_2$，得</p><script type="math/tex; mode=display">(a_{11}a_{22}-a_{12}a_{21}x_1)=b_1a_{22}-a_{12}b_2</script><p>类似地，消去$x_1$，得</p><script type="math/tex; mode=display">(a_{11}a_{22}-a_{12}a_{21}x_2)=b_2a_{11}-a_{21}b_1</script><p>当<script type="math/tex">a_{11} a_{22}-a_{12} a_{21} \neq 0</script> 时，方程组的解为</p><script type="math/tex; mode=display">\displaystyle x_{1}=\frac{b_{1} a_{22}-a_{12} b_{2}}{a_{11} a_{22}-a_{12} a_{21}}, \quad x_{2}=\frac{a_{11} b_{2}-b_{1} a_{21}}{a_{11} a_{22}-a_{12} a_{21}}</script><h4 id="二、二阶行列式"><a href="#二、二阶行列式" class="headerlink" title="二、二阶行列式"></a>二、二阶行列式</h4><p><span style="color:red;font-size:20px">定义：</span><script type="math/tex">\begin{vmatrix}a_{11}&a_{12}\\a_{21}&a_{22}\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21}</script>（行列式是一个<strong>数</strong>）</p><p>利用二阶行列式的概念，二元线性方程组的解也可写成二阶行列式，即</p><p>记<script type="math/tex">D=\begin{vmatrix}a_{11}&a_{12}\\a_{21}&a_{22}\end{vmatrix}=a_{11} a_{22}-a_{12} a_{21}\quad \\D_1=\begin{vmatrix}b_{1}&a_{12}\\b_{2}&a_{22}\end{vmatrix}=b_{1} a_{22}-a_{12} b_{2}\\D_2=\begin{vmatrix}a_{11}&b_{1}\\a_{21}&b_{2}\end{vmatrix}=a_{11} b_{2}-b_{1} a_{21}</script></p><p>那么行列式的解可写作<script type="math/tex">\displaystyle x_1=\frac{D_1}{D},x_2=\frac{D_2}{D}</script></p><p><strong>注意：</strong>分子分母都为原方程组的系数构成的行列式</p><h4 id="三、三阶行列式"><a href="#三、三阶行列式" class="headerlink" title="三、三阶行列式"></a>三、三阶行列式</h4><p><span style="color:red;font-size:20px">定义：</span><script type="math/tex">\begin{vmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\end{vmatrix}=a_{11} a_{22} a_{33}+a_{12} a_{23} a_{31}+a_{13} a_{21} a_{32}-a_{11} a_{23} a_{32}-a_{12} a_{21} a_{33}-a_{13} a_{22} a_{31},</script></p><p>三元线性方程组的解问题也同理</p><h3 id="第三节-n阶行列式的定义"><a href="#第三节-n阶行列式的定义" class="headerlink" title="第三节 n阶行列式的定义"></a>第三节 n阶行列式的定义</h3><p>$a_{xy}$的第一个下标称为行标，第二个下标称为列标，在行列式的每一项中，所有元素都处在不同的行，不同的列</p><p><strong>列标</strong>的排列为偶排列时的项为正号，列标的排列为奇排列时的项为负号，因此各项的正负号可以表示为$(-1)^t$</p><p>二阶：<script type="math/tex">\begin{vmatrix}a_{11} & a_{12} \\a_{21} & a_{22}\end{vmatrix}=\sum(-1)^{t\left(p_{1} p_{2}\right)} a_{1 p_{1}} a_{2 p_{2}}</script>，共有两项</p><p>三阶：<script type="math/tex">\begin{vmatrix}a_{11} & a_{12} & a_{13} \\a_{21} & a_{22} & a_{23} \\a_{31} & a_{32} & a_{33}\end{vmatrix}=\sum(-1)^{t\left(p_{1} p_{2} p_{3}\right)} a_{1 p_{1}} a_{2 p_{2}} a_{3 p_{3}}</script>，共有六项</p><p>n阶的行列式有n!项</p><p><strong>例：</strong>已知<script type="math/tex">a_{23}a_{31}a_{42}a_{65}a_{56}a_{14}</script>是六阶行列式中的一项，试确定该项所带符号</p><p>解：<script type="math/tex">a_{23}a_{31}a_{42}a_{65}a_{56}a_{14}=a_{14}a_{23}a_{31}a_{42}a_{56}a_{65}</script></p><p>t(431265)=6，所以该项带正号</p><p><strong>notes:</strong></p><ol><li>行列式结果是一个数</li><li>当n=1时，竖杠不用写，直接写$a_{11}$，与绝对值分开</li><li>二阶、三阶行列式有对角线法则，四阶及四阶以上的行列式没有对角线法则</li></ol><p>主对角线以下（上）的元素都为0的行列式叫做<strong>上（下）三角行列式</strong><br>主对角线以下和以上的元素都为0的行列式叫做<strong>对角行列式</strong><br>三角行列式和对角行列式的值都是主对角线的元素相乘</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>n阶行列式共有n!项，每项都是位于不同行、不同列的n个元素的乘积组成，正负号由下标排列的逆序数决定。</p><h3 id="第四节-行列式的性质"><a href="#第四节-行列式的性质" class="headerlink" title="第四节 行列式的性质"></a>第四节 行列式的性质</h3><p><span style="color:sienna;font-size:20px">性质1：</span>行列式和它的转置行列式相等（行列式对行有的性质对列也有）</p><p><span style="color:sienna;font-size:20px">性质2：</span>对换行列式的两行（列），行列式变号（$r_i\leftrightarrow r_j$)</p><p><span style="color:green;font-size:20px">推论：</span>如果行列式有两行（列）完全相同，则此行列式等于零</p><p><span style="color:sienna;font-size:20px">性质3：</span>行列式的某一行（列）中的所有元素都乘同一数k，等于用数k乘此行列式（$r_i\times k$)</p><p><span style="color:green;font-size:20px">推论：</span>行列式中某一行（列)中的元素的公因子可以提到行列式记号的外面</p><p><span style="color:sienna;font-size:20px">性质4：</span>行列式中如果有两行（列）元素成比例，则此行列式等于零</p><p><span style="color:sienna;font-size:20px">性质5：</span>若行列式中某一行(列)元素均为两数之和，则行列式可按照该行分拆成两个行列式之和，其他各行保持不变(每次只能按照一行或者一列分拆)</p><p><span style="color:sienna;font-size:20px">性质6：</span>把行列式的某一行(列)的各元素乘以同一数然后加到另一行(列)对应的元素上去，行列式值不变（$r_i+kr_j$）</p><p><strong>计算行列式常用的方法一：</strong>任一n阶行列式均可以只经过行(列)变换化为上(下)三角形行列式</p><p>  <strong>note：</strong>若各行元素之和相同，则可将各列加到第一列提取公因子再造零</p><h3 id="第五节-行列式按行（列）展开"><a href="#第五节-行列式按行（列）展开" class="headerlink" title="第五节 行列式按行（列）展开"></a>第五节 行列式按行（列）展开</h3><p>一般来说，低阶行列式的计算比高阶行列式的计算要简便，我们先引进余子式和代数余子式的概念</p><h4 id="一、余子式和代数余子式的定义"><a href="#一、余子式和代数余子式的定义" class="headerlink" title="一、余子式和代数余子式的定义"></a>一、余子式和代数余子式的定义</h4><p><strong>余子式：</strong><script type="math/tex">在n阶行列式中，划去元素a_{ij}所在的第i行和第j列，余下元素保持原来位置组成一个n-1阶行列式，\\称为元素a_{ij}的余子式，记为M_{ij}</script></p><p><strong>代数余子式：</strong><script type="math/tex">A_{ij}=(-1)^{i+j}M_{ij}</script></p><p><strong>note：</strong><script type="math/tex">A_{ij}与a_{ij}的数值无关，与a_{ij}的位置有关</script></p><h4 id="二、有关定理、范德蒙德行列式"><a href="#二、有关定理、范德蒙德行列式" class="headerlink" title="二、有关定理、范德蒙德行列式"></a>二、有关定理、范德蒙德行列式</h4><p><span style="color:blue;font-size:20px">引理：</span><script type="math/tex">一个n阶行列式，如果其中第i行所有元素除a_{ij}外都为零，那么这个行列式等于a_{ij}与它的代数余子式的乘积，\\即D=a_{ij}A_{ij}</script></p><p><span style="color:blue;font-size:20px">定理（拉普拉斯定理）：</span>行列式D等于它任一行(列)的各个元素与其代数余子式的乘积之和（行列式按行（列）展开定理）</p><p><span style="color:green;font-size:20px">推论：</span><script type="math/tex">a_{i1}A_{j1}+a_{i2}A_{j2}+\cdots+a_{in}A_{jn}=\begin{cases}0\qquad(i\neq j)\\D\qquad(i=j)\end{cases}</script></p><p><strong>note：</strong>展开时尽量划边，让余子式易于辨认</p><p><strong>计算行列式常用的方法二：</strong>利用性质将行列式D化为某行(某列)只有一个非零元素，然后按该行(列)将行列式展开</p><p><strong>范德蒙德行列式：</strong><script type="math/tex">\displaystyle\begin{vmatrix}1 & 1 & 1 & \cdots & 1 \\x_{1} & x_{2} & x_{3} & \cdots & x_{n} \\x_{1}^{2} & x_{2}^{2} & x_{3}^{2} & \cdots & x_{n}^{2} \\\cdots & \cdots & \cdots &  & \cdots \\x_{1}^{n-2} & x_{2}^{n-2} & x_{3}^{n-2} & \cdots & x_{n}^{n-2} \\x_{1}^{n-1} & x_{2}^{n-1} & x_{3}^{n-1} & \cdots & x_{n}^{n-1}\end{vmatrix}=\prod_{n \geq i>j \geq 1}(x_{i}-x_{j})</script></p><p>特点：第一行都为1；每列等比；$x_i、x_j$为第二行元素，共有n-1+n-2+···+1=$\displaystyle \frac{n(n-1)}{2}$项</p><p><strong>计算行列式常用的方法三：</strong>递推法（建立<script type="math/tex">D_n与D_{n-1}</script>之间的关系式）</p><p><strong>note：</strong>三对角线形可用递推法</p><center><span style="color:blue;font-size:15px">2021/6/29</span></center><h2 id="第二章-矩阵及其运算"><a href="#第二章-矩阵及其运算" class="headerlink" title="第二章 矩阵及其运算"></a>第二章 矩阵及其运算</h2><h3 id="第一节-线性方程组和矩阵"><a href="#第一节-线性方程组和矩阵" class="headerlink" title="第一节 线性方程组和矩阵"></a>第一节 线性方程组和矩阵</h3><script type="math/tex; mode=display">\begin{cases} 2 x_{1}-x_{2}-x_{3}+x_{4}=2 \\ x_{1}+x_{2}-2 x_{3}+x_{4}=4\\ 4 x_{1}-6 x_{2}+2 x_{3}-2 x_{4}=4 \end{cases} \quad \Leftrightarrow \quad\begin{pmatrix} 2 & -1 & -1 & 1 & |2 \\ 1 & 1 & -2 & 1 & |4 \\ 4 & -6 & 2 & -2 & |4\end{pmatrix}</script><p>线性方程组与矩阵的对应关系：<br>上述的有序数表完全确定了原线性方程组, 对它的研究可以判断方程组的解的情况。</p><h4 id="一、线性方程组"><a href="#一、线性方程组" class="headerlink" title="一、线性方程组"></a>一、线性方程组</h4><p>称<script type="math/tex">\begin{cases} a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1\\ a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2\\ \cdots\qquad\cdots\qquad\cdots\qquad\cdots\\a_{m1}x_1+a_{m2}x_2+\cdots+a_{mn}x_n =b_m\end{cases}</script>为<strong>n元非齐次线性方程组</strong>；当b全为0时，称为<strong>n元齐次线性方程组</strong></p><h4 id="二、矩阵的定义"><a href="#二、矩阵的定义" class="headerlink" title="二、矩阵的定义"></a>二、矩阵的定义</h4><p><span style="color:red;font-size:20px">定义：</span>由$m\times n$个数$a_{ij}$（i=1,2,···,m；j=1,2,···,n）排成的m行n列的<strong>数表</strong>称为m行n列矩阵，</p><p>记作<script type="math/tex">A=\begin{pmatrix}a_{11}&a_{12}&\cdots&a_{1n}\\a_{21}&a_{22}&\cdots&a_{2n}\\\vdots&\vdots&&\vdots\\a_{m1}&a_{m2}&\cdots&a_{mn}\end{pmatrix}</script></p><p>行数和列数都等于n的矩阵称为<strong>n阶矩阵</strong>或<strong>n阶方阵</strong>，记作$A_n$</p><p>只有一行的矩阵称为<strong>行矩阵</strong>或者<strong>行向量</strong>；只有一列的矩阵称为<strong>列矩阵</strong>或者<strong>列向量</strong></p><p>两个行数、列数相等的矩阵称为<strong>同型矩阵</strong>；若同型矩阵的每个对应元素都相等，则称这两个<strong>矩阵相等</strong>，记作A=B</p><p>元素都是零的矩阵称为<strong>零矩阵</strong>，记作O，不同型的零矩阵是不同的</p><p>称<script type="math/tex">\begin{cases} y_1=a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n\\ y_2=a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n\\ \cdots\qquad\cdots\qquad\cdots\qquad\cdots\\y_m=a_{m1}x_1+a_{m2}x_2+\cdots+a_{mn}x_n \end{cases}</script>为由$x_1,x_2,\cdots,x_n$到$y_1,y_2,\cdots,y_n$的<strong>线性变换</strong>，A是线性变换的矩阵</p><h3 id="第二节-矩阵的运算"><a href="#第二节-矩阵的运算" class="headerlink" title="第二节 矩阵的运算"></a>第二节 矩阵的运算</h3><h4 id="一、矩阵的加法"><a href="#一、矩阵的加法" class="headerlink" title="一、矩阵的加法"></a>一、矩阵的加法</h4><p>同型矩阵才能进行加法运算</p><h4 id="二、数与矩阵相乘"><a href="#二、数与矩阵相乘" class="headerlink" title="二、数与矩阵相乘"></a>二、数与矩阵相乘</h4><p>数乘=遍乘</p><h4 id="三、矩阵与矩阵相乘"><a href="#三、矩阵与矩阵相乘" class="headerlink" title="三、矩阵与矩阵相乘"></a>三、矩阵与矩阵相乘</h4><p>有<script type="math/tex">A_{m\times n}B_{n\times s}=C_{ms}</script></p><p>矩阵的乘法不满足交换律，即在一般情况下$AB\neq BA$；</p><p>若$AB=BA$，则称方阵A和B是<strong>可交换的</strong>；（对角矩阵可交换）</p><p>若两个矩阵A、B满足AB=0，不能得出A=0或B=0的结论；若A$\neq $0而A(X-Y)=O，也不能得出X=Y的结论</p><p>EA=AE=A（可见单位矩阵E在矩阵乘法中的作用类似于数1  ）</p><p>引入矩阵乘法的目的是进行线性变换的合成（$y=Ax，x=Bz\Rightarrow y=A(Bz)=(AB)z$）</p><p>矩阵的幂：$A^k$就是k个A连乘，显然只有方阵的幂才有意义</p><p>当$AB\neq BA$时，$(AB)^k\neq A^kB^k、(A+B)^2\neq A^2+2AB+B^2、(A+B)(A-B)\neq A^2-B^2$</p><p><strong>好求方幂的矩阵：</strong>（1）一列乘一行（2）严格上三角矩阵（3）对角阵</p><h4 id="四、矩阵的转置"><a href="#四、矩阵的转置" class="headerlink" title="四、矩阵的转置"></a>四、矩阵的转置</h4><ol><li><p><span style="color:red;font-size:20px">定义：</span>把矩阵A的行换成同序数的列得到的新矩阵，叫作A的转置矩阵，记作$A^T$</p></li><li><p>转置矩阵满足的运算规律：</p><p>(1)$(A^T)^T=A$</p><p>(2)$(A\pm B)^T=A^T\pm B^T$</p><p>(3)$(\lambda A^T)=\lambda A^T$</p><p>(4)$(AB)^T=B^TA^T$</p></li></ol><p><strong>note1：</strong>若$A^T=A$，称A为对称矩阵；若$A^T=-A$，称A为反对称矩阵</p><p>$\displaystyle A=\frac{A+A^T}{2}（对称矩阵）+\frac{A-A^T}{2}（反对称矩阵）$</p><p>所以任意一个方阵一定可以写成一个对称矩阵和一个反对称矩阵之和</p><p><strong>note2：</strong>A为$m\times n$型，则$A^T$为$n\times m$型；$AA^T$，$A^TA$分别为m，n阶方阵且为对称矩阵</p><p><strong>note3：</strong>$\alpha=(a_1,a_2,\cdots,a_n)^T,\alpha^T=(a_1,a_2,\cdots,a_n)$</p><p>$\alpha^T\alpha=a_1^2+a_2^2+\cdots+a_n^2\geq0;\alpha^T\alpha=0\Leftrightarrow \alpha=0$（<strong>一行乘一列为数</strong>）</p><p>$\alpha\alpha^T=\begin{pmatrix}a_1^2&amp;a_1a_2&amp;\cdots&amp;a_1a_n\\a_2a_1&amp;a_2^2&amp;\cdots&amp;a_2a_n\\\cdots&amp;\cdots&amp;&amp;\cdots\\a_na_1&amp;a_na_2&amp;\cdots&amp;a_n^2\end{pmatrix};\alpha\alpha^T=0\Leftrightarrow \alpha=0$（<strong>一列乘一行为矩阵</strong>）</p><h4 id="五、方阵的行列式"><a href="#五、方阵的行列式" class="headerlink" title="五、方阵的行列式"></a>五、方阵的行列式</h4><ol><li><p><span style="color:red;font-size:20px">定义：</span>由n阶<strong>方阵</strong>A的元素所构成的行列式（各元素的位置不变），称为方阵A的行列式，记号|A|或detA</p></li><li><p>性质：设A、B为n阶方阵，则有</p><p>（1）$|A^T|=|A|$（$(A+E)^T=A^T+E\Rightarrow|A+E|=|A^T+E|$）</p><p>（2）$|\lambda A|=\lambda^n|A|$</p><p>（3）$|AB|=|A||B|=|B||A|=|BA|$（$AB\neq BA$）</p><p><strong>note1：</strong>$AB=0\not\Rightarrow A=0或B=0$</p><p>$\qquad AB=0\Rightarrow |A|=0或|B|=0$</p><p><strong>note2：</strong>如果A，B不是方阵，则$|AB|\neq |BA|$</p><p><strong>note3：</strong>$|A+B|\neq|A|+|B|$</p></li></ol><h4 id="六、方阵的伴随矩阵"><a href="#六、方阵的伴随矩阵" class="headerlink" title="六、方阵的伴随矩阵"></a>六、方阵的伴随矩阵</h4><p><span style="color:red;font-size:20px">定义：</span><script type="math/tex">A=(a_{i j})_{n}，A_{i j} 为|A|中 a_{i j}</script>的代数余子式，记 </p><script type="math/tex; mode=display">A^{*}=\begin{pmatrix}A_{11} & A_{21} & \cdots & A_{n 1} \\A_{12} & A_{22} & \cdots & A_{n 2} \\& \cdots & \cdots & \\A_{1 n} & A_{2 n} & \cdots & A_{n n}\end{pmatrix}</script><p>称A*为A的伴随矩阵（注意下标！）</p><p><strong>note：</strong>二阶矩阵求伴随阵口诀：主对调，副变号；二阶矩阵(A*)*=A​</p><p><strong>性质：</strong>$AA^<em>=A^</em>A=|A|E$</p><p>(<script type="math/tex">AA^*=|A|E\Rightarrow|A||A^*|=||A|E|=|A|^n\Rightarrow|A^*|=|A|^{n-1}</script>)</p><center><span style="color:blue;font-size:15px">2021/6/30</span></center><h3 id="第三节-逆矩阵"><a href="#第三节-逆矩阵" class="headerlink" title="第三节 逆矩阵"></a>第三节 逆矩阵</h3><p><span style="color:red;font-size:20px">定义：</span>设A是n阶方阵，如果有一个n阶方阵B，使AB=BA=E，则说A是可逆的，并把B称为A的逆矩阵，简称逆阵。记为$A^{-1}$，读作A逆。</p><p>n阶方阵A可逆的充要条件是$|A|\neq0$，当A可逆时，<script type="math/tex">A^{-1}=\frac{1}{|A|}A^*(|A|=0\Leftrightarrow |A^*|=0)</script> </p><p><strong>note：</strong>伴随求逆，二阶最方便，三阶还可以，四阶五阶太麻烦，不可取</p><p><strong>推论</strong>：若AB=E（或BA=E），则$B=A^{-1}$</p><p>若$|A|=0$，则称A为<strong>奇异矩阵</strong>（退化矩阵）(不可逆)；若$|A|\neq 0$，则称A为<strong>非奇异矩阵</strong>（非退化矩阵）(可逆)</p><p><strong>方阵A的逆矩阵的求法：</strong></p><p>（1）利用公式<script type="math/tex">A^{-1}=\frac{1}{|A|}A^*</script>（适用于二阶、三阶矩阵求逆）（$A^*=|A|A^{-1}$）</p><p>（2）寻找方阵B，使得AB=E（适用于抽象矩阵求逆）</p><p>（3）利用矩阵的初等变换求逆矩阵（后面讲）</p><p><strong>例：</strong>设方阵A满足方程$A^2-A-2E=0$，证明A，A+2E都可逆，并求它们的逆矩阵</p><p>证：<script type="math/tex">(1)由A^2-A-2E=0\\得A(A-E)=2E\Rightarrow A\frac{A-E}{2}=E\\所以A可逆，且A^{-1}=\frac 1 2(A-E)\\(2)由A^2-A-2E=0\\得(A+2E)(A-3E)+4E=0\\(A+2E[-\frac 1 4(A-3E)])=E\\所以A+2E可逆，且(A+2E)^{-1}=-\frac 1 4(A-3E)</script></p><p><strong>逆矩阵满足以下运算规律：</strong></p><p>（1）$若A可逆，则A^{-1}也可逆，且(A^{-1})^{-1}=A$</p><p>（2）$若A可逆，数\lambda\neq0，则\lambda A也可逆，且(\lambda A)^{-1}=\frac 1\lambda A^{-1}$</p><p>（3）$若A，B为同阶方阵且均可逆，则AB亦可逆，且（AB)^{-1}=B^{-1}A^{-1}$</p><p>（4）$若A可逆，则A^T也可逆，且(A^T)^{-1}=(A^{-1})^T$</p><p>（5）$若A可逆，则|A^{-1}|=|A|^{-1}$</p><p><strong>note：</strong>$(A+B)^{-1}\neq A^{-1}+B^{-1}$</p><p><strong>伴随矩阵的性质：</strong></p><p>（1）$|A^*|=|A|^{n-1}$</p><p>（2）<script type="math/tex">(kA)^*=K^{n-1}A^*</script></p><p>（3）<script type="math/tex">(A^*)^T=(A^T)^*</script></p><p>（4）<script type="math/tex">(A^*)^{-1}=(A^{-1})^*=\frac A {|A|}</script>（假设A可逆）</p><p>（5）设A为n阶可逆阵，则<script type="math/tex">(A^*)^*=|A|^{n-2}A，当n=2时，(A^*)^*=A</script></p><p>（6）设A，B均为可逆矩阵，则<script type="math/tex">(AB)^*=B^*A^*</script></p><div class="table-container"><table><thead><tr><th>转置</th><th>逆$（AA^{-1}=E)$</th><th>伴随$(A^{-1}=\frac{1}{\vert A\vert }A^*)$</th></tr></thead><tbody><tr><td>$(A^T)^T$=A</td><td>$(A^{-1})^{-1}=A$</td><td><script type="math/tex">(A^*)^*=\vert A\vert ^{n-2}A</script></td></tr><tr><td>$(kA)^T=kA^T$</td><td>$(kA)^{-1}=\frac 1 k A^{-1}$</td><td><script type="math/tex">(kA)^*=k^{n-1}A^*</script></td></tr><tr><td>$(AB)^T=B^TA^T$</td><td>$(AB)^{-1}=B^{-1}A^{-1}$</td><td><script type="math/tex">(AB)^*=B^*A^*</script></td></tr><tr><td>$(A+B)^T=A^T+B^T$</td><td>无</td><td>无</td></tr><tr><td>$(A^T)^{-1}=(A^{-1})^T$</td><td><script type="math/tex">(A^{-1})^*=(A^*)^{-1}=\frac{A}{\vert A\vert }</script></td><td><script type="math/tex">(A^*)^T=(A^T)^*</script></td></tr></tbody></table></div><h3 id="第四节-克拉默法则"><a href="#第四节-克拉默法则" class="headerlink" title="第四节 克拉默法则"></a>第四节 克拉默法则</h3><p><strong>克拉默法则：</strong>如果一个（方程个数和未知数个数相同的）非齐次线性方程组的系数矩阵A的行列式不等于零，那么，方程组有唯一解$x_n=\frac{|A_n|}{A}$</p><p><strong>notes：</strong></p><p>（1）如果线性方程组系数行列式D≠0，则有解，且解唯一；若系数行列式为零，则解不唯一或无解 。</p><p>（2）Cramer法则仅用于未知数个数与方程个数相同的情况。</p><p><strong>推论：</strong>若<strong>齐次</strong>线性方程组的系数行列式D≠0，则方程组只有零解</p><p><strong>notes：</strong></p><p>（1）齐次方程组一定有解</p><p>（2）若齐次线性方程组有非零解，则D=0</p><h3 id="第五节-矩阵分块法"><a href="#第五节-矩阵分块法" class="headerlink" title="第五节 矩阵分块法"></a>第五节 矩阵分块法</h3><p><span style="color:red;font-size:20px">定义：</span>将矩阵A用若干条纵线和若干条横线分成许多个小矩阵，每一个小矩阵称为A的子块，以子块为元素的形式上的矩阵称为分块矩阵</p><p><strong>分块矩阵的运算：</strong></p><p>（1）设矩阵A与B的行数相同，列数相同，采用同样的分块法，那么<strong>加减法</strong>与矩阵加减法类似</p><p>（2）数乘=遍乘</p><p>（3）<script type="math/tex">A=\left(\begin{array}{ccc}A_{11} & \cdots & A_{1 t} \\\vdots & & \vdots \\A_{s 1} & \cdots & A_{s t}\end{array}\right), \quad B=\left(\begin{array}{ccc}B_{11} & \cdots & B_{1 r} \\\vdots & & \vdots \\B_{t 1} & \cdots & B_{t r}\end{array}\right)\\其中 A_{i 1}, A_{i 2}, \cdots A_{i t} 的列数分别等于 B_{1 j}, B_{2 j}, \cdots B_{t j} 的行数。\\A B=\left(\begin{array}{ccc}C_{11} & \cdots & C_{1 r} \\\vdots & & \vdots \\C_{s 1} & \cdots & C_{s r}\end{array}\right)\\其中 \displaystyle C_{i j}=\sum_{k=1}^{t} A_{i k} B_{k j} \quad(i=1, \cdots s ; j=1, \cdots, r)</script></p><p>（4）转置：行列交换，同时每个小子块发生转置（公转且自转）</p><p><strong>notes：</strong></p><p>1.乘法要保证有意义</p><p>2.按普通矩阵一样乘</p><p><strong>分块对角矩阵：</strong>设<script type="math/tex">A=\begin{pmatrix}B&0\\0&C\end{pmatrix}</script>，其中B，C均为方阵，则</p><p>（1）<script type="math/tex">|A|=|B||C|</script></p><p>（2）<script type="math/tex">A^n=\begin{pmatrix}B^n&0\\0&C^n\end{pmatrix}</script></p><p>（3）A可逆的充分必要条件为B，C均可逆，且<script type="math/tex">A^{-1}=\begin{pmatrix}B^{-1}&0\\0&C^{-1}\end{pmatrix}(注意:\begin{pmatrix}0&B\\C&0\end{pmatrix}^{-1}=\begin{pmatrix}0&C^{-1}\\B^{-1}&0\end{pmatrix})</script></p><p>（4）<script type="math/tex">A^*=|A|A^{-1}=|B||C|\begin{pmatrix}B^{-1}&0\\0&C^{-1}\end{pmatrix}=\begin{pmatrix}|C|B^*&0\\0&|B|C^*\end{pmatrix}</script></p><center><span style="color:blue;font-size:15px">2021/7/2</span></center><h2 id="第三章-矩阵的初等变换和线性方程组"><a href="#第三章-矩阵的初等变换和线性方程组" class="headerlink" title="第三章 矩阵的初等变换和线性方程组"></a>第三章 矩阵的初等变换和线性方程组</h2><h3 id="第一节-矩阵的初等变换"><a href="#第一节-矩阵的初等变换" class="headerlink" title="第一节 矩阵的初等变换"></a>第一节 矩阵的初等变换</h3><p>消元法解线性方程组的三种同解变换：</p><p>（1）一个方程加到另一个方程</p><p>（2）非零数乘某个方程</p><p>（3）互换两个方程的位置</p><p>在上述变换过程中，实际上只对方程组的系数和常数进行运算，未知数并未参与运算，因此，对方程组的变换可以完全转换为对它的<strong>增广矩阵</strong>的变换</p><p><span style="color:red;font-size:20px">定义：（初等行变换）</span></p><p>（1）对调两行（$r_i\leftrightarrow r_j$）</p><p>（2）以数k≠0乘某一行中所有元素（$r_i\times k$）</p><p>（3）某行所有元素k倍加到另一行对应元素上去（$r_i+kr_j$）</p><p>把行换成列，即得到矩阵的<strong>初等列变换</strong>的定义；矩阵的初等行变换和初等列变换，统称为<strong>初等变换</strong></p><p><strong>note：</strong>解方程组不可以用列变换</p><p><strong>矩阵的等价关系：</strong>如果矩阵A结果有限次（初等行变换\初等列变换\初等变换）变成矩阵B，就称矩阵A与B（行等价\列等价\等价），记作（$ A\overset{r}\sim B\setminus A\overset{c}\sim B\setminus A\sim B$）</p><p><strong>行阶梯形矩阵：</strong>(经过<strong>初等行变换</strong>)<br>（1）可以画一条阶梯线，线的下方全为零;<br>（2）每个台阶只占一行，阶梯竖线右边第一个元素非零。<br><strong>行最简形矩阵：</strong>在行阶梯形中，经过<strong>初等行变换</strong>化为<br>（3） 每个非零行的首非零元素全为1,<br>（4）每个非零行的首非零元素所在列的其他元素为0。<br><strong>标准形：</strong><br>在行最简形矩阵中，再经过有限次<strong>初等列变换</strong>可变成<script type="math/tex">F=\begin{pmatrix}E_r&O\\O&O\end{pmatrix}</script></p><p><span style="color:red;font-size:20px">定义：（初等矩阵）</span>由单位矩阵E经过一次初等变换得到的矩阵称为<strong>初等矩阵</strong>。</p><p>三种初等变换对应有三种初等矩阵</p><p>（1）对换阵（$E\overset{r_i\leftrightarrow r_j}\longrightarrow E(i,j)$）</p><p>（2）数乘阵（$E\overset{r_i\times k}\longrightarrow E(i(k))$）</p><p>（3）倍加阵（$E\overset{r_i+k r_j}\longrightarrow E(ij(k))$）</p><p><strong>性质（行左列右）：</strong>对$A_{m\times n}$施行一次初等行(列)变换就相当于在 A的左(右)乘以一个相应的m(n)阶初等矩阵。</p><p><strong>定理：</strong>初等矩阵均可逆，且其逆仍然是同类型的初等矩阵，</p><p>且<script type="math/tex">(E(ij))^{-1}=E(ij)\quad[E(ij)E(ij)=E]\\(E(i(k)))^{-1}=E(i(\frac 1 k))\quad[E(i(\frac 1 k))E(i(k))=E]\\(E(ij(k)))^{-1=}E(ij(-k))\quad [E(ij(-k))E(ij(k))=E]</script></p><p><strong>推论1：</strong>方阵A可逆的充分必要条件是A通过初等行变换得到E</p><p><strong>推论2：</strong>A可逆的充分必要条件是存在有限个初等矩阵$P_1,P_2,\cdots,P_l$使得$A= P_1P_2\cdots P_l$</p><p><strong>推论3：</strong> <script type="math/tex">A_{m\times n}通过有限次初等变换得到B_{m\times n}的充分必要条件是存在可逆阵P_{m\times n},Q_{m\times n,}使得PAQ=B</script></p><p><strong>利用初等行变换求逆矩阵的方法：</strong>$(A|E)\overset{初等行变换}\longrightarrow (E|A^{-1})$(从上往下化成上三角，再重下往上化成对角，再每一行乘上倒数)</p><p><strong>利用初等行变换解矩阵方程AX=B的步骤：</strong>$(A|B)\overset{初等行变换}\longrightarrow (E|A^{-1}B)=(E|X)$</p><h3 id="第二节-矩阵的秩"><a href="#第二节-矩阵的秩" class="headerlink" title="第二节 矩阵的秩"></a>第二节 矩阵的秩</h3><p><span style="color:red;font-size:20px">定义：（子式）</span><script type="math/tex">在A_{m\times n}中，任取k行与k列(k≤m,k≤n),位于这些行列交叉处的k^2个元素，\\不改变它们在A中所处的位置次序而得的k阶行列式称为矩阵A的一个k阶子式。(k阶子式共有C^k_m\times C^k_n个)</script></p><p><strong>notes：</strong></p><p>（1）$A_{m\times n}$的每一个元素都是其的一阶子式，共m×n个</p><p>（2）若A为n阶方阵，|A|为A的唯一的n阶子式， |A|中每个元素的余子式为A的n-1阶子式， 共$n^2$个。</p><p>（3）若矩阵A中所有k阶子式都为零，则高于k阶的子式（若有）都为零。</p><p><span style="color:red;font-size:20px">定义：（矩阵的秩）</span>若矩阵A中有一个不等于0的r阶子式D，且所有r+1阶子式全等于0，则称D为A的最高阶非零子式，r称为A的秩，记作R(A)或者r(A)。规定零矩阵的秩为零。<strong>R(A)即为A的最高阶非零子式的阶数</strong>。（rank)</p><p><strong>notes：</strong></p><p>（1）R(A)≥r⇔A中至少有一个r阶子式不为零；R(A)&lt;r+1⇔A中所有r+1阶子式等于零</p><p>（2）对于n阶方阵A，|A|≠0⇔R(A)=n,称A是满秩的；|A|=0⇔R(A)&lt;n,称A是降秩的。</p><p>（3）行阶梯型矩阵的秩等于非零行的行数</p><p><strong>定理1：</strong>若A~B，则R(A)= R(B)</p><p><strong>求矩阵秩R(A)的方法：</strong>利用初等(行)变换将矩阵A化为阶梯形；此阶梯形矩阵中非零行的行数即为矩阵的秩R(A)</p><p><strong>秩的性质与结论（部分）：</strong></p><p><strong>（1）</strong>$0≤R(A_{m\times n})≤\min\{m,n\}$</p><p>（2）$R(A^T)=R(A)=R(AA^T)=R(A^TA))$</p><p>（3）若A~B，则R(A)=R(B)；反之，若A，B同型，且R(A)=R(B)，则A，B等价</p><p>（4）若P，Q可逆，则R(PAQ)=R(A)</p><p><strong>（5）</strong>R(A|B)≥R(A)；R(A|B)≥R(B)</p><p><strong>（6）R(A+B)≤</strong>R(A+B|B)= R(A|B)≤<strong>R(A)+R(B)</strong></p><p><strong>（7）</strong>R(AB)≤R(A)；R(AB)≤R(B)；若B可逆，则R(AB)=R(A)</p><p><strong>（8）</strong><script type="math/tex">若A_{m\times n}B_{n\times s}=0,则R(A)+R(B)≤n</script></p><p><strong>例：</strong>设A为n阶方阵，证明：<script type="math/tex">R(A^*)=\begin{cases}n,若R(A)=n\\1,若R(A)=n-1\\0,若R(A)<n-1\end{cases}</script></p><p>证：<script type="math/tex">AA^*=A^*A=|A|E,|A^*|=|A|^{n-1},A^*中的元素是A的代数余子式(n-1阶子式)\\当R(A)=n时,|A|\neq 0,|A^*|\neq 0,R(A^*)=n\\当R(A)<n-1时,A的余子式均为0,A^*为零矩阵\\当R(A)=n-1时,AA^*=|A|E=0\Rightarrow R(A)+R(A^*)\leq n \Rightarrow R(A^*)\leq 1\\又因为A至少有一个n-1阶子式不为0,所以A^*不是零矩阵,所以R(A^*)\geq 1</script></p><p>一个n阶矩阵的秩可能是0到n，不过一个n阶矩阵的伴随的秩只可能是n，1，0</p><center><span style="color:blue;font-size:15px">2021/7/3</span></center><h3 id="第三节-线性方程组的解"><a href="#第三节-线性方程组的解" class="headerlink" title="第三节 线性方程组的解"></a>第三节 线性方程组的解</h3><h4 id="一、非齐次线性方程组"><a href="#一、非齐次线性方程组" class="headerlink" title="一、非齐次线性方程组"></a>一、非齐次线性方程组</h4><p><strong>定理：</strong>对于线性方程组$A_{m\times n}x=b$</p><p>（1）无解⇔R(A)&lt;R(A,b)；（R(A,b)=R(A)+1）</p><p>（2）有唯一解⇔R(A)=(A,b)=n；</p><p>（3）有无穷多解⇔R(A)=R(A,b)&lt;n；</p><p><strong>推论：</strong>线性方程组$A_{m\times n}x=b$有解⇔R(A)=R(A,b)</p><p>当线性方程组<script type="math/tex">A_{m\times n}x=b</script>有<strong>无穷多解</strong>时，其所有解的共同表达式称为线性方程组$A_{m\times n}x=b$的<strong>通解</strong>或<strong>一般解</strong></p><p>特别的，对于方阵$A_n,A_nx=b$有唯一解⇔$|A_n|≠0$（参见克拉默法则）；若|A|=0，可能无解或无穷多解</p><p><strong>求解Ax=b的方法：</strong></p><p>（1）写出增广矩阵(A,b)<br>（2）利用<strong>初等行变换</strong>将其化为<strong>行阶梯形</strong>，判断R(A)=R(A,b)，从而确定线性方程组是否有解<br>（3）如果线性方程组有解，就继续将(A,b)化为<strong>行最简形</strong><br>（4）从行最简形写回线性方程组，并将每个首非零元素对应的变量放在等号的左边，其余变量（称为<strong>自由末知量</strong>）移到等号的右边<br>（5）添加方程$x_i= x_i$，其中xi为每个自由未知量<br>（6）将自由未知量xi换成c1，c2等，写出线性方程组的解或通解</p><h4 id="二、齐次线性方程组"><a href="#二、齐次线性方程组" class="headerlink" title="二、齐次线性方程组"></a>二、齐次线性方程组</h4><p>（1）只有零解（有唯一解）⇔R(A)=n；</p><p>（2）有非零解（有无穷多解）⇔R(A)&lt;n；</p><p><strong>推论1：（方阵情况）</strong>（只有方阵才能谈行列式）</p><p>（1）$A_nx=0$只有零解⇔|A|≠0</p><p>（2）$A_nx=0$有非零解⇔|A|=0</p><p><strong>推论2：</strong>方程的个数小于未知数个数，则一定有非零解。</p><center><span style="color:blue;font-size:15px">2021/7/4</span></center><h2 id="第四章-向量组的线性相关性"><a href="#第四章-向量组的线性相关性" class="headerlink" title="第四章 向量组的线性相关性"></a>第四章 向量组的线性相关性</h2><h3 id="第一节-向量组及其线性组合"><a href="#第一节-向量组及其线性组合" class="headerlink" title="第一节 向量组及其线性组合"></a>第一节 向量组及其线性组合</h3><h4 id="一、向量"><a href="#一、向量" class="headerlink" title="一、向量"></a>一、向量</h4><ol><li><p><span style="color:red;font-size:20px">定义1</span>称$\begin{pmatrix}a_1\\a_2\\\vdots\\a_n\end{pmatrix}$为n维列向量，其中ai称为第i个分量。$(b_1,b_2,\cdots,b_n)$为n维行向量</p><p><strong>note：</strong>列向量用$\alpha,\beta,\gamma,\cdots$表示，行向量用$\alpha^T,\beta^T,\gamma^T,\cdots$表示；</p></li><li><p>向量的线性运算（加减法、数乘）</p></li><li><p><strong>向量组：</strong>若干个<strong>同维数</strong>的行（列）向量所组成的集合；</p></li><li><p>向量组和矩阵的关系（含有有限个向量的有序向量组可以与矩阵一一对应）（第二章已经介绍）</p></li><li><p>方程组的向量表示（第二章已经介绍）</p><script type="math/tex; mode=display">\begin{pmatrix}a_{11}&a_{12}&\cdots&a_{1n}\\a_{21}&a_{22}&\cdots&a_{2n}\\\vdots&\vdots&\ddots&\vdots\\a_{m1}&a_{m2}&\cdots&a_{mn}\end{pmatrix}\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix}=\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\end{pmatrix}\Leftrightarrow(\alpha_1,\alpha_1,\cdots,\alpha_n)\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix}=\beta\Leftrightarrow x_1\alpha_1+x_2\alpha_2+\cdots+x_n\alpha_n=\beta</script></li></ol><h4 id="二、向量组的线性表示（以列向量为对象）（与非齐有关-Ax-B"><a href="#二、向量组的线性表示（以列向量为对象）（与非齐有关-Ax-B" class="headerlink" title="二、向量组的线性表示（以列向量为对象）（与非齐有关 Ax=B)"></a>二、向量组的线性表示（以列向量为对象）（与非齐有关 Ax=B)</h4><ol><li><p><span style="color:red;font-size:20px">定义2：</span>设向量组A：$α_1,α_2,\cdots,α_m$以及任意一组实数$k_1,k_2,\cdots,k_m$，称$k_1α_1+k_2α_1+\cdots+k_mα_m$为向量组A的一个线性组合</p><p><strong>note：</strong>零向量可写成任意同维数向量的线性组合</p></li><li><p><span style="color:red;font-size:20px">定义3：</span>给定向量组A，如果存在一组数k使得$\beta=k_1α_1+k_2α_1+\cdots+k_mα_m$，则称向量b能由向量组A线性表示</p><p><strong>定理1：</strong><script type="math/tex">向量β能由向量组A线性表示\\⇔线性方程组x_1α_1+x_2α_1+\cdots+x_mα_m=\beta，即Ax=\beta有解\\⇔R(α_1,α_2,\cdots,α_m)=R(α_1,α_2,\cdots,α_m,\beta)，即R(A)=R(A,B)</script></p></li></ol><h4 id="三、向量组的等价"><a href="#三、向量组的等价" class="headerlink" title="三、向量组的等价"></a>三、向量组的等价</h4><p><span style="color:red;font-size:20px">定义4：</span>若向量组B中的每个向量都能由A中的向量线性表示，则称<strong>向量组B能由向量组A线性表示</strong>；若向量组A和向量组B能相互线性表示，则称这两个向量组<strong>等价</strong></p><p><strong>note：</strong>矩阵等价与向量组等价有区别：向量组等价不能确定向量组构成的矩阵等价；矩阵等价不能确定其行(列)向量组等价</p><p><img src="/images/linear-algebra/image-20210704205828955.png" alt=""></p><p><img src="/images/linear-algebra/image-20210704210041624.png" alt=""></p><p><strong>note2：</strong>由上可知若AB=C，则</p><p>（1）C的列向量可由A的列向量线性表示（A<span style="color:blue">B</span>=C)（表示的系数为B的列元素）</p><p>（1）C的行向量可由B的行向量线性表示（<span style="color:blue">A</span>B=C)（表示的系数为A的行元素）</p><p><strong>note3：</strong>矩阵A经初等行变换变成矩阵B，则A的行向量组与B的行向量组等价。但是列向量组未必等价。同理，矩阵A经初等列变换变成矩阵B，则A的列向量组与B的列向量组等价。但是行向量组未必等价。</p><p><strong>推论：</strong>列向量组A与列向量组B等价$\Leftrightarrow R(A)=R(B)=R(A,B)$（三秩相等即等价）</p><p><strong>定理1：</strong>向量组B能由向量组A线性表示，则R(B)=R(AK)≤R(A)</p><center><span style="color:blue;font-size:15px">2021/7/5</span></center><h3 id="第二节-向量组的线性相关性（与齐次有关-Ax-0）"><a href="#第二节-向量组的线性相关性（与齐次有关-Ax-0）" class="headerlink" title="第二节 向量组的线性相关性（与齐次有关 Ax=0）"></a>第二节 向量组的线性相关性（与齐次有关 Ax=0）</h3><h4 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h4><p><span style="color:red;font-size:20px">定义：</span>给定向量组A:$a_1,a_2,\cdots,a_m$，如果存在<strong>不全为零</strong>的数$k_1,k_2,\cdots,k_m$，使得$k_1α_1+k_2α_1+\cdots+k_mα_m=0$，则称向量组A<strong>线性相关</strong>，否则称它<strong>线性无关</strong>（齐次线性方程组只有零解）。</p><p><strong>note：</strong>线性相关的充分条件（1）有零向量（2）有两个向量成比例（3）有一个可以由其余向量表示（充要）</p><p><strong>note1：</strong>线性相关无关的<strong>直观意义</strong></p><p>（1）α线性相关⇔α=0；α线性无关⇔α≠0；</p><p>（2）$α_1,a_2$线性相关⇔$α_1,a_2$成比例（或平行）；$α_1,a_2$线性无关⇔$α_1,a_2$不成比例（或不平行）</p><p>（3）$α_1,a_2,a_3$线性相关⇔$α_1,a_2,a_3$共面；$α_1,a_2,a_3$线性无关⇔$α_1,a_2,a_3$不共面；</p><h4 id="二、相关定理（相关结论）"><a href="#二、相关定理（相关结论）" class="headerlink" title="二、相关定理（相关结论）"></a>二、相关定理（相关结论）</h4><p>（1）向量组A线性相关⇔A中至少有一个向量可由其余向量线性表示</p><p>（2）向量组中含有零向量，则该向量组线性相关</p><p><strong>定理1：</strong></p><p>（1）向量组A线性相关⇔线性方程组Ax=0有非零解⇔A的秩小于m（向量的个数）</p><p>（2）向量组A线性无关⇔线性方程组Ax=0只有零解⇔A的秩等于m</p><p><strong>note：</strong>判断相关无关，只要将向量组构成矩阵A，比较R(A)与向量个数之间的关系</p><p><strong>note1：</strong><script type="math/tex">设n维向量组α_1,a_2,\cdots,α_s线性无关，且(β_1,β_2,\cdots,β_s)=(α_1,a_2,\cdots,α_s)k_{s\times s},\\则(β_1,β_2,\cdots,β_s)线性无关⇔k_{s\times s}≠0(可逆\Rightarrow A与B的秩相等)</script></p><p><strong>定理2：</strong></p><p>（1）<script type="math/tex">若α_1,a_2,\cdots,α_m线性相关，则α_1,a_2,\cdots,α_m,α_{m+1}必线性相关;\\反之，若α_1,α_2,α_m,α_{m+1}线性无关，则α_1,a_2,\cdots,α_m线性无关;</script></p><p>（2）<script type="math/tex">若α_1,a_2,\cdots,α_m线性无关，而α_1,a_2,\cdots,α_m,β线性相关，\\则β能由α_1,a_2,\cdots,α_m线性表示，且表达式唯一</script></p><p>（3）m个n维向量组成的向量组，当向量个数m大于维数n时，该向量组一定线性相关。<br>特别地，n+1个n维向量一定线性相关。</p><p><strong>定理3：</strong>线性无关的向量组中每个向量分别添加分量后的新向量组一定线性无关。</p><p><strong>定理4：</strong>对矩阵进行初等<strong>行</strong>变换不改变其<strong>列向量组</strong>的线性相关性；<br>对矩阵进行初等<strong>列</strong>变换不改变其<strong>行向量组</strong>的线性相关性。</p><center><span style="color:blue;font-size:15px">2021/7/7</span></center><h3 id="第三节-向量组的秩"><a href="#第三节-向量组的秩" class="headerlink" title="第三节 向量组的秩"></a>第三节 向量组的秩</h3><h4 id="一、定义和性质"><a href="#一、定义和性质" class="headerlink" title="一、定义和性质"></a>一、定义和性质</h4><p><span style="color:red;font-size:20px">定义：</span>设有向量组A，若在A中能选出r个向量满足</p><p>（1）这r个向量组成的向量组线性无关</p><p>（2）向量组A中任意r+1个向量（如果有的话）都线性相关。</p><p>或（2’）A中任意一个向量都可以由这r个向量线性表示</p><p>满足(1)(2)的r个向量是向量组A的一个最大(线性)无关组，数r称为<strong>向量组A的秩</strong>，记为$r=R_A$</p><p><strong>note1：</strong>向量组A的最大无关组可能不唯一；如果$R_A=r$，则向量组A中的任意r个线性无关的向量所组成的向量组都是A的最大无关组。</p><p><strong>note2：</strong>如果向量组A线性无关，则A的唯一最大无关组就是它本身。</p><p><strong>性质：</strong></p><p>（1）向量组与最大无关组等价</p><p>（2）同一向量组的任意两个最大无关组等价</p><p>（3）两个等价向量组的最大无关组等价</p><h4 id="二、相关定理"><a href="#二、相关定理" class="headerlink" title="二、相关定理"></a>二、相关定理</h4><p><strong>定理：</strong>矩阵的秩等于矩阵的列向量组的秩，也等于矩阵行向量组的秩</p><p><strong>求列向量组A的最大无关组和秩r的方法：</strong></p><p>（1）先将列向量组A构成矩阵</p><p>（2）对矩阵作初等行变换化为行阶梯型，则在行阶梯型中：非零行的行数即为向量组A的秩；每个非零行的首非零元素所在的列向量的全体即为列向量组的一个最大无关组。</p><p>（3）继续将矩阵A作初等行变换化成行最简形，则利用行最简形，可将其余向量由最大无关组线性表示。</p><p>原理：对矩阵就行初等行变换不改变其列向量组的线性无关性</p><center><span style="color:blue;font-size:15px">2021/7/8</span></center><h3 id="第四节-线性方程组的的解的结构"><a href="#第四节-线性方程组的的解的结构" class="headerlink" title="第四节 线性方程组的的解的结构"></a>第四节 线性方程组的的解的结构</h3><h4 id="一、齐次线性方程组的解的结构"><a href="#一、齐次线性方程组的解的结构" class="headerlink" title="一、齐次线性方程组的解的结构"></a>一、齐次线性方程组的解的结构</h4><ol><li><p>齐次线性方程组解向量的性质</p><p><strong>性质1：</strong>齐次的解相加还是齐次的解</p><p><strong>性质2：</strong>齐次的解乘常数还是齐次的解</p><p><span style="color:red;font-size:20px">定义：</span>齐次线性方程组的所有解构成的向量组的最大无关组称为该齐次线性方程组的基础解系</p></li></ol><p><img src="/images/linear-algebra/image-20210708145621760.png" alt=""></p><ol><li><p>齐次线性方程组的基础解系的性质</p><p><strong>定理：</strong><script type="math/tex">设R(A_{m\times n})=r，则n元齐次线性方程组A_{m\times n}x=0</script>的基础解系中有n-r个解向量，即s=n-r</p><p>R(A)：有效方程个数；n：未知量个数；n-R(A)：自由未知量个数</p><p><strong>推论：</strong><script type="math/tex">A_{m\times n}x=0的任意n-r(A)个线性无关的解即为A_{m\times n}x=0的基础解系</script></p><p><strong>结论：</strong>若<script type="math/tex">\xi_1,\xi_2,\cdots,\xi_{n-r}为A_{m \times n} x=0</script>的一个基础解系</p><p>则 <script type="math/tex">A_{m \times n} x=0 的通解为\quad x=c_{1} \xi_{1}+c_{2} \xi_{2}+\cdots+c_{n-r} \xi_{n-r}</script></p></li></ol><h4 id="二、非齐次线性方程组解的结构"><a href="#二、非齐次线性方程组解的结构" class="headerlink" title="二、非齐次线性方程组解的结构"></a>二、非齐次线性方程组解的结构</h4><p><strong>性质：</strong></p><p>（1）两个非齐的解相减是齐次的解</p><p>（2）齐次的解加非齐的解是非齐的解</p><p><strong>note：</strong>当<script type="math/tex">R(A)=r<n时, 求 A x=b的通解只要求A x=b的一个特解\eta^{*}和 A x=0 的通解\\ x=c_{1} \xi_{1}+\cdots+c_{n-r} \xi_{n-r}，则 A x=b 的通解为 x=\eta^{*}+c_{1} \xi_{1}+\cdots+c_{n-r} \xi_{n-r}</script></p><h3 id="第五节-向量空间"><a href="#第五节-向量空间" class="headerlink" title="第五节 向量空间"></a>第五节 向量空间</h3><h4 id="一、向量空间的定义"><a href="#一、向量空间的定义" class="headerlink" title="一、向量空间的定义"></a>一、向量空间的定义</h4><p><span style="color:red;font-size:20px">定义：</span>设V为n维向量的集合，如果集合V非空，且集合V对于向量的加法和数乘两种运算<strong>封闭</strong>，那么称集合V为<strong>向量空间</strong></p><p><strong>note：</strong>向量空间必含零向量</p><p>n元齐次线性方程组的解集是一个向量空间（称为齐次线性方程组的<strong>解空间</strong>）</p><h4 id="二、生成空间"><a href="#二、生成空间" class="headerlink" title="二、生成空间"></a>二、生成空间</h4><p>设 <script type="math/tex">\alpha_{1}, \cdots, \alpha_{m}</script> 为一n维向量组，则</p><script type="math/tex; mode=display">V=\left\{\lambda_{1} \alpha_{1}+\cdots+\lambda_{m} \alpha_{m} \mid \lambda_{1}, \cdots, \lambda_{m} \in R\right\}</script><p>是一向量空间, 称V是由 <script type="math/tex">\alpha_{1}, \cdots, \alpha_{m} 所生成的向量空间。 记为 V=L\{\alpha_{1}, \cdots, \alpha_{m}\}</script>.</p><p><strong>note：</strong></p><p>（1）<script type="math/tex">\alpha,\cdots,\alpha_m与=L\{\alpha_{1}, \cdots, \alpha_{m}\}</script>等价</p><p>（2）等价的向量组所生成的向量空间是相等的</p><h4 id="三、向量空间的基，维数与坐标"><a href="#三、向量空间的基，维数与坐标" class="headerlink" title="三、向量空间的基，维数与坐标"></a>三、向量空间的基，维数与坐标</h4><ol><li><h5 id="基、维数"><a href="#基、维数" class="headerlink" title="基、维数"></a>基、维数</h5><p><span style="color:red;font-size:20px">定义：</span>设V为向量空间，$\alpha,\cdots,\alpha_r∈V$且满足:<br>（1）$\alpha,\cdots,\alpha_r$线性无关;<br>（2）任意α∈V都可由$\alpha,\cdots,\alpha_r$线性表示.<br>则称$\alpha,\cdots,\alpha_r$是V的基，r为V的维数。记为dimV =r。<br>规定零空间的维数为0，没有基</p><p><strong>note：</strong></p><p>（1）若向量空间V看成向量组，则V的基就是V的最大无关组，向量空间的维数r就是V的秩。<br>进而V中任何r个线性无关的向量都是V的基。</p><p>（2）<script type="math/tex">若 \alpha_{1}, \cdots, \alpha_{r} 是向量空间 V的基, 则V =L\left\{\alpha_{1}, \cdots, \alpha_{r}\right\};\\若V =L\left\{\alpha_{1}, \cdots, {\alpha}_{m}\right\}，则 \alpha_{1}, \cdots, \alpha_{m} 的最大无关组为 V 的基。</script></p></li><li><h5 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h5><p><span style="color:red;font-size:20px">定义：</span><script type="math/tex">设 \alpha_{1}, \cdots, \alpha_{r} 是向量空间V的一组基，那么对\forall \beta \in V 都可唯一表示为\\\beta=x_{1} \alpha_{1}+\cdots+x_{r} \alpha_{r}，称有序数组 \left(x_{1}, \cdots, x_{r}\right) 是向量 \beta 在基 \alpha_{1}, \cdots, \alpha_{r} 的坐标。</script></p><p><strong>note：</strong>基给定后，求一个向量的坐标就是求非齐次线性方程组的解。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="2021/04/11/data-structure/"/>
      <url>2021/04/11/data-structure/</url>
      
        <content type="html"><![CDATA[<p>使用的教材：</p><p>数据结构（C语言版） 严蔚敏</p><p>王道数据结构考研复习指导（2022）</p><center><span style="color:blue;font-size:15px">2021/4/11</span></center><h2 id="考研大纲（408）"><a href="#考研大纲（408）" class="headerlink" title="考研大纲（408）"></a>考研大纲（408）</h2><p>【408考查目标】</p><ol><li>掌握数据结构的基本概念、基本原理和基本方法。</li><li>掌握数据的逻辑结构、存储结构及基本操作的实现，能够对算法进行基本的时间复杂度与空间复杂度的分析。</li><li>能够运用数据结构基本原理和方法进行问题的分析与求解，具备采用 C 或 C++语言设计与实现算法的能力。</li></ol><h3 id="一、线性表"><a href="#一、线性表" class="headerlink" title="一、线性表"></a>一、线性表</h3><p> (一)线性表的基本概念<br> (二)线性表的实现（顺序存储、链式存储）<br> (三).线性表的应用</p><h3 id="二、栈、队列和数组"><a href="#二、栈、队列和数组" class="headerlink" title="二、栈、队列和数组"></a>二、栈、队列和数组</h3><p> (一)栈和队列的基本概念<br> (二)栈和队列的顺序存储结构<br> (三)栈和队列的链式存储结构<br> (四)多维数组的存储<br> (五)特殊矩阵的压缩存储<br> (六)栈、队列和数组的应用</p><h3 id="三、树与二叉树"><a href="#三、树与二叉树" class="headerlink" title="三、树与二叉树"></a>三、树与二叉树</h3><p>(一)树的基本概念</p><p>(二)二叉树<br> 1.二叉树的定义及其主要特征<br> 2.二叉树的顺序存储结构和链式存储结构<br> 3.二叉树的遍历<br> 4.线索二叉树的基本概念和构造</p><p>(三)树、森林<br> 1.树的存储结构<br> 2.森林与二叉树的转换<br> 3.树和森林的遍历</p><p>(四)树与二叉树的应用<br> 1.二叉搜索树<br> 2.平衡二叉树<br> 3.哈夫曼(Huffman)树和哈夫曼编码</p><h3 id="四、图"><a href="#四、图" class="headerlink" title="四、图"></a>四、图</h3><p> (一)图的基本概念<br> (二)图的存储及基本操作<br> 1.邻接矩阵法<br> 2.邻接表法<br> 3.邻接多重表、十字链表<br> (三)图的遍历<br> 1.深度优先搜索<br> 2.广度优先搜索<br> (四)图的基本应用<br> 1.最小(代价)生成树<br> 2.最短路径<br> 3.拓扑排序<br> 4.关键路径</p><h3 id="五、查找"><a href="#五、查找" class="headerlink" title="五、查找"></a>五、查找</h3><p> (一)查找的基本概念<br> (二)顺序查找法<br> (三)分块查找法<br> (四)折半查找法<br> (五)B 树及其基本操作、B+树的基本概念<br> (六)散列(Hash)表<br> (七)字符串模式匹配<br> (八)查找算法的分析及应用</p><h3 id="六、排序"><a href="#六、排序" class="headerlink" title="六、排序"></a>六、排序</h3><p> (一)排序的基本概念<br> (二)插入排序<br> 1.直接插入排序<br> 2.折半插入排序<br> (三)起泡排序(bubble sort)<br> (四)简单选择排序<br> (五)希尔排序(shell sort)<br> (六)快速排序<br> (七)堆排序<br> (八)二路归并排序(merge sort)<br> (九)基数排序<br> (十)外部排序<br> (十一)各种内部排序算法的比较<br> (十二)排序算法的应用</p><h2 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h2><p>本章的内容是数据结构概述，不在考研大纲中，但是分析算法的时间复杂度和空间复杂度是本章的重点，属于必考内容，一定要熟练掌握。</p><h3 id="1-1-数据结构的基本概念"><a href="#1-1-数据结构的基本概念" class="headerlink" title="1.1 数据结构的基本概念"></a>1.1 数据结构的基本概念</h3><h4 id="1-1-1-基本概念和术语"><a href="#1-1-1-基本概念和术语" class="headerlink" title="1.1.1 基本概念和术语"></a>1.1.1 基本概念和术语</h4><ul><li>数据：信息的载体，是对客观事物的符号表示</li><li>数据元素：数据的<strong>基本单位</strong>，一个数据元素可由若干个数据项组成。如：一个学生记录（学号、姓名、…）数据项是构成数据元素的不可分割的<strong>最小单位</strong></li><li>数据对象：具有相同性质的数据元素的集合，是数据的一个子集。</li><li>数据结构：是相互存在一种或多种特定<strong>关系</strong>的数据元素的集合；数据结构包括三方面的内容：<strong>逻辑结构</strong>，<strong>存储结构</strong>和<strong>数据的运算</strong></li><li>数据类型：原子类型、结构类型、抽象数据类型</li><li>抽象数据类型：指一个数学模型以及定义在该模型上的一组操作<ul><li>通常用（数据对象，数据关系，基本操作集）这样的三元组来表示抽象数据类型。</li><li>ADT 抽象数据类型名{<br>数据对象:&lt;数据对象的定义&gt;<br>数据关系:&lt;数据关系的定义&gt;<br>基本操作:&lt;基本操作的定义&gt;<br>}ADT 抽象数据类型名</li></ul></li></ul><h4 id="1-1-2-数据结构三要素"><a href="#1-1-2-数据结构三要素" class="headerlink" title="1.1.2 数据结构三要素"></a>1.1.2 数据结构三要素</h4><h5 id="1-数据的逻辑结构"><a href="#1-数据的逻辑结构" class="headerlink" title="1.数据的逻辑结构"></a>1.数据的逻辑结构</h5><p>线性结构：一对一<br>树形结构：一对多<br>图结构：多对多<br>集合</p><h5 id="2-数据的存储结构"><a href="#2-数据的存储结构" class="headerlink" title="2.数据的存储结构"></a>2.数据的存储结构</h5><p>顺序存储<br>链式存储<br>索引存储<br>散列存储</p><p>绪论部分只需要理解三点:<br>1.若采用<strong>顺序存储</strong>，则各个数据元素在<strong>物理上必须是连续的</strong>；若采用<strong>非顺序存储</strong>，则各个数据元素在物理上可以是<strong>离散的</strong>。<br>2.数据的<strong>存储结构</strong>会影响<strong>存储空间分配的方便程度</strong>。<br>3.数据的<strong>存储结构</strong>会影响对<strong>数据运算的速度</strong>。</p><h5 id="3-数据的运算"><a href="#3-数据的运算" class="headerlink" title="3.数据的运算"></a>3.数据的运算</h5><p>施加在数据上的运算包括运算的定义和实现。<strong>运算的定义</strong>是<strong>针对逻辑结构</strong>的，指出运算的功能；<strong>运算的实现</strong>是<strong>针对存储结构</strong>的，指出运算的具体操作步骤。</p><h3 id="1-2-算法和算法分析"><a href="#1-2-算法和算法分析" class="headerlink" title="1.2 算法和算法分析"></a>1.2 算法和算法分析</h3><h4 id="1-2-2-算法效率的度量"><a href="#1-2-2-算法效率的度量" class="headerlink" title="1.2.2 算法效率的度量"></a>1.2.2 算法效率的度量</h4><p><strong>1.时间复杂度</strong></p><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的<strong>某个函数</strong>f(n)，算法的时间量度记作</p><script type="math/tex; mode=display">T(n)=O(f(n))</script><p>它表示随问题规模n的增大，算法执行时间的<strong>增长率</strong>和f(n)的增长率相同，称作算法的<strong>渐进时间复杂度</strong>，简称时<strong>间复杂度</strong>。</p><p>常见的渐进时间复杂度为</p><p>$O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$</p><p><strong>2.空间复杂度</strong></p><p>算法的空间复杂度作为算法所需存储空间的量度，记作</p><script type="math/tex; mode=display">S(n)=O(f(n))</script><center><span style="color:blue;font-size:15px">2021/4/12</span></center><h2 id="第2章-线性表"><a href="#第2章-线性表" class="headerlink" title="第2章 线性表"></a>第2章 线性表</h2><p>线性表是考研的重点，实现起来比较容易而且代码量较少，但却要求具有最优的性能才能获得满分。</p><h3 id="408大纲"><a href="#408大纲" class="headerlink" title="408大纲"></a>408大纲</h3><p> (一)线性表的基本概念<br> (二)线性表的实现（顺序存储、链式存储）<br> (三).线性表的应用</p><h3 id="2-1-线性表的定义和基本操作"><a href="#2-1-线性表的定义和基本操作" class="headerlink" title="2.1 线性表的定义和基本操作"></a>2.1 线性表的定义和基本操作</h3><h4 id="2-1-1-线性表的定义"><a href="#2-1-1-线性表的定义" class="headerlink" title="2.1.1 线性表的定义"></a>2.1.1 线性表的定义</h4><p>线性表是具有<strong>相同数据类型</strong>的n个数据元素的<strong>有限序列</strong>，其中n为表长，当n=0时，是一个空表。<br>若将线性表记为</p><script type="math/tex; mode=display">L=(a_1,a_2,...,a_n)</script><p>除第一个元素外，每一个元素有且仅有一个直接前驱，每个元素有且仅有一个直接后继。</p><p><strong>注意：</strong>线性表是一种逻辑结构，顺序表和链表是指存储结构。</p><h4 id="2-1-2-线性表的基本操作"><a href="#2-1-2-线性表的基本操作" class="headerlink" title="2.1.2 线性表的基本操作"></a>2.1.2 线性表的基本操作</h4><p>InitList(&amp;L)：初始化表。构造一个空的线性表。<br>Length(L)：求表长。返回线性表I的长度，即L中数据元素的个数。<br>LocateElem(L,e)：按值查找操作。在表L中查找具有给定 关键字值的元素。<br>GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。<br>ListInsert(&amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e.<br>ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值<br>PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。<br>Empty(L)：判空操作。若L为空表，则返回true,否则返回false.<br>DestroyList(&amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</p><h3 id="2-2-线性表的顺序表示"><a href="#2-2-线性表的顺序表示" class="headerlink" title="2.2 线性表的顺序表示"></a>2.2 线性表的顺序表示</h3><h4 id="2-2-1-顺序表的定义"><a href="#2-2-1-顺序表的定义" class="headerlink" title="2.2.1 顺序表的定义"></a>2.2.1 顺序表的定义</h4><p>顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。因此，<strong>顺序表的特点是表中元素的逻辑地址与其物理顺序相同。</strong></p><p><img src="/images/Data-Structure/image-20210412091209532.png" alt=""></p><p><strong>注意：</strong>线性表中元素的位序是从1开始的，而数组中元素的下标是从0开始的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">InitSize <span class="token number">100</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    Elemtype <span class="token operator">*</span>data<span class="token punctuation">;</span>    <span class="token keyword">int</span> maxSize<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span> <span class="token comment">//在进行增删操作后记得更改length</span><span class="token punctuation">}</span>Sqlist<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//动态增加动态数组的长度</span><span class="token keyword">void</span> <span class="token function">IncreaseSize</span><span class="token punctuation">(</span>SeqList <span class="token operator">&amp;</span>L，<span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>data<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>MaxSize<span class="token operator">+</span>len<span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    L<span class="token punctuation">.</span>MaxSize<span class="token operator">=</span>L<span class="token punctuation">.</span>MaxSize<span class="token operator">+</span>len<span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顺序表最主要的特点是<strong>随机访问</strong>，即通过首地址和元素序号可在时间O(1)内找到指定的元素。<br>顺序表的存储密度高，每个结点只存储数据元素。<br>顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。</p><h4 id="2-2-2-顺序表上基本操作的实现"><a href="#2-2-2-顺序表上基本操作的实现" class="headerlink" title="2.2.2 顺序表上基本操作的实现"></a>2.2.2 顺序表上基本操作的实现</h4><p>略</p><center><span style="color:blue;font-size:15px">2021/4/13</span></center><h3 id="2-3-线性表的链式表示"><a href="#2-3-线性表的链式表示" class="headerlink" title="2.3 线性表的链式表示"></a>2.3 线性表的链式表示</h3><p>链式存储线性表时，不要求逻辑上相邻的两个元素在物理位置上也相邻，因此对线性表的插入、删除不需要移动元素，只需要修改指针。</p><h4 id="2-3-1-单链表的定义"><a href="#2-3-1-单链表的定义" class="headerlink" title="2.3.1 单链表的定义"></a>2.3.1 单链表的定义</h4><p>线性表的链式存储又称单链表，它是指通过一组任意的存储单 元来存储线性表中的数据元素。对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。</p><p>单链表中结点类型的描述如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">{</span>ElemType data<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>LNode<span class="token punctuation">,</span><span class="token operator">*</span>LinkList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>利用单链表可以解决顺序表需要大量连续存储空间的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。单链表是<strong>非随机存取</strong>的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要<strong>从表头开始遍历，依次查找</strong>。通常用<strong>头指针</strong>来标识一个单链表，如单链表L，头指针为NULL时表示一个空表。 此外，为了操作上的方便，在单链表第一个结点之前附加一个结点，称为<strong>头结点</strong>。头结点的数据域可以不设任何信息，也可以记录表长等相关信息。头结点的指针域指向线性表的第一个元素结点。</p><p><img src="/images/Data-Structure/image-20210413111617026.png" alt=""></p><p>可入头结点后，可以带来两个优点:<br>①在链表的第一个位置上的操作和在表的其他位置上的操作一致， 无须进行特殊处理。<br>②无论链表是否为空，其头指针都指向头结点的非空指针(空表中头结点的指针域为空，因此空表和非空表的处理也就得到了统一。</p><h4 id="2-3-2-单链表上基本操作的实现"><a href="#2-3-2-单链表上基本操作的实现" class="headerlink" title="2.3.2 单链表上基本操作的实现"></a>2.3.2 单链表上基本操作的实现</h4><p>只写全一个例子</p><p><strong>1.采用头插法建立单链表</strong></p><p><img src="/images/Data-Structure/image-20210413113850093.png" alt=""></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LinkList <span class="token function">List_HeadInsert</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>LNode <span class="token operator">*</span>s<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">;</span>L<span class="token operator">=</span><span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建头结点</span>L<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token number">9999</span><span class="token punctuation">)</span><span class="token punctuation">{</span>s<span class="token operator">=</span><span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token operator">-&gt;</span>data<span class="token operator">=</span>x<span class="token punctuation">;</span>s<span class="token operator">-&gt;</span>next<span class="token operator">=</span>L<span class="token operator">-&gt;</span>nextL<span class="token operator">-&gt;</span>next<span class="token operator">=</span>s<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单链表在插入元素时，在给定的结点后插入，时间复杂度仅为O(1)，但在前面插入时，如果从头开始寻找第前置元素，时间复杂度为O(n)，我们可以通过另一种方法转化为后插操作（后插+换数据）使得时间复杂度为O(1)。</p><p>删除元素同理。</p><h4 id="2-3-3-双链表"><a href="#2-3-3-双链表" class="headerlink" title="2.3.3 双链表"></a>2.3.3 双链表</h4><p>双链表结点中有两个指针prior和next，分别指向其前驱结点和后驱结点。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">DNode</span><span class="token punctuation">{</span>ElemType data<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">DNode</span> <span class="token operator">*</span>prior<span class="token punctuation">,</span><span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>DNode<span class="token punctuation">,</span><span class="token operator">*</span>DLinkList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/Data-Structure/image-20210413220828493.png" alt=""></p><p>双链表可以很方便地找到其前驱结点，因此，插入，删除操作的时间复杂度仅为O(1)。</p><h4 id="2-3-4-循环链表"><a href="#2-3-4-循环链表" class="headerlink" title="2.3.4 循环链表"></a>2.3.4 循环链表</h4><p>1.循环单链表</p><p>在循环单链表中，表尾结点*r的next域指向L，故表中没有指针域为NULL的结点，因此，循环单链表的判空条件是头结点的指针是否等于头指针。</p><p>2.循环双链表</p><h4 id="2-3-5-静态链表"><a href="#2-3-5-静态链表" class="headerlink" title="2.3.5 静态链表"></a>2.3.5 静态链表</h4><p><img src="/images/Data-Structure/image-20210413223005264.png" alt=""></p><center><span style="color:blue;font-size:15px">2021/4/14</span></center><h4 id="2-3-6-顺序表和链表的比较"><a href="#2-3-6-顺序表和链表的比较" class="headerlink" title="2.3.6 顺序表和链表的比较"></a>2.3.6 顺序表和链表的比较</h4><p><strong>1.存取(读写)方式</strong><br>顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序依次存取元素。</p><p><strong>2.逻辑结构与物理结构</strong><br>采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。</p><p><strong>3.查找、插入和删除操作</strong><br>对于按值查找，顺序表无序时，两者的时间复杂度均为O(n)；顺序表有序时，可采用折半查找，此时的时间复杂度为O($\log_2n$)。<br>对于按序号查找，顺序表支持随机访问，时间复杂度仅为0(1)；而链表的平均时间复杂度为O(n)。<br>顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。由于链表的每个结点都带有指针域，故而存储密度不够大。</p><p><strong>4.空间分配</strong><br>顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。<br>链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。</p><p><strong>在实际中存储结构的选择</strong></p><p><strong>1.基于存储的考虑</strong><br>难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低。</p><p><strong>2.基于运算的考虑</strong><br>若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。<br>进行插入、删除操作时，显然后者优于前者。</p><p>总之，两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。通常较稳定的线性表选择顺序存储，而频繁进行插入，删除操作的线性表（动态性较强）宜选择链式存储。</p><center><span style="color:blue;font-size:15px">2021/4/16</span></center><h2 id="第3章-栈和队列"><a href="#第3章-栈和队列" class="headerlink" title="第3章 栈和队列"></a>第3章 栈和队列</h2><p>本章通常以选择题的形式考查，题目不算难，但命题的形式比较灵活，其中栈(出入栈的过程、出栈序列的合法性)和队列的操作及其特征是重点。由于它们均是线性表的应用和推广，因此也容易出现在算法设计题中。此外，栈和队列的顺序存储、链式存储及其特点、双端队列的特点、栈和队列的常见应用，以及数组和特殊矩阵的压缩存储都是必须掌握的内容。</p><h3 id="408大纲-1"><a href="#408大纲-1" class="headerlink" title="408大纲"></a>408大纲</h3><p> (一)栈和队列的基本概念<br> (二)栈和队列的顺序存储结构<br> (三)栈和队列的链式存储结构<br> (四)多维数组的存储<br> (五)特殊矩阵的压缩存储<br> (六)栈、队列和数组的应用</p><h3 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h3><h4 id="3-1-1-栈的基本概念"><a href="#3-1-1-栈的基本概念" class="headerlink" title="3.1.1 栈的基本概念"></a>3.1.1 栈的基本概念</h4><h5 id="1-栈的定义"><a href="#1-栈的定义" class="headerlink" title="1.栈的定义"></a>1.栈的定义</h5><p><img src="/images/Data-Structure/image-20210416211011395.png" alt=""></p><p><strong>栈</strong>是只允许在一端进行插入或删除操作的<strong>线性表</strong>。<br><strong>栈顶</strong>：线性表允许进行插入删除的那一端。<br><strong>栈底</strong>：固定的，不允许进行插入和删除的另一端。</p><p>栈的操作特性可以明显地概括为后进先出（LIFO）</p><h5 id="2-栈的基本操作"><a href="#2-栈的基本操作" class="headerlink" title="2.栈的基本操作"></a>2.栈的基本操作</h5><p>InitStack(&amp;S)：初始化一个空栈S。<br>StackEmpty(S)：判断一个栈是否为空，若栈s为空则返回true，否则返回false。<br>Push(&amp;S,x)：进栈，若栈s未满，则将x加入使之成为新栈顶。<br>Pop(&amp;S,&amp;x)：出栈，若栈s非空，则弹出栈项元素，并用x返回。<br>GetTop(S,&amp;x)：读栈顶元素，若栈s非空，则用x返回栈项元素。<br>DestroyStack(&amp;S)：销毁栈，并释放栈S占用的存储空间</p><p><strong>在解答算法题时，若题干未做出限制，则可直接使用这些基本的操作函数。</strong></p><h4 id="3-1-2-栈的顺序存储结构"><a href="#3-1-2-栈的顺序存储结构" class="headerlink" title="3.1.2 栈的顺序存储结构"></a>3.1.2 栈的顺序存储结构</h4><p>栈是一种操作受限的线性表，类似于线性表，它也有对应的两种存储方式。</p><h5 id="1-顺序栈的实现"><a href="#1-顺序栈的实现" class="headerlink" title="1.顺序栈的实现"></a>1.顺序栈的实现</h5><p>栈的顺序存储类型可描述为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MaxSize <span class="token number">50</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span><span class="token punctuation">}</span>sqstack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>栈项指针</strong>：S.top，初始时设置S.top=-1；栈项元素：S.data[S.top]。<br><strong>进栈操作</strong>：栈不满时，栈顶指针先加1，再送值到栈顶元素。<br><strong>出栈操作</strong>：栈非空时，先取栈顶元素值，再将栈顶指针减1。<br><strong>栈空条件</strong>：s. top=\=-1；<strong>栈满条件</strong>: S.top==MaxSize-1; <strong>栈长</strong>: s. top+1。</p><p><strong>注意</strong>:栈和队列的判空、判满条件，会因实际给的条件不同而变化，需具体问题具体分析。</p><h5 id="2-顺序栈的基本运算"><a href="#2-顺序栈的基本运算" class="headerlink" title="2.顺序栈的基本运算"></a>2.顺序栈的基本运算</h5><p>同上。</p><h5 id="3-共享栈"><a href="#3-共享栈" class="headerlink" title="3.共享栈"></a>3.共享栈</h5><p>利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。<br>共享栈是为了更有效地利用存储空间，两个栈的空间相互调节。</p><h4 id="3-1-3-栈的链式存储结构"><a href="#3-1-3-栈的链式存储结构" class="headerlink" title="3.1.3 栈的链式存储结构"></a>3.1.3 栈的链式存储结构</h4><p>采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且<strong>不存在栈满上溢的情况</strong>。通常采用单链表实现，并规定<strong>所有操作都是在单链表的表头进行的</strong>。这里规定链栈没有头结点，Lhead 指向栈顶元素。</p><p><img src="/images/Data-Structure/image-20210422154019487.png" alt=""></p><p>栈的顺序存储类型可描述为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Linknode</span><span class="token punctuation">{</span>    ELemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Linknode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token operator">*</span>Listack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>采用链式存储，便于结点的插入与删除。链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行。</p><h3 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h3><h4 id="3-2-1-队列的基本概念"><a href="#3-2-1-队列的基本概念" class="headerlink" title="3.2.1 队列的基本概念"></a>3.2.1 队列的基本概念</h4><h5 id="1-队列的定义"><a href="#1-队列的定义" class="headerlink" title="1.队列的定义"></a>1.队列的定义</h5><p>队列简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。其操作的特性是先进先出(FIFO)<br><strong>队头</strong>：允许删除的一端，又称队首<br><strong>队尾</strong>：允许插入的一端</p><h5 id="2-队列常见的基本操作"><a href="#2-队列常见的基本操作" class="headerlink" title="2.队列常见的基本操作"></a>2.队列常见的基本操作</h5><p>InitQueue(&amp;Q)：初始化队列，构造个空队列Q。<br>QueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。<br>EnQueue(&amp;Q,x)：入队，若队列Q未满，将x加入，使之成为新的队尾。<br>DeQueue(&amp;Q, &amp;x)：出队，若队列Q非空，删除队头元素，并用x返回。<br>GetHead(Q,&amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给X。</p><h4 id="3-2-2-队列的顺序存储结构"><a href="#3-2-2-队列的顺序存储结构" class="headerlink" title="3.2.2 队列的顺序存储结构"></a>3.2.2 队列的顺序存储结构</h4><h5 id="1-队列的顺序存储"><a href="#1-队列的顺序存储" class="headerlink" title="1.队列的顺序存储"></a>1.队列的顺序存储</h5><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置（不同教材对front和rear的定义可能不同，对于不同的定义，出队入队的操作是不同的）。</p><p>队列的顺序存储类型可描述为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MaxSize <span class="token number">50</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token punctuation">,</span>rear<span class="token punctuation">;</span><span class="token punctuation">}</span>SqQueue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>初始状态</strong>（队空条件）: Q.front==Q.rear==0。<br><strong>进队操作</strong>：队不满时，先送值到队尾元素，再将队尾指针加1。<br><strong>出队操作</strong>：队不空时，先取队头元素值，再将队头指针加1。</p><p>这样存储可能会发生“假溢出”。</p><p><img src="/images/Data-Structure/image-20210422155137122.png" alt=""></p><center><span style="color:blue;font-size:15px">2021/4/22</span></center><h5 id="2-循环队列"><a href="#2-循环队列" class="headerlink" title="2.循环队列"></a>2.循环队列</h5><p>为了克服顺序存储的缺点，这里引出循环队列的概念，即把存储队列元素的表从逻辑上视为一个环。当队首指针Q.front=MaxSize-1后，再前进一个位置就自动到0，这可以利用除法<strong>取余</strong>运算来实现。</p><p>初始时：Q.front=Q.rear=0。<br>队首指针进1：Q.front= (Q.front+1)%MaxSize。<br>队尾指针进1：Q.rear= (Q.rear+1)%MaxSize。<br>队列长度：(Q.rear+MaxSize-Q.front)%MaxSize。</p><p>但是队空和队满的条件都是Q.front==Q.rear，为了<strong>区分队空还是队满</strong>的情况，有三种处理方式：<br>（1）牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，约定以“队头指针在队尾指针的下-一位置作为队满的标志。<br>队满条件：(Q.rear+1) %MaxSize==Q.front。<br>队空条件仍：Q.front==Q.rear.<br>队列中元素的个数：(Q.rear-Q.front+MaxSize)%MaxSize。<br>（2）类型中增设表示元素个数的数据成员。这样，队空的条件为Q.size==0；队满的条件为Q.size==MaxSize。这两种情况都有Q.front==Q. rear。<br>（3）类型中增设tag 数据成员，以区分是队满还是队空。（入队置1，出队置0，初试设0）tag等于0时，若因删除导致Q. front==Q.rear，则为队空；tag等于1时,若因插入导致Q.front==Q.rear,则为队满。</p><p><img src="/images/Data-Structure/image-20210422164650942.png" alt=""></p><h5 id="3-循环队列的操作"><a href="#3-循环队列的操作" class="headerlink" title="3.循环队列的操作"></a>3.循环队列的操作</h5><p>（1）初始化<br>（2）判断空<br>（3）入队</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">EnQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>ElemType x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MaxSize<span class="token operator">==</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>data<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MaxSize<span class="token punctuation">;</span>    <span class="token keyword">return</span> ture<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）出队</p><h4 id="3-2-3-队列的链式存储结构"><a href="#3-2-3-队列的链式存储结构" class="headerlink" title="3.2.3 队列的链式存储结构"></a>3.2.3 队列的链式存储结构</h4><h5 id="1-队列的链式存储"><a href="#1-队列的链式存储" class="headerlink" title="1.队列的链式存储"></a>1.队列的链式存储</h5><p>队列的链式表示称为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点。</p><p><img src="/images/Data-Structure/image-20210422171448161.png" alt=""></p><p>队列的链式存储类型可描述为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    ElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>LinkNode<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    LinkNode <span class="token operator">*</span>front<span class="token punctuation">,</span> <span class="token operator">*</span>rear<span class="token punctuation">;</span><span class="token punctuation">}</span> LinkQueue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当Q.front==NULL且Q.rear==NULL时，链式队列为空。</p><p>不带头结点的链式队列在操作上往往比较麻烦，因此<strong>通常将链式队列设计成一个带头结点的单链表</strong>，这样插入和删除操作就统一了。</p><p><img src="/images/Data-Structure/image-20210422171950914.png" alt=""></p><p>用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。</p><h5 id="2-链式队列的基本操作"><a href="#2-链式队列的基本操作" class="headerlink" title="2.链式队列的基本操作"></a>2.链式队列的基本操作</h5><p>（1）初始化<br>（2）判断空<br>（3）入队<br>（4）出队</p><h4 id="3-2-4-双端队列"><a href="#3-2-4-双端队列" class="headerlink" title="3.2.4 双端队列"></a>3.2.4 双端队列</h4><p>双端队列是指允许两端都可以进行入队和出队操作的队列。其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端，两端都可以入队和出队。<br>输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列。<br>输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为输入受限的双端队列。<br>若限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相邻接的栈。</p><h3 id="3-3栈和队列的应用"><a href="#3-3栈和队列的应用" class="headerlink" title="3.3栈和队列的应用"></a>3.3栈和队列的应用</h3><h4 id="3-3-1-栈在括号匹配中的应用"><a href="#3-3-1-栈在括号匹配中的应用" class="headerlink" title="3.3.1 栈在括号匹配中的应用"></a>3.3.1 栈在括号匹配中的应用</h4><h4 id="3-2-2-栈在表达式求值中的应用"><a href="#3-2-2-栈在表达式求值中的应用" class="headerlink" title="3.2.2 栈在表达式求值中的应用"></a>3.2.2 栈在表达式求值中的应用</h4><div class="table-container"><table><thead><tr><th>中缀表达式(a 操作符 b)</th><th>后缀表达式(逆波兰式)(a b 操作符)</th><th>前缀表达式(波兰式)(操作符 a b)</th></tr></thead><tbody><tr><td>a+b</td><td>ab+</td><td>+ab</td></tr><tr><td>a+b-c</td><td>ab+c-</td><td>-+abc</td></tr><tr><td>a+b-c*d</td><td>ab+cd*-</td><td>-+ab*cd</td></tr><tr><td>a+b*(c-d)-e/f</td><td>abcd-*+ef/-</td><td>+a-*-cdb/ef</td></tr></tbody></table></div><p><strong>后缀表达式的运算：</strong></p><p>在后缀表达式中已考虑了运算符的优先级，没有括号，只有操作数和运算符。<br>中缀表达式A+B*(C-D)-E/F​所对应的后缀表达式为ABCD-*+EF/-​。</p><p>若项是操作数，则将其压入栈中；若项是操作符，则连续从栈中退出两个操作数Y和X，形成运算指令X op Y,并将计算结果重新压入栈中。全部处理完后，栈顶存放的就是结果。</p><p><strong>前缀表达式的运算：</strong></p><p>前缀表达式从右往左扫，原理差不多</p><p><strong>中缀表达式转后缀表达式：</strong></p><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。<br>从左到右处理各个元素，直到末尾。可能遇到三种情况: .<br>①遇到操作数。直接加入后缀表达式。<br>②遇到界限符。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(” 为止。注意:“(” 不加入后缀表达式。<br>③遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(”或栈空则停止。之后再把当前运算符入栈。<br>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p><p><a href="https://www.bilibili.com/video/BV1b7411N798?p=28">中缀表达式转后缀表达式/中缀表达式的计算（用栈实现）:</a></p><h4 id="3-3-3-栈在递归中的作用"><a href="#3-3-3-栈在递归中的作用" class="headerlink" title="3.3.3 栈在递归中的作用"></a>3.3.3 栈在递归中的作用</h4><p>适合用“递归”算法解决：可以把原始问题转换为<strong>属性相同</strong>，但<strong>规模较小</strong>的问题<br>栈递归算法大大减少了程序的代码量，但在通常情况下，它的效率不是太高。</p><p>递归函数的实现需要借助一个函数调用栈来实现。<br>（也可以将递归算法转换为非递归算法，通常需要借助栈来实现这种转换。）</p><h4 id="3-3-4-队列在层次遍历中的应用（广度优先遍历）"><a href="#3-3-4-队列在层次遍历中的应用（广度优先遍历）" class="headerlink" title="3.3.4 队列在层次遍历中的应用（广度优先遍历）"></a>3.3.4 队列在层次遍历中的应用（广度优先遍历）</h4><p>逐层\逐行处理（广度优先遍历）。这类问题的解决方法往往是在处理当前层或当前行时就对下一层或下一行做预处理，把处理顺序安排好，待当前层或当前行处理完毕，就可以处理下一层或下一行。使用队列是为了保存下一步的处理顺序。表3.2显示了层次遍历二叉树的过程。<br>该过程的简单描述如下:<br>①根结点入队。<br>②若队空（所有结点都已处理完毕），则结束遍历；否则重复③操作。<br>③队列中第一个结点出队并访问。若其有左孩子，则将左孩子入队；若其有右孩子，则将右孩子入队，返回②。</p><p><img src="/images/Data-Structure/image-20210422210537669.png" alt=""></p><h4 id="3-3-5-队列在计算机系统中的应用"><a href="#3-3-5-队列在计算机系统中的应用" class="headerlink" title="3.3.5 队列在计算机系统中的应用"></a>3.3.5 队列在计算机系统中的应用</h4><p>打印数据缓冲区、CPU进程访问队列……</p><center><span style="color:blue;font-size:15px">2021/4/23</span></center><h3 id="3-4-特殊矩阵的压缩存储"><a href="#3-4-特殊矩阵的压缩存储" class="headerlink" title="3.4 特殊矩阵的压缩存储"></a>3.4 特殊矩阵的压缩存储</h3><p>矩阵在计算机图形学、工程计算中占有举足轻重的地位。在数据结构中考虑的是如何用最小的内存空间来存储同样的一组数据。</p><h4 id="3-4-1-数组的定义"><a href="#3-4-1-数组的定义" class="headerlink" title="3.4.1 数组的定义"></a>3.4.1 数组的定义</h4><h4 id="3-4-2-数组的存储结构"><a href="#3-4-2-数组的存储结构" class="headerlink" title="3.4.2 数组的存储结构"></a>3.4.2 数组的存储结构</h4><h4 id="3-4-3-矩阵的压缩存储"><a href="#3-4-3-矩阵的压缩存储" class="headerlink" title="3.4.3 矩阵的压缩存储"></a>3.4.3 矩阵的压缩存储</h4><p>压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是为了节省存储空间。</p><h5 id="1-对称矩阵"><a href="#1-对称矩阵" class="headerlink" title="1.对称矩阵"></a>1.对称矩阵</h5><p><img src="/images/Data-Structure/PL%5D02XD8%5BHT24T%605$D1%7B%7BG4-1619144889792.png" alt=""></p><h5 id="2-三角矩阵"><a href="#2-三角矩阵" class="headerlink" title="2.三角矩阵"></a>2.三角矩阵</h5><p><img src="/images/Data-Structure/image-20210423103127933.png" alt=""></p><h5 id="3-三对角矩阵"><a href="#3-三对角矩阵" class="headerlink" title="3.三对角矩阵"></a>3.三对角矩阵</h5><p><img src="/images/Data-Structure/image-20210423104520259.png" alt=""></p><h4 id="3-4-4-稀疏矩阵"><a href="#3-4-4-稀疏矩阵" class="headerlink" title="3.4.4 稀疏矩阵"></a>3.4.4 稀疏矩阵</h4><p>稀疏矩阵：非零元素远远少于矩阵元素的个数</p><p><img src="/images/Data-Structure/image-20210423104735236.png" alt=""></p><center><span style="color:blue;font-size:15px">2021/4/27</span></center><h2 id="第4章-串"><a href="#第4章-串" class="headerlink" title="第4章 串"></a>第4章 串</h2><p>统考大纲只要求掌握字符串模式匹配，需重点掌握KMP匹配算法的原理及next数组的推理过程，了解nextval数组的求解方法。</p><h3 id="408大纲-2"><a href="#408大纲-2" class="headerlink" title="408大纲"></a>408大纲</h3><p>字符串模式匹配</p><h3 id="4-1-串的定义和实现"><a href="#4-1-串的定义和实现" class="headerlink" title="4.1 串的定义和实现"></a>4.1 串的定义和实现</h3><p>字符串简称串，计算机上非数值处理的对象基本都是字符串数据。</p><h4 id="4-1-1-串的定义"><a href="#4-1-1-串的定义" class="headerlink" title="4.1.1 串的定义"></a>4.1.1 串的定义</h4><p>串(string) 是由零个或多个字符组成的有限序列。一般记为</p><script type="math/tex; mode=display">S='{a_1a_2...a_n}'(n\geq0)</script><p><strong>子串：</strong>串中任意个连续的字符组成的子序列。<br><strong>主串：</strong>包含子串的串。<br><strong>字符在主串中的位置：</strong>字符在串中的序号。<br><strong>子串在主串中的位置：</strong>子串的第一个字符在主串中的位置。</p><p>串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集。</p><p>串的基本操作通常以子串作为操作对象，如查找、插入或删除一个子串等。</p><h4 id="4-1-2-串的顺序结构"><a href="#4-1-2-串的顺序结构" class="headerlink" title="4.1.2 串的顺序结构"></a>4.1.2 串的顺序结构</h4><h5 id="1-定长顺序存储表示"><a href="#1-定长顺序存储表示" class="headerlink" title="1.定长顺序存储表示"></a>1.定长顺序存储表示</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MAXLEN <span class="token number">255</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> ch<span class="token punctuation">[</span>MAXLEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span>SString<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>串长有两种表示方法：一是如上述定义描述的那样，用一个额外的变量len来存放串的长度；二是在串<br>值后面加一一个不计入串长的结束标记字符“\0”， 此时的串长为隐含值。</p><h5 id="2-堆（动态）分配存储表示"><a href="#2-堆（动态）分配存储表示" class="headerlink" title="2.堆（动态）分配存储表示"></a>2.堆（动态）分配存储表示</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span>SString<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-块链存储表示"><a href="#3-块链存储表示" class="headerlink" title="3.块链存储表示"></a>3.块链存储表示</h5><p>也可采用链表方式存储串值。由于串的特殊性(每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符， 也可以存放多个字符。每个结点称为块，整个链表称为块链结构。最后一个结点占不满时通常用“#”补上。</p><p><img src="/images/Data-Structure/image-20210427105854294.png" alt=""></p><h4 id="4-1-3-串的基本操作"><a href="#4-1-3-串的基本操作" class="headerlink" title="4.1.3 串的基本操作"></a>4.1.3 串的基本操作</h4><ul><li><strong>StrAssign(&amp;T, chars)：赋值操作。</strong>把串T赋值为chars。</li><li>StrCopy(&amp;T,S)：复制操作。由串S复制得到串T。</li><li>StrEmpty(S)：判空操作。若S为空串，则返回TRUE，否则返回FALSE。</li><li><strong>StrCompare(S,T)：比较操作</strong>。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0;若S&lt;T，则返回值&lt;0。</li><li><strong>StrLength(S)：求串长。</strong>返回串S的元素个数。</li><li><strong>SubString (&amp;Sub,S,pos,len)：求子串。</strong>用Sub返回串S的第pos个字符起长度为len的子串。</li><li><strong>Concat (&amp;T,S1,S2)：串联接。</strong>用T返回由S1和S2联接而成的新串。</li><li>Index(S,T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。</li><li>ClearString(&amp;S)：清空操作。将S清为空串。</li><li>DestroyString(&amp;S)：销毁串。将串S销毁。</li></ul><p>在上述定义的操作中，<strong>串赋值StrAssign、串比较StrCompare、求串长StrLength、串联接Concat及求子串SubString五种操作构成串类型的最小操作子集</strong>，即这些操作不可能利用其他串操作来实现；反之，其他串操作（除串清除ClearString和串销毁DestroyString外）均可在该最小操作子集上实现。</p><p>例如，可利用判等、求串长和求子串等操作实现定位函数Index(S,T)。算法思想为:在主串S中取从第一个字符起、长度和串T相等的子串，与串T比较，若相等则求得函数值为i，否则i值增1，直至串S中不存在和串T相等的子串为止。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Index</span><span class="token punctuation">(</span>String S，String T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token function">StrLength</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">,</span>m<span class="token operator">=</span><span class="token function">StrLength</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>n<span class="token operator">-</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">SubString</span><span class="token punctuation">(</span>sub<span class="token punctuation">,</span>S<span class="token punctuation">,</span>i<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">StrCompare</span><span class="token punctuation">(</span>sub<span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-串的模式匹配"><a href="#4-2-串的模式匹配" class="headerlink" title="4.2 串的模式匹配"></a>4.2 串的模式匹配</h3><p>子串的定位操作通常称为串的模式匹配，它求的是子串(常称模式串)在主串中的位置。</p><h4 id="4-2-1-简单的模式匹配算法"><a href="#4-2-1-简单的模式匹配算法" class="headerlink" title="4.2.1 简单的模式匹配算法"></a>4.2.1 简单的模式匹配算法</h4>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>又一次搞崩博客的经历</title>
      <link href="2021/02/14/annoying-err/"/>
      <url>2021/02/14/annoying-err/</url>
      
        <content type="html"><![CDATA[<p>经过一次折腾，网站又双叒叕访问不了了，怎么都解决不了，而且这次的问题也太怪了</p><p>ip和域名都能ping通</p><p><img src="/images/annoying-err/image-20210214134957668.png" alt=""></p><p>nginx启动正常</p><p><img src="/images/annoying-err/image-20210214134338024.png" alt=""></p><p>端口未被占用</p><p><img src="/images/annoying-err/image-20210214134406848.png" alt=""></p><p>防火墙已开放80端口（<a href="https://www.cnblogs.com/furenjian/p/12612547.html">防火墙设置 </a>）</p><p><img src="/images/annoying-err/image-20210214134506577.png" alt=""></p><p>然鹅就是访问不了</p><p><img src="/images/annoying-err/image-20210214134541301.png" alt=""></p><p>真是怪了，折腾了好久都不行，可能博客得瘫痪一段时间了</p><p>后记：突然又能用了，我等理解不能</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++中STL的常用用法</title>
      <link href="2021/02/03/cpp-stl/"/>
      <url>2021/02/03/cpp-stl/</url>
      
        <content type="html"><![CDATA[<h3 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h3><h4 id="1-容器（container）"><a href="#1-容器（container）" class="headerlink" title="1.容器（container）"></a>1.容器（container）</h4><ul><li>1.向量（vector）</li><li>2.双端队列（deque）</li><li>3.列表（list）</li><li>4.集合（set）</li><li>5.多重集合（multiset）</li><li>6.映射（map）</li><li>7.关联容器（associative）</li></ul><h4 id="2-迭代器（iterator）"><a href="#2-迭代器（iterator）" class="headerlink" title="2.迭代器（iterator）"></a>2.迭代器（iterator）</h4><p>迭代器提供了顺序访问容器中每个元素的方法。对迭代器可以使用“++”运算符来获得指向下一个元素的迭代器，可以使用“*”运算符访问一个迭代器所指向的元素。如果元素类型是类或结构体，还可以使用“-&gt;”运算符直接访问该元素的一个成员，有些迭代器还支持通过“—”运算符获得指向上一个元素的迭代器。指针也具有相同的特性，因此指针本身就是一种迭代器，迭代器是泛化的指针。</p><h4 id="3-函数对象（function-object）"><a href="#3-函数对象（function-object）" class="headerlink" title="3.函数对象（function object）"></a>3.函数对象（function object）</h4><p>函数对象是泛化的函数</p><h4 id="4-算法（algorithm）"><a href="#4-算法（algorithm）" class="headerlink" title="4.算法（algorithm）"></a>4.算法（algorithm）</h4><p>使用STL的算法，需要包含头文件\<algorithm\></algorithm\></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="map-unordered-map"><a href="#map-unordered-map" class="headerlink" title="map / unordered_map"></a>map / unordered_map</h3><p>map是STL的一个关联容器，它提供一对一的hash。</p><ul><li>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；</li><li>第二个可能称为该关键字的值(value)；</li></ul><p>使用map得包含map类所在的头文件</p><p><code>#include &lt;map&gt;</code></p><h4 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h4><p><code>map&lt;int, string&gt; hashtable;</code></p><h4 id="插入元素："><a href="#插入元素：" class="headerlink" title="插入元素："></a>插入元素：</h4><p> <code>hashtable[7] = "seven";</code><br> <code>hashtable.insert(pair&lt;int, string&gt;(7, "seven"));</code></p><h4 id="查找元素："><a href="#查找元素：" class="headerlink" title="查找元素："></a>查找元素：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// find 返回迭代器指向当前查找元素的位置否则返回map::end()位置</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span><span class="token operator">::</span>iterator iter <span class="token operator">=</span>  hashtable<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用auto更好</span><span class="token keyword">if</span><span class="token punctuation">(</span>iter <span class="token operator">!=</span> hashtable<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span>iter<span class="token operator">-&gt;</span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="刪除与清空元素："><a href="#刪除与清空元素：" class="headerlink" title="刪除与清空元素："></a>刪除与清空元素：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//迭代器刪除</span>iter <span class="token operator">=</span> hashtable<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hashtable<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//用关键字刪除</span><span class="token keyword">int</span> status <span class="token operator">=</span> hashtable<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//如果刪除了會返回1，否則返回0</span> <span class="token comment">//用迭代器范围刪除 : 把整个map清空</span>hashtable<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>hashtable<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hashtable<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等同于hashtable.clear()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="map的大小："><a href="#map的大小：" class="headerlink" title="map的大小："></a>map的大小：</h4><p><code>hashtable.size();</code></p><h4 id="其他常用用法："><a href="#其他常用用法：" class="headerlink" title="其他常用用法："></a>其他常用用法：</h4><p><strong>begin</strong>()     返回指向map头部的迭代器</p><p><strong>end</strong>()      返回指向map末尾的迭代器</p><p><strong>count</strong>()     返回指定元素出现的次数</p><p><strong>empty</strong>()     如果map为空则返回true</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端</title>
      <link href="2021/01/28/front-end/"/>
      <url>2021/01/28/front-end/</url>
      
        <content type="html"><![CDATA[<p>在学校学过，然后就没有然后了。。。</p><p>本篇大多内容来自菜鸟教程</p><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><p>内容不多，看着菜鸟教程入门的写了一个<a href="/html/Front-end/dazahui.html">超级无敌大浆糊页面</a></p><p>不过hexo居然丧心病狂地把我这个页面也给渲染了。。。查到的<a href="https://blog.csdn.net/weixin_41287260/article/details/99705257">解决办法</a></p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>CSS 指层叠样式表 (<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)<br>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:<br>选择器通常是您需要改变样式的 HTML 元素。每条声明由一个属性和一个值组成。</p><p>例：<code>p {color:red;text-align:center;}</code></p><p>CSS注释：</p><p><code>/*这是个注释*/</code></p><h3 id="id-和-class-选择器"><a href="#id-和-class-选择器" class="headerlink" title="id 和 class 选择器"></a>id 和 class 选择器</h3><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">#para1</span><span class="token punctuation">{</span>    <span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点”.”号显示：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*所有拥有 center 类的 HTML 元素均为居中*/</span><span class="token selector">.center</span> <span class="token punctuation">{</span><span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*所有的 p 元素使用 class="center" 让该元素的文本居中*/</span><span class="token selector">p.center</span> <span class="token punctuation">{</span><span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>类名的第一个字符不能使用数字！</strong></p><h3 id="如何插入样式表"><a href="#如何插入样式表" class="headerlink" title="如何插入样式表"></a>如何插入样式表</h3><p>插入样式表的方法有三种:</p><ul><li>外部样式表(External style sheet)</li><li>内部样式表(Internal style sheet)</li><li>内联样式(Inline style)</li></ul><h4 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h4><p>当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，可以通过改变一个文件来改变整个站点的外观。每个页面使用 link 标签链接到样式表。 link 标签在（文档的）头部：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mystyle.css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>外部样式表可以在任何文本编辑器中进行编辑。文件不能包含任何的 html 标签。样式表应该以 .css 扩展名进行保存。下面是一个样式表文件的例子：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">hr</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>sienna<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">p</span> <span class="token punctuation">{</span><span class="token property">margin-left</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">body</span> <span class="token punctuation">{</span><span class="token property">background-image</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">"/images/back40.gif"</span><span class="token punctuation">)</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h4><p>当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 style 标签在文档头部定义内部样式表</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">        <span class="token selector">hr</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>sienna<span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token selector">p</span> <span class="token punctuation">{</span><span class="token property">margin-left</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token selector">body</span> <span class="token punctuation">{</span><span class="token property">background-image</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">"images/back40.gif"</span><span class="token punctuation">)</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token selector">table,th,td</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">/*逗号：多个标签*/</span>        <span class="token selector">tr.alt td</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">/*空格：class为alt的tr下层的td*/</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><p>请慎用这种方法</p><p>要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>sienna<span class="token punctuation">;</span><span class="token property">margin-left</span><span class="token punctuation">:</span>20px</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是一个段落。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="color:sienna;margin-left:20px">这是一个段落。</p><h4 id="多重样式优先级"><a href="#多重样式优先级" class="headerlink" title="多重样式优先级"></a>多重样式优先级</h4><p>样式表允许以多种方式规定样式信息。样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。一般情况下，优先级如下：</p><p><strong>内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</strong></p><blockquote><p><strong>注意：*</strong>如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。*</p></blockquote><h3 id="CSS-backgrounds-背景"><a href="#CSS-backgrounds-背景" class="headerlink" title="CSS backgrounds(背景)"></a>CSS backgrounds(背景)</h3><ul><li>background-color</li><li>background-image</li><li>background-repeat</li><li>background-attachment</li><li>background-position</li><li>background</li></ul><h4 id="background-color-背景颜色"><a href="#background-color-背景颜色" class="headerlink" title="background-color 背景颜色"></a>background-color 背景颜色</h4><p>red;<br>#00ff00;<br>rgb(255,0,0);</p><h4 id="background-image-背景图片"><a href="#background-image-背景图片" class="headerlink" title="background-image 背景图片"></a>background-image 背景图片</h4><p><code>body {background-image:url('1.jpg');}</code></p><h4 id="background-repeat-背景图片重复平铺"><a href="#background-repeat-背景图片重复平铺" class="headerlink" title="background-repeat 背景图片重复平铺"></a>background-repeat 背景图片重复平铺</h4><p>默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体。一些图像如果在水平方向与垂直方向平铺，这样看起来很不协调，</p><p><code>background-repeat:repeat-x;</code></p><p>这样就让其只在水平方向平铺</p><h4 id="background-attachment-背景图片定位"><a href="#background-attachment-背景图片定位" class="headerlink" title="background-attachment 背景图片定位"></a>background-attachment 背景图片定位</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">body</span><span class="token punctuation">{</span><span class="token property">background-image</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">'img_tree.png'</span><span class="token punctuation">)</span></span><span class="token punctuation">;</span><span class="token property">background-repeat</span><span class="token punctuation">:</span>no-repeat<span class="token punctuation">;</span><span class="token property">background-position</span><span class="token punctuation">:</span>right top<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就实现了图片不重复，且放在右上角</p><h4 id="background-position-背景随页面滚动"><a href="#background-position-背景随页面滚动" class="headerlink" title="background-position 背景随页面滚动"></a>background-position 背景随页面滚动</h4><p>background-attachment属性设置背景图像是否固定或者随着页面的其余部分滚动。</p><h4 id="background-简写属性"><a href="#background-简写属性" class="headerlink" title="background 简写属性"></a>background 简写属性</h4><p><code>body {background:#ffffff url('img_tree.png') no-repeat right top;}</code></p><p>顺序为上面介绍的顺序，无需全部使用，可以按照页面的实际需要使用.</p><iframe src="https://www.runoob.com/try/try.php?filename=trycss_background_shorthand2" width="100%" height="600"></iframe><h3 id="CSS-text-文本"><a href="#CSS-text-文本" class="headerlink" title="CSS text(文本)"></a>CSS text(文本)</h3><ul><li>color</li><li>text-align</li><li>text-decoration</li><li>text-transform</li><li>text-indent</li><li>letter-spacing</li><li>line-height</li><li>word-spacing</li><li>text-shadow</li></ul><h4 id="color-文本颜色"><a href="#color-文本颜色" class="headerlink" title="color 文本颜色"></a>color 文本颜色</h4><p><code>&lt;span style="color:red;"&gt;这是红字&lt;/span&gt;</code></p><p><span style="color:red;">这是红字</span></p><h4 id="text-align-文本的对齐方式"><a href="#text-align-文本的对齐方式" class="headerlink" title="text-align 文本的对齐方式"></a>text-align 文本的对齐方式</h4><p><code>&lt;p style="text-align:center;"&gt;我在中间&lt;/p&gt;</code></p><p style="text-align:center;">我在中间</p><h4 id="text-decoration-文本上的线"><a href="#text-decoration-文本上的线" class="headerlink" title="text-decoration 文本上的线"></a>text-decoration 文本上的线</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-decoration</span><span class="token punctuation">:</span>overline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>上面的线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-decoration</span><span class="token punctuation">:</span>line-through<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>删除线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-decoration</span><span class="token punctuation">:</span>underline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>底下的线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-decoration</span><span class="token punctuation">:</span>underline overline dotted blue<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>蓝色上下虚线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-decoration</span><span class="token punctuation">:</span>underline wavy red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>红色波浪形下划线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://ep4l.com<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-decoration</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>超链接去线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div>    <p style="text-decoration:overline;">上面的线</p>    <p style="text-decoration:line-through;">删除线</p>    <p style="text-decoration:underline;">底下的线</p>    <p style="text-decoration:underline overline dotted blue;">蓝色上下虚线</p>    <p style="text-decoration:underline wavy red;">红色波浪形下划线</p>    <a href="https://ep4l.com" style="text-decoration:none;">超链接去线</a></div><h4 id="text-transform-大小写转换"><a href="#text-transform-大小写转换" class="headerlink" title="text-transform 大小写转换"></a>text-transform 大小写转换</h4><p>可以转变文本的大小写</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-transform</span><span class="token punctuation">:</span>uppercase<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-transform</span><span class="token punctuation">:</span>lowercase<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-transform</span><span class="token punctuation">:</span>capitalize<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p style="text-transform:uppercase;">This is some text.</p><p style="text-transform:lowercase;">This is some text.</p><p style="text-transform:capitalize;">This is some text.</p><h4 id="text-indent-首行缩进"><a href="#text-indent-首行缩进" class="headerlink" title="text-indent 首行缩进"></a>text-indent 首行缩进</h4><p>文本缩进属性是用来指定文本的第一行的缩进。</p><p><code>&lt;p style="text-indent:50px;"&gt;balabala&lt;/p&gt;</code></p><p style="text-indent:50px;">车位费幕后成为覅海外仓粉煤灰IC我没法hi欧吃完饭后IC我为此欧辰我IEhi从未hi出没无常我覅欧美汇慈文传媒是服务器从IC我粗黑触怒万能充我拿出WiFi从未in哦</p><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><h5 id="letter-spacing-字符之间的空间："><a href="#letter-spacing-字符之间的空间：" class="headerlink" title="letter-spacing 字符之间的空间："></a>letter-spacing 字符之间的空间：</h5><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">letter-spacing</span><span class="token punctuation">:</span>2px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">letter-spacing</span><span class="token punctuation">:</span>-3px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p style="letter-spacing:2px;">This is some text.</p><p style="letter-spacing:-3px;">This is some text.</p><h5 id="line-height-行与行之间的空间："><a href="#line-height-行与行之间的空间：" class="headerlink" title="line-height 行与行之间的空间："></a>line-height 行与行之间的空间：</h5><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">line-height</span><span class="token punctuation">:</span>70%<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">line-height</span><span class="token punctuation">:</span>200%<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p style="line-height:70%;">    This is some text.<br>    This is some text.<br></p><p style="line-height:200%;">    This is some text.<br>    This is some text.<br></p><h5 id="word-spacing-单词之间的空间："><a href="#word-spacing-单词之间的空间：" class="headerlink" title="word-spacing 单词之间的空间："></a>word-spacing 单词之间的空间：</h5><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">word-spacing</span><span class="token punctuation">:</span>30px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    This is some text. This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p style="word-spacing:30px;">This is some text. This is some text.</p><h5 id="text-shadow-文本阴影："><a href="#text-shadow-文本阴影：" class="headerlink" title="text-shadow 文本阴影："></a>text-shadow 文本阴影：</h5><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>white<span class="token punctuation">;</span><span class="token property">text-shadow</span><span class="token punctuation">:</span>2px 2px 4px #000000<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    This is some text. This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p style="color:white;text-shadow:2px 2px 4px #000000;">This is some text. This is some text.</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-shadow</span><span class="token punctuation">:</span>2px 2px blue<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-shadow:2px 2px blue;">This is some text.</p><h3 id="CSS-fonts-字体"><a href="#CSS-fonts-字体" class="headerlink" title="CSS fonts(字体)"></a>CSS fonts(字体)</h3><ul><li>font-family </li><li>font-style</li><li>font-size </li><li>font-weight</li><li>font-variant</li><li>font</li></ul><p>CSS字体属性定义字体，加粗，大小，文字样式。</p><h4 id="font-family-字体"><a href="#font-family-字体" class="headerlink" title="font-family  字体"></a>font-family  字体</h4><p>font-family 属性设置文本的字体系列。<br>font-family 属性应该设置几个字体名称作为一种”后备”机制，如果浏览器不支持第一种字体，他将尝试下一种字体。</p><p><code>p{font-family:"Times New Roman", Times, serif;}</code></p><p><a href="https://www.runoob.com/cssref/css-websafe-fonts.html">常用的安全字体组合</a></p><h4 id="font-style-字体样式"><a href="#font-style-字体样式" class="headerlink" title="font-style 字体样式"></a>font-style 字体样式</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-style</span><span class="token punctuation">:</span>normal<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是一个段落,正常。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-style</span><span class="token punctuation">:</span>italic<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是一个段落,斜体。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-style</span><span class="token punctuation">:</span>oblique<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是一个段落,斜体。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p style="font-style:normal;">这是一个段落,正常。</p><p style="font-style:italic;">这是一个段落,斜体。</p><p style="font-style:oblique;">这是一个段落,斜体。</p><h4 id="font-size-字体大小"><a href="#font-size-字体大小" class="headerlink" title="font-size 字体大小"></a>font-size 字体大小</h4><p>能否管理文字的大小，在网页设计中是非常重要的。但是，你不能通过调整字体大小使段落看上去像标题，或者使标题看上去像段落。<br>请务必使用正确的HTML标签，就h1 - h6表示标题和p表示段落：<br>字体大小的值可以是绝对或相对的大小。<br>如果你不指定一个字体的大小，默认大小和普通文本段落一样，是16像素（16px=1em）。</p><h5 id="用em来设置字体大小"><a href="#用em来设置字体大小" class="headerlink" title="用em来设置字体大小"></a>用em来设置字体大小</h5><p>1em和当前字体大小相等。在浏览器中默认的文字大小是16px。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span>2.5em<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span> /* 40px/16=2.5em */<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span>0.875em<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>This is some text.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span> /* 14px/16=0.875em */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p style="font-size:2.5em;">This is some text.</p> <p style="font-size:0.875em;">This is some text.</p> <h5 id="使用百分比和EM组合"><a href="#使用百分比和EM组合" class="headerlink" title="使用百分比和EM组合"></a>使用百分比和EM组合</h5><p>在所有浏览器的解决方案中，设置 body元素的默认字体大小的是百分比：</p><p><code>body {font-size:100%;}</code></p><p>在所有浏览器中，可以显示相同的文本大小，并允许所有浏览器缩放文本的大小。</p><h4 id="其他属性-1"><a href="#其他属性-1" class="headerlink" title="其他属性"></a>其他属性</h4><ul><li>font-weight: bold;                                              设置粗体</li><li>font-variant: small-caps;                                   设置小号的大写</li><li>font: italic bold 12px/30px Georgia,serif;       简写</li></ul><h3 id="CSS-链接状态选择器"><a href="#CSS-链接状态选择器" class="headerlink" title="CSS 链接状态选择器"></a>CSS 链接状态选择器</h3><p>链接的样式，可以用任何CSS属性（如颜色，字体，背景等）。</p><p>特别的链接，可以有不同的样式，这取决于他们是什么状态。</p><p>这四个链接状态是：</p><ul><li>a:link - 正常，未访问过的链接</li><li>a:visited - 用户已访问过的链接</li><li>a:hover - 当用户鼠标放在链接上时</li><li>a:active - 链接被点击的那一刻</li></ul><p>当设置为若干链路状态的样式，也有一些顺序规则：</p><ul><li>a:hover 必须跟在 a:link 和 a:visited后面</li><li>a:active 必须跟在 a:hover后面</li></ul><iframe src="https://www.runoob.com/try/try.php?filename=trycss_link2" width="100%" height="600"></iframe><p>这些状态写入内联样式好像需要js</p><h3 id="CSS-列表项标记"><a href="#CSS-列表项标记" class="headerlink" title="CSS 列表项标记"></a>CSS 列表项标记</h3><ul><li>list-style-type</li></ul><p>用来设置列表项标记</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">list-style-type</span><span class="token punctuation">:</span>circle<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>这是<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>圈圈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">list-style-type</span><span class="token punctuation">:</span>square<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>这是<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>方块<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">list-style-type</span><span class="token punctuation">:</span>upper-roman<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>这是<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>大写罗马字母<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">list-style-type</span><span class="token punctuation">:</span>lower-alpha<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>这是<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>小写字母<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">list-style-image</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">'https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/favicon-16x16.png'</span><span class="token punctuation">)</span></span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>这是<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul style="list-style-type:circle;">  <li>这是</li>  <li>圈圈</li></ul><ul style="list-style-type:square;">  <li>这是</li>  <li>方块</li></ul><ol style="list-style-type:upper-roman;">  <li>这是</li>  <li>大写罗马字母</li></ol><ol style="list-style-type:lower-alpha;">  <li>这是</li>  <li>小写字母</li></ol><ul style="list-style-image:url('https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/favicon-16x16.png');">    <li>这是</li>    <li>图片</li></ul><h3 id="CSS-table-表格"><a href="#CSS-table-表格" class="headerlink" title="CSS table(表格)"></a>CSS table(表格)</h3><ul><li>border</li><li>border-collapse</li><li>border-spacing</li><li>text-align / vertical-align</li><li>padding</li><li>background-color / color</li></ul><h4 id="border-表格边框"><a href="#border-表格边框" class="headerlink" title="border 表格边框"></a>border 表格边框</h4><p>对table/th/td使用</p><p><code>border: 1px solid black;</code></p><h4 id="border-collapse-折叠边框"><a href="#border-collapse-折叠边框" class="headerlink" title="border-collapse 折叠边框"></a>border-collapse 折叠边框</h4><p>对table使用</p><p>设置表格的边框是否被折叠成一个单一的边框或隔开</p><p><code>border-collapse:collapse;</code></p><h4 id="border-spacing-边框间距（仅用于”边框分离”模式）"><a href="#border-spacing-边框间距（仅用于”边框分离”模式）" class="headerlink" title="border-spacing 边框间距（仅用于”边框分离”模式）"></a>border-spacing 边框间距（仅用于”边框分离”模式）</h4><p>对table使用</p><p><code>border-collapse:separate;</code></p><p><code>border-spacing:10px 50px;</code></p><h4 id="表格文字对齐"><a href="#表格文字对齐" class="headerlink" title="表格文字对齐"></a>表格文字对齐</h4><p><code>text-align:right;</code>去</p><p><code>vertical-align:bottom;</code></p><h4 id="padding-填充属性"><a href="#padding-填充属性" class="headerlink" title="padding 填充属性"></a>padding 填充属性</h4><p>对table/th/td使用，可以写4个值</p><p><code>padding:15px;</code></p><h4 id="表格颜色"><a href="#表格颜色" class="headerlink" title="表格颜色"></a>表格颜色</h4><p>对table/th/td使用</p><p><code>background-color:green;</code></p><p><code>color:white;</code></p><h3 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a>CSS 盒子模型</h3><p>所有HTML元素可以看作盒子。<br>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。<br>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。<br>下面的图片说明了盒子模型(Box Model)：</p><ul><li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li><li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。</li><li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li><li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li></ul><p><img src="https://www.runoob.com/images/box-model.gif" alt=""></p><div style="    background-color: lightgrey;    width: 300px;    border: 25px solid green;    padding: 25px;    margin: 25px;">这里是盒子内的实际内容。有 25px 内间距，25px 外间距、25px 绿色边框。</div><h4 id="元素的宽度和高度"><a href="#元素的宽度和高度" class="headerlink" title="元素的宽度和高度"></a>元素的宽度和高度</h4><p><strong>重要:</strong> 当您指定一个 CSS 元素的宽度和高度属性时，你只是设置内容区域的宽度和高度。要知道，完整大小的元素，你还必须添加内边距，边框和边距。</p><h3 id="CSS-Border-边框"><a href="#CSS-Border-边框" class="headerlink" title="CSS Border(边框)"></a>CSS Border(边框)</h3><p>CSS边框属性允许你指定一个元素边框的样式和颜色。</p><ul><li>border-style</li><li>border-width</li><li>border-color</li><li>各边分别设置</li><li>border</li></ul><h4 id="border-style-边框样式"><a href="#border-style-边框样式" class="headerlink" title="border-style 边框样式"></a>border-style 边框样式</h4><div>    <p style="border-style:none">none:无边框。</p>    <p style="border-style:dotted">dotted:虚线边框。</p>    <p style="border-style:dashed">dashed:虚线边框。</p>    <p style="border-style:solid">solid:实线边框。</p>    <p style="border-style:double">double:双边框。</p>    <p style="border-style:groove"> groove:凹槽边框。</p>    <p style="border-style:ridge">ridge:脊状边框。</p>    <p style="border-style:inset">inset：嵌入边框。</p>    <p style="border-style:outset">outset：外凸边框。</p>    <p style="border-style:hidden">hidden：隐藏边框。</p></div><h4 id="border-width-边框宽度"><a href="#border-width-边框宽度" class="headerlink" title="border-width 边框宽度"></a>border-width 边框宽度</h4><p>为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em(单位为 px, pt, cm, em 等)，或者使用 3 个关键字之一，它们分别是 thick 、medium（默认值） 和 thin。</p><p><strong>注意：</strong>CSS 没有定义 3 个关键字的具体宽度，所以一个用户可能把 <strong>thick</strong> 、<strong>medium</strong> 和 <strong>thin</strong> 分别设置为等于 5px、3px 和 2px，而另一个用户则分别设置为 3px、2px 和 1px。</p><p><strong>注意:</strong> “border-width” 属性 如果单独使用则不起作用。要先使用 “border-style” 属性来设置边框。</p><div>    <p style="border-style:solid;border-width:thick"> thick</p>    <p style="border-style:solid;border-width:medium"> medium</p>    <p style="border-style:solid;border-width:thin"> thin</p></div><h4 id="border-color-边框颜色"><a href="#border-color-边框颜色" class="headerlink" title="border-color 边框颜色"></a>border-color 边框颜色</h4><p><strong>注意：</strong> border-color单独使用是不起作用的，必须得先使用border-style来设置边框样式。</p><div>    <p style="border-style:solid;border-color:red;">实线红色边框</p>    <p style="border-style:solid;border-color:#98bf21;">实线绿色边框</p></div><h4 id="单独设置各边"><a href="#单独设置各边" class="headerlink" title="单独设置各边"></a>单独设置各边</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value">    <span class="token property">border-top-style</span><span class="token punctuation">:</span>dotted<span class="token punctuation">;</span></span><span class="token attr-value"><span class="token property">border-right-style</span><span class="token punctuation">:</span>solid<span class="token punctuation">;</span></span><span class="token attr-value"><span class="token property">border-bottom-style</span><span class="token punctuation">:</span>dotted<span class="token punctuation">;</span></span><span class="token attr-value"><span class="token property">border-left-style</span><span class="token punctuation">:</span>solid<span class="token punctuation">;</span></span><span class="token attr-value">    <span class="token property">border-left-width</span><span class="token punctuation">:</span>15px<span class="token punctuation">;</span></span><span class="token attr-value">    <span class="token property">border-color</span><span class="token punctuation">:</span>#ff0000 #00ff00 #0000ff <span class="token function">rgb</span><span class="token punctuation">(</span>250<span class="token punctuation">,</span>0<span class="token punctuation">,</span>255<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>两个不同的边界样式。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div>    <p style="    border-top-style:dotted;    border-right-style:solid;    border-bottom-style:dotted;    border-left-style:solid;    border-left-width:15px;    border-color:#ff0000 #00ff00 #0000ff rgb(250,0,255);">两个不同的边界样式。</p></div><p>上面的例子也可以设置一个单一属性：</p><p><code>&lt;p style="border-style:dotted solid;"&gt;两个不同的边界样式。&lt;/p&gt;</code></p><p style="border-style:dotted solid;">两个不同的边界样式。</p><p>border-style属性可以有1-4个值：</p><ul><li>4个值的顺序：上、右、下、左</li><li>3个值的顺序：上、左右、下</li><li>2个值的顺序：上下、左右</li></ul><h4 id="border-简写属性"><a href="#border-简写属性" class="headerlink" title="border 简写属性"></a>border 简写属性</h4><p><code>&lt;p style="border:5px solid red;"&gt;简写&lt;/p&gt;</code></p><p style="border:5px solid red;">简写</p><p><code>&lt;p style="border-style:solid;border-top:thick double #ff0000;"&gt;简写&lt;/p&gt;</code></p><p style="border-style:solid;border-top:thick double #ff0000;">简写</p><h4 id="其他属性-2"><a href="#其他属性-2" class="headerlink" title="其他属性"></a>其他属性</h4><p><code>&lt;p style="border:1px solid; border-radius:16px; padding:5px"&gt;圆角边框&lt;/p&gt;</code></p><p style="border:1px solid; border-radius:16px; padding:5px">圆角边框</p><p><code>&lt;p style="background-color:#ddffff; padding:10px;border-left:6px solid #2196F3"&gt;背景和左边框配合&lt;/p&gt;</code></p><p style="background-color:#ddffff; padding:10px;border-left:6px solid #2196F3">背景和左边框配合</p><h3 id="CSS-outline-轮廓"><a href="#CSS-outline-轮廓" class="headerlink" title="CSS outline(轮廓)"></a>CSS outline(轮廓)</h3><p>轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</p><p>轮廓（outline）属性指定元素轮廓的样式、颜色和宽度。</p><p>轮廓设置方法和边框相同，把border改为outline即可</p><p><img src="https://www.runoob.com/images/box_outline.gif" alt=""></p><p><code>&lt;p style="border:10px red solid;outline:25px blue dotted;"&gt;这是边框和轮廓&lt;/p&gt;</code></p><p>这是上面的字</p><p style="border:10px red solid;outline:25px blue dotted; ">这是边框和轮廓</p><p>这是下面的字</p><p>可以看见，outline是不占空间的，即不会增加额外的width或者height或者margin。</p><h3 id="CSS-margin-外边距"><a href="#CSS-margin-外边距" class="headerlink" title="CSS margin(外边距)"></a>CSS margin(外边距)</h3><p>margin 可以单独改变元素的上，下，左，右边距，也可以一次改变所有的属性。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/08/VlwVi.png" alt=""></p><h4 id="可能的值"><a href="#可能的值" class="headerlink" title="可能的值"></a>可能的值</h4><div class="table-container"><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">auto</td><td style="text-align:left">设置浏览器边距。 这样做的结果会依赖于浏览器</td></tr><tr><td style="text-align:left"><em>length</em></td><td style="text-align:left">定义一个固定的margin（使用像素，pt，em等）</td></tr><tr><td style="text-align:left"><em>%</em></td><td style="text-align:left">定义一个使用百分比的边距</td></tr></tbody></table></div><h3 id="CSS-padding-填充"><a href="#CSS-padding-填充" class="headerlink" title="CSS padding(填充)"></a>CSS padding(填充)</h3><p>CSS padding（填充）是一个简写属性，定义元素边框与元素内容之间的空间，即上下左右的内边距。</p><h4 id="可能的值-1"><a href="#可能的值-1" class="headerlink" title="可能的值"></a>可能的值</h4><div class="table-container"><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><em>length</em></td><td style="text-align:left">定义一个固定的填充(像素, pt, em,等)</td></tr><tr><td style="text-align:left"><em>%</em></td><td style="text-align:left">使用百分比值定义一个填充</td></tr></tbody></table></div><h3 id="CSS-分组-和-嵌套-选择器"><a href="#CSS-分组-和-嵌套-选择器" class="headerlink" title="CSS 分组 和 嵌套 选择器"></a>CSS 分组 和 嵌套 选择器</h3><h4 id="分组选择器"><a href="#分组选择器" class="headerlink" title="分组选择器"></a>分组选择器</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">h1,h2,p</span>     <span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span>green<span class="token punctuation">;</span>     <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="嵌套选择器"><a href="#嵌套选择器" class="headerlink" title="嵌套选择器"></a>嵌套选择器</h4><p>它可能适用于选择器内部的选择器的样式。</p><p>在下面的例子设置了三个样式：</p><ul><li><strong>p{ }</strong>: 为所有 <strong>p</strong> 元素指定一个样式。</li><li><strong>.marked{ }</strong>: 为所有 <strong>class=”marked”</strong> 的元素指定一个样式。</li><li><strong>.marked p{ }</strong>: 为所有 <strong>class=”marked”</strong> 元素内的 <strong>p</strong> 元素指定一个样式。</li><li><strong>p.marked{ }</strong>: 为所有 <strong>class=”marked”</strong> 的 <strong>p</strong> 元素指定一个样式。</li></ul><h3 id="CSS-尺寸-Dimension"><a href="#CSS-尺寸-Dimension" class="headerlink" title="CSS 尺寸 (Dimension)"></a>CSS 尺寸 (Dimension)</h3><p>CSS 尺寸 (Dimension) 属性允许你控制元素的高度和宽度。同样，它允许你增加行间距。</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-height.html">height</a></td><td style="text-align:left">设置元素的高度。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-line-height.html">line-height</a></td><td style="text-align:left">设置行高。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-max-height.html">max-height</a></td><td style="text-align:left">设置元素的最大高度。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-max-width.html">max-width</a></td><td style="text-align:left">设置元素的最大宽度。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-min-height.html">min-height</a></td><td style="text-align:left">设置元素的最小高度。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-min-width.html">min-width</a></td><td style="text-align:left">设置元素的最小宽度。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cssref/pr-dim-width.html">width</a></td><td style="text-align:left">设置元素的宽度。</td></tr></tbody></table></div><h3 id="CSS-Display-显示-与-Visibility（可见性）"><a href="#CSS-Display-显示-与-Visibility（可见性）" class="headerlink" title="CSS Display(显示) 与 Visibility（可见性）"></a>CSS Display(显示) 与 Visibility（可见性）</h3><ul><li>visibility</li><li>display</li></ul><h4 id="隐藏元素-display-none或visibility-hidden"><a href="#隐藏元素-display-none或visibility-hidden" class="headerlink" title="隐藏元素 - display:none或visibility:hidden"></a>隐藏元素 - display:none或visibility:hidden</h4><p>visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。</p><p>display:none可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。</p><h4 id="CSS-Display-块和内联元素"><a href="#CSS-Display-块和内联元素" class="headerlink" title="CSS Display - 块和内联元素"></a>CSS Display - 块和内联元素</h4><p><strong>块元素</strong>是一个元素，占用了全部宽度，在前后都是换行符。</p><p>块元素的例子：</p><ul><li>h1</li><li>p</li><li>div</li></ul><p><strong>内联元素</strong>只需要必要的宽度，不强制换行。</p><p>内联元素的例子：</p><ul><li>span</li><li>a</li></ul><h4 id="如何改变一个元素显示"><a href="#如何改变一个元素显示" class="headerlink" title="如何改变一个元素显示"></a>如何改变一个元素显示</h4><p>可以更改内联元素和块元素的显示，反之亦然</p><p><strong>注意：</strong>变更元素的显示类型看该元素是如何显示，不改变它是什么样的元素。例如：一个内联元素设置为display:block不允许有它内部的嵌套块元素。</p><p>下面的示例把列表项显示为内联元素：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>red</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>inline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>列表项1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>inline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>列表项2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>inline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>列表项3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>inline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>列表项4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul style="color:red">    <li style="display:inline;">列表项1</li>    <li style="display:inline;">列表项2</li>    <li style="display:inline;">列表项3</li>    <li style="display:inline;">列表项4</li></ul><p>下面的示例把span元素作为块元素：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>red</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>span1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>span2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>span3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>span4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div style="color:red">    <span style="display:block;">span1</span>    <span style="display:block;">span2</span>    <span style="display:block;">span3</span>    <span style="display:block;">span4</span></div><h3 id="CSS-Position-定位"><a href="#CSS-Position-定位" class="headerlink" title="CSS Position(定位)"></a>CSS Position(定位)</h3><p>position 属性指定了元素的定位类型。</p><p>position 属性的五个值：</p><ul><li>static</li><li>relative</li><li>fixed</li><li>absolute</li><li>sticky</li></ul><p>设立position属性后，元素可以使用顶部，底部，左侧和右侧属性定位。</p><h4 id="static-默认"><a href="#static-默认" class="headerlink" title="static 默认"></a>static 默认</h4><p>HTML 元素的默认值，即没有定位，遵循正常的文档流对象。</p><p>静态定位的元素不会受到 top, bottom, left, right影响。</p><h4 id="fixed-不随窗口滚动"><a href="#fixed-不随窗口滚动" class="headerlink" title="fixed 不随窗口滚动"></a>fixed 不随窗口滚动</h4><p><strong>不占据空间</strong></p><p>元素的位置相对于浏览器窗口是固定位置。</p><p>即使窗口是滚动的它也不会移动</p><h4 id="relative-相对位置"><a href="#relative-相对位置" class="headerlink" title="relative 相对位置"></a>relative 相对位置</h4><p>相对定位元素的定位是相对其正常位置。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>red</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">position</span><span class="token punctuation">:</span>relative<span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span>-20px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>对于其正常位置向左移动<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>正常位置<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">position</span><span class="token punctuation">:</span>relative<span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>相对于其正常位置向右移动<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><div style="color:red">    <p style="position:relative;left:-20px;">对于其正常位置向左移动</p><p>    </p><p>正常位置</p><p>    </p><p style="position:relative;left:20px;">相对于其正常位置向右移动</p><p></p></div><p>移动相对定位元素，但它原本所占的空间不会改变，可能对覆盖其他元素的显示。</p><h4 id="absolute-绝对位置"><a href="#absolute-绝对位置" class="headerlink" title="absolute 绝对位置"></a>absolute 绝对位置</h4><p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于html。</p><p>absolute 定位<strong>不占据空间</strong>，因此absolute 定位的元素和其他显示重叠。</p><p><strong>clip 属性</strong>可以剪裁绝对定位元素。</p><h4 id="sticky-基于用户的滚动位置来定位"><a href="#sticky-基于用户的滚动位置来定位" class="headerlink" title="sticky  基于用户的滚动位置来定位"></a>sticky  基于用户的滚动位置来定位</h4><p>粘性定位的元素是依赖于用户的滚动，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换。</p><p>它的行为就像 <strong>position:relative;</strong> 而当页面滚动超出目标区域时，它的表现就像 <strong>position:fixed;</strong>，它会固定在目标位置。</p><p>这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p><iframe src="https://www.runoob.com/try/try.php?filename=trycss_position_sticky" width="100%" height="600"></iframe><h4 id="重叠的元素"><a href="#重叠的元素" class="headerlink" title="重叠的元素"></a>重叠的元素</h4><p>元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素</p><p>z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面）</p><p>具有更高堆叠顺序的元素总是在较低的堆叠顺序元素的前面。</p><p>一个元素可以有正数或负数的堆叠顺序：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span><span class="token property">z-index</span><span class="token punctuation">:</span>-1<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>因为图像元素设置了 z-index 属性值为 -1, 所以它会显示在文字之后。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> 如果两个定位元素重叠，没有指定z - index，最后定位在HTML代码中的元素将被显示在最前面</p><h3 id="CSS-Overflow-内容溢出的显示方式"><a href="#CSS-Overflow-内容溢出的显示方式" class="headerlink" title="CSS Overflow (内容溢出的显示方式)"></a>CSS Overflow (内容溢出的显示方式)</h3><p>CSS overflow 属性可以控制内容溢出元素框时在对应的元素区间内添加滚动条。</p><p>默认情况下，overflow 的值为 visible， 意思是内容溢出元素框：</p><p>overflow属性有以下值：</p><div class="table-container"><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">visible</td><td style="text-align:left">默认值。内容不会被修剪，会呈现在元素框之外。</td></tr><tr><td style="text-align:left">hidden</td><td style="text-align:left">内容会被修剪，并且其余内容是不可见的。</td></tr><tr><td style="text-align:left">scroll</td><td style="text-align:left">内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。(两个滚动条都出现)</td></tr><tr><td style="text-align:left">auto</td><td style="text-align:left">如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</td></tr><tr><td style="text-align:left">inherit</td><td style="text-align:left">规定应该从父元素继承 overflow 属性的值。</td></tr></tbody></table></div><p><strong>注意:</strong>overflow 属性只工作于指定高度的块元素上。</p><h3 id="CSS-Float-浮动"><a href="#CSS-Float-浮动" class="headerlink" title="CSS Float(浮动)"></a>CSS Float(浮动)</h3><p>CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。</p><p>Float（浮动），往往是用于图像，但它在布局时一样非常有用。</p><p>元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。</p><p>一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</p><p>浮动元素之后的元素将围绕它。</p><p>浮动元素之前的元素将不会受到影响。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">float</span><span class="token punctuation">:</span>right</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    这是一些文本。这是一些文本。这是一些文本。    ......    这是一些文本。这是一些文本。这是一些文本。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="margin:0px;float:right">    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。    这是一些文本。这是一些文本。这是一些文本。</p><h4 id="彼此相邻的浮动元素"><a href="#彼此相邻的浮动元素" class="headerlink" title="彼此相邻的浮动元素"></a>彼此相邻的浮动元素</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">float</span><span class="token punctuation">:</span>left</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    ......    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">float</span><span class="token punctuation">:</span>left</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left">    <img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/medias/logo.png" width="100" style="float:left"></p><p style="clear:both;"></p><p></p><h4 id="清除浮动-使用-clear"><a href="#清除浮动-使用-clear" class="headerlink" title="清除浮动 - 使用 clear"></a>清除浮动 - 使用 clear</h4><p>元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。</p><div class="table-container"><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">left</td><td style="text-align:left">在左侧不允许浮动元素。</td></tr><tr><td style="text-align:left">right</td><td style="text-align:left">在右侧不允许浮动元素。</td></tr><tr><td style="text-align:left">both</td><td style="text-align:left">在左右两侧均不允许浮动元素。</td></tr></tbody></table></div><h4 id="让段落的第一个字母浮动到左侧"><a href="#让段落的第一个字母浮动到左侧" class="headerlink" title="让段落的第一个字母浮动到左侧"></a>让段落的第一个字母浮动到左侧</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">float</span><span class="token punctuation">:</span>left<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span>1.2em<span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span>400%<span class="token punctuation">;</span>font</span><span class="token attr-value">                 <span class="token property">family</span><span class="token punctuation">:</span>algerian<span class="token punctuation">,</span>courier<span class="token punctuation">;</span><span class="token property">line-height</span><span class="token punctuation">:</span>80%<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        这<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>是一些文本。    这是一些文本。这是一些文本。    ...    这是一些文本。这是一些文本。这是一些文本。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span style="float:left;width:1.2em;font-size:400%;font-family:algerian,courier;line-height:80%;">这</span>是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。这是一些文本。</p><h3 id="其他属性-3"><a href="#其他属性-3" class="headerlink" title="其他属性"></a>其他属性</h3><h4 id="cursor-更改光标"><a href="#cursor-更改光标" class="headerlink" title="cursor 更改光标"></a>cursor 更改光标</h4>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学速成课</title>
      <link href="2021/01/22/crash-course-computer-science/"/>
      <url>2021/01/22/crash-course-computer-science/</url>
      
        <content type="html"><![CDATA[<p>视频在<a href="https://www.bilibili.com/video/BV1EW411u7th">这里</a></p><h2 id="1-计算机早期历史"><a href="#1-计算机早期历史" class="headerlink" title="1.计算机早期历史"></a>1.计算机早期历史</h2><p>算盘 → 步进计算器（1694 第一个可以做加减乘除的机器）→ 差分机（1823 失败）分析机（设想）</p><h2 id="2-电子计算机"><a href="#2-电子计算机" class="headerlink" title="2.电子计算机"></a>2.电子计算机</h2><p>机械继电器（bug的起源）→ 真空管（1904 电子管）→ 晶体管（1947 半导体）</p><h2 id="3-布尔逻辑和逻辑门"><a href="#3-布尔逻辑和逻辑门" class="headerlink" title="3.布尔逻辑和逻辑门"></a>3.布尔逻辑和逻辑门</h2><p>二进制<br>布尔代数（not and or）的晶体管实现：非（接地）与（串联）或（并联）<br>XOR（异或）用上面的三种门组成</p><h2 id="4-二进制"><a href="#4-二进制" class="headerlink" title="4.二进制"></a>4.二进制</h2><p>二进制的原理及表示范围<br>字节（8bit）（用颜色举例，8bit有256种，现在用的32bit有4,294,967,295种）；<br>由于内存的增加，内存地址现在应该有64位<br>浮点数的表示，ASCII码，Unicode</p><h2 id="5-算术逻辑单元-ALU"><a href="#5-算术逻辑单元-ALU" class="headerlink" title="5.算术逻辑单元-ALU"></a>5.算术逻辑单元-ALU</h2><p>ALU有2个单元：1个算术单元和一个逻辑单元</p><p>算术单元：</p><ul><li>半加器：<br>sum：当前位的和<br>carry：进位</li></ul><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123023411810.png" alt="半加器"></p><ul><li>全加器：<br>由于有进位的存在，半加器输出了进位，下一位需要接收3个二进制位</li></ul><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123023902758.png" alt="全加器"></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123024147310.png" alt="8位行波进位加法器，现代实际使用超前进位加法器"></p><p>除了加减，类似计算机里也有专门做乘法的算术单元，电路比较复杂</p><p>逻辑单元：<br>执行逻辑操作，例如and，or，not和一些简单的数值测试（如测试输出是否为0）</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123025231997.png" alt="简单的ALU"></p><h2 id="6-寄存器和内存"><a href="#6-寄存器和内存" class="headerlink" title="6.寄存器和内存"></a>6.寄存器和内存</h2><p>用基本逻辑门可以做出存一位信息的叫”AND-OR锁存器”</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123025835832.png" alt="锁存器"></p><p>加亿点细节，用一根线来同时作用设置和复位，再加一根线用来做写入的开关</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123025922499.png" alt="门锁"></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123030158536.png" alt="门锁"></p><p>数个锁存器的组合叫<strong>寄存器</strong>，寄存器有多少位称为<strong>位宽</strong>，早期位宽为8，现在很多都是64<br>用1根线连接寄存器所有的允许输入线，用8条数据线发送数据，就可以给一个寄存器存入数据</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123030623292.png" alt="写寄存器"></p><p>有n个单元时，需要非常多(2n+1根)的线，可以改进成为矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123030954261.png" alt="门锁矩阵"></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123031155319.png" alt="放大"></p><p>对于256位的存储，只需要1条数据线，1条允许写入线，1条允许读取线，和16行16列的线，共35条即可</p><p>用8位可以表示这里的地址，12行8列的地址就是11001000，然后用两个多路复用器将8位的地址装换为行和列</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123031909074.png" alt="256位内存"></p><p>将8个内存连接起来，同一个地址可以存一个8位数字（1个字节），这里总共能存256个字节（byte）</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123031955194.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123032242052.png" alt="抽象成一块整体"></p><p>现在的64位计算机有64位的内存，但不论几位机，一个地址都是对应1Byte<br>内存的一个重要特征是：可以随时访问任何位置，因此叫”随机存取存储器（RAM）“</p><h2 id="7-中央处理器（CPU）"><a href="#7-中央处理器（CPU）" class="headerlink" title="7.中央处理器（CPU）"></a>7.中央处理器（CPU）</h2><p>先构建一个16个地址的内存和4个寄存器</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123033206319.png" alt=""></p><p>在内存里存储的数据前4位为操作码，后4位为地址或者寄存器</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123033336716.png" alt=""></p><p>我们还需要两个寄存器来完成CPU，一个叫指令地址寄存器，一个叫指令寄存器</p><p>取指令阶段：从地址寄存器存放的地址中取出指令 </p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123120300566.png" alt="取指令"></p><p>解码阶段：由控制单元（也是一堆逻辑门）进行解码</p><p>执行阶段：操作码0010：存放到寄存器a；地址码1110的值：00000011</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123121150970.png" alt="执行"></p><p>指令完成后，关闭所有电路，去拿下一条指令，指令地址寄存器+1，执行阶段结束<br>接下来再经过一个执行阶段，把一个值送进寄存器B，指令地址+1<br>接下来到了地址2，指令码是1000，把寄存器B的值加进A里，需要整合ALU来执行</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123123610284.png" alt=""></p><p>运算完之后output输出到control unit的临时存储寄存器，关闭ALU，把值写入寄存器A，A变为了00010001，指令地址再+1。</p><p>最后一个指令将寄存器A中的内存写入内存中</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/Crash-Course-Computer-Science/image-20210123125844934.png" alt=""></p><p>cpu工作的节奏由“时钟”来负责管理，CPU”取指令→解码→执行“的速度叫”<strong>时钟速度</strong>“，单位是赫兹<br>cpu可以超频也可以降频</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Crash-Course-Computer-Science/image-20210123230724705.png" alt="CPU"></p><h2 id="8-指令与程序"><a href="#8-指令与程序" class="headerlink" title="8.指令与程序"></a>8.指令与程序</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编</title>
      <link href="2021/01/20/assembly/"/>
      <url>2021/01/20/assembly/</url>
      
        <content type="html"><![CDATA[<p><span style="color: #c31887;">受益匪浅，对cpu指令的执行，显存的运行过程，操作系统对程序的控制和运行，内存定位/寻址，递归/函数栈/子程序等等有了进一步的了解。</span></p><p><span style="color: #c31887;">本书的课后检测点和实验很重要，日后需要用的时候应重点复习</span></p><p><span style="color: #c31887;">重点：第九章，第十章</span></p><p><span style="color: #c31887;">2021/4/19 暂停更新，有时间再看，10-12章均有未完成的部分</span></p><p>使用的教材：汇编语言（第3版）王爽</p><center><span style="color:blue;font-size:15px">2021/1/20</span></center><h2 id="第1章-基础知识"><a href="#第1章-基础知识" class="headerlink" title="第1章 基础知识"></a>第1章 基础知识</h2><p>汇编语言是直接在硬件之上工作的编程语言，需要有一定知识，但是在汇编课程中我们部队硬件系统进行全面和深入的研究，汇编课程的研究重点放在如何利用硬件系统的编程结构和指令集有效灵活地控制系统进行工作。</p><h3 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h3><p>机器语言是机器指令的集合，电子计算机的机器指令是一列二进制数字，每一种微处理器都有自己的机器指令集，也就是机器语言。</p><h3 id="1-2-汇编语言的产生"><a href="#1-2-汇编语言的产生" class="headerlink" title="1.2 汇编语言的产生"></a>1.2 汇编语言的产生</h3><p>汇编语言的主体是汇编指令，汇编指令是机器指令便于记忆的书写格式。</p><h3 id="1-3-汇编语言的组成"><a href="#1-3-汇编语言的组成" class="headerlink" title="1.3 汇编语言的组成"></a>1.3 汇编语言的组成</h3><p>（1）汇编指令：机器码的助记符，有相应的机器码。</p><p>（2）伪指令：没有对应的机器码，由编译器执行，计算机并不执行。</p><p>（3）其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。</p><p>汇编语言的核心是汇编指令，它决定了汇编语言的特性。</p><h3 id="1-4-存储器"><a href="#1-4-存储器" class="headerlink" title="1.4 存储器"></a>1.4 存储器</h3><p>指令和数据在存储器中存放，也就是我们平时所说的内存。</p><h3 id="1-5-指令和数据"><a href="#1-5-指令和数据" class="headerlink" title="1.5 指令和数据"></a>1.5 指令和数据</h3><p>指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二讲制信息。CPU在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。</p><h3 id="1-6-存储单元"><a href="#1-6-存储单元" class="headerlink" title="1.6 存储单元"></a>1.6 存储单元</h3><p>微型机存储器的存储单元可以存储一个Byte，即8个二进制位。</p><h3 id="1-7-CPU对存储器的读写"><a href="#1-7-CPU对存储器的读写" class="headerlink" title="1.7 CPU对存储器的读写"></a>1.7 CPU对存储器的读写</h3><p>CPU要想进行数据的读写，必须和外部器件(标准的说法是芯片)进行下面3类信息的交互。</p><ul><li>存储单元的地址(地址信息)；</li><li>器件的选择，读或写的命令(控制信息)；</li><li>读或写的数据(数据信息)。</li></ul><p>在计算机中专门有连接CPU和其他芯片的导线，通常称为总线。总线从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为3类，<strong>地址总线</strong>、<strong>控制总线</strong>和<strong>数据总线</strong>。</p><p>CPU从3号单元中读取数据的过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210120230352328.png" alt=""></p><p>（1）CPU 通过地址线将地址信息3发出。<br>（2）CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。<br>（3）存储器将3号单元中的数据8通过数据线送入CPU。</p><h3 id="1-8-地址总线"><a href="#1-8-地址总线" class="headerlink" title="1.8 地址总线"></a>1.8 地址总线</h3><p>一个CPU有N跟地址总线，则可以说这个CPU的地址总线的宽度为N。这样的CPU最多可以寻找2的N次方个内存单元。</p><h3 id="1-9-数据总线"><a href="#1-9-数据总线" class="headerlink" title="1.9 数据总线"></a>1.9 数据总线</h3><p>数据总线的宽度决定了CPU和外界的数据传送速度。8 根数据总线一次可传送一个8位二进制数据(即一个字节)。16 根数据总线一次可传送两个字节。</p><h3 id="1-10-控制总线"><a href="#1-10-控制总线" class="headerlink" title="1.10 控制总线"></a>1.10 控制总线</h3><p>CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。<br>前面所讲的内存读或写命令是由几根控制线综合发出的，其中有一根称为 “读信号输出”的控制线负贵由CPU向外传送读信号，CPU向该控制线上输出低电平表示将要读取数据；有一根称为“写信号输出”的控制线则负责传送写信号。</p><h3 id="1-11-内存地址空间（概述）"><a href="#1-11-内存地址空间（概述）" class="headerlink" title="1.11 内存地址空间（概述）"></a>1.11 内存地址空间（概述）</h3><p>举例来讲，一个CPU的地址总线宽度为10，那么可以寻址1024个内存单元，这1024 个可寻到的内存单元就构成这个CPU的内存地址空间。下面进行深入讨论。首先需要介绍两部分基本知识，主板和接口卡。</p><h3 id="1-12-主板"><a href="#1-12-主板" class="headerlink" title="1.12 主板"></a>1.12 主板</h3><p>在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件，这些器件通过总线(地址总线、数据总线、控制总线)相连。这些器件有<strong>CPU</strong>、<strong>存储器</strong>、<strong>外围芯片组</strong>（北桥负责高速信号，比如CPU与内存、显卡等设备的通信。南桥负责低速信号，比如PCI/PCIe、SATA、USB等外围设备通信。再后来北桥芯片逐渐被集成到了CPU里面。<strong>芯片组的主要差别就是CPU对外围设备和拓展支持情况的差别</strong>）、扩展插槽等。扩展插槽上一般插有RAM内存条和各类接口卡。</p><h3 id="1-13-接口卡"><a href="#1-13-接口卡" class="headerlink" title="1.13 接口卡"></a>1.13 接口卡</h3><p>CPU对外部设备都不能直接控制，直接控制这些设备进行工作的是插在扩展插槽上的接口卡。<br>简单地讲，就是CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作。</p><h3 id="1-14-各类存储器芯片"><a href="#1-14-各类存储器芯片" class="headerlink" title="1.14 各类存储器芯片"></a>1.14 各类存储器芯片</h3><p>一台PC机中，装有多个存储器芯片，这些存储器芯片从物理连接上看是独立的、不同的器件。从读写属性上看分为两类：<strong>随机存储器</strong>(RAM)和<strong>只读存储器</strong>(ROM)。 随机存储器可读可写，但必须带电存储，关机后存储的内容丢失；只读存储器只能读取不能写入，关机后其中的内容不丢失。这些存储器从功能和连接上又可分为以下几类。</p><ul><li><p>随机存储器<br>用于存放供CPU使用的绝大部分程序和数据。</p></li><li><p>装有BIOS(Basic Input/Output System,基本输入/输出系统)的ROM<br>BIOS是由主板和各类接口卡(如显卡、网卡等)厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM。例如，主板上的ROM中存储着主板的BIOS(通常称为系统BIOS)；显卡上的ROM中存储着显卡的BIOS；如果网卡上装有ROM，那其中就可以存储网卡的BIOS。</p></li><li>接口卡上的RAM<br>某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有RAM。最典型的是显示卡上的RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210120235427070.png" alt=""></p><h3 id="1-15-内存地址空间"><a href="#1-15-内存地址空间" class="headerlink" title="1.15 内存地址空间"></a>1.15 内存地址空间</h3><p>上述的那些存储器，在物理上是独立的器件，但是在以下两点上相同。</p><ul><li>都和CPU的总线相连。</li><li>CPU对它们进行读或写的时候都通过控制线发出内存读写命令。</li></ul><p>这也就是说，CPU 在操控它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。在汇编这门课中，我们所面对的是内存地址空间。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210120235904993.png" alt=""></p><p>在图1.8中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</p><p>假设，图1.8中的内存地址空间的地址段分配如下。<br>地址0~7FFFH的32KB空间为主随机存储器的地址空间:<br>地址8000H~9FFFH的8KB空间为显存地址空间:<br>地址A000H~FFFFH的24KB空间为各个ROM的地址空间。</p><p>这样，CPU向内存地址为1000H的内存单元中写入数据，这个数据就被写入主随机存储器中；CPU向内存地址为8000H的内存单元中写入数据，这个数据就被写入显存中，然后会被显卡输出到显示器上；CPU向内存地址为C000H的内存单元中写入数据的操作是没有结果的，C000H 单元中的内容不会被改变，C000H 单元实际上就是ROM存储器中的一个单元。</p><p>内存地址空间的大小受CPU地址总线宽度的限制。80386CPU 的地址总线宽度为32，其内存地址空间最大为4GB。</p><p>我们在基于一个计算机硬件系统编程的时候，必须知道这个系统中的内存地址空间分配情况。不同的计算机系统的内存地址的分配情况是不同的。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/20200430191506580.png" alt="8086PC机内存地址空间"></p><center><span style="color:blue;font-size:15px">2021/1/23</span></center><h2 id="第2章-寄存器"><a href="#第2章-寄存器" class="headerlink" title="第2章 寄存器"></a>第2章 寄存器</h2><p>一个典型的CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。<br>对一个汇编程序员来说，CPU中的主要部件是寄存器。</p><h3 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h3><p>8086CPU的所以寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为<strong>通用寄存器</strong>。<br>为了向上一代的8位CPU寄存器兼容，这4个通用寄存器都可分为两个独立使用的8位寄存器来用。<br>例如：AX可分为AH（高8位）和AL（低8位）</p><h3 id="2-2-字在寄存器中的存储"><a href="#2-2-字在寄存器中的存储" class="headerlink" title="2.2 字在寄存器中的存储"></a>2.2 字在寄存器中的存储</h3><p>出于对兼容性的考虑，8086CPU可以一次性处理以下两种尺寸的数据</p><ul><li>字节：记为byte，由8个bit组成</li><li>字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节</li></ul><p>出于对数据直观分析的需要，我们多用十六进制来表示一个数据</p><h3 id="2-3-几条汇编指令"><a href="#2-3-几条汇编指令" class="headerlink" title="2.3 几条汇编指令"></a>2.3 几条汇编指令</h3><div class="table-container"><table><thead><tr><th style="text-align:center">程序段中的指令</th><th style="text-align:center">指令执行后AX中的数据</th><th style="text-align:center">指令执行后BX中的数据</th></tr></thead><tbody><tr><td style="text-align:center">mov ax,4E20H</td><td style="text-align:center">4E20H</td><td style="text-align:center">0000H</td></tr><tr><td style="text-align:center">add ax,106H</td><td style="text-align:center">6226H</td><td style="text-align:center">0000H</td></tr><tr><td style="text-align:center">mov bx,2000H</td><td style="text-align:center">6226H</td><td style="text-align:center">2000H</td></tr><tr><td style="text-align:center">add ax,bx</td><td style="text-align:center">8226H</td><td style="text-align:center">2000H</td></tr><tr><td style="text-align:center">mov bx,ax</td><td style="text-align:center">8226H</td><td style="text-align:center">8226H</td></tr><tr><td style="text-align:center">add ax,bx</td><td style="text-align:center"><strong>044CH</strong></td><td style="text-align:center">8226H</td></tr></tbody></table></div><p>最后一条指令所得的值应该为1044CH，但是ax寄存器放不下，最高位的1不能保存</p><div class="table-container"><table><thead><tr><th style="text-align:center">程序段中的指令</th><th style="text-align:center">指令执行后AX中的数据</th><th style="text-align:center">指令执行后BX中的数据</th></tr></thead><tbody><tr><td style="text-align:center">mov ax,001AH</td><td style="text-align:center">001AH</td><td style="text-align:center">0000H</td></tr><tr><td style="text-align:center">mov bx,0026H</td><td style="text-align:center">001AH</td><td style="text-align:center">0026H</td></tr><tr><td style="text-align:center">add al,bl</td><td style="text-align:center">0040H</td><td style="text-align:center">0026H</td></tr><tr><td style="text-align:center">add ah,bl</td><td style="text-align:center">2640H</td><td style="text-align:center">0026H</td></tr><tr><td style="text-align:center">add bh,al</td><td style="text-align:center">2640H</td><td style="text-align:center">4026H</td></tr><tr><td style="text-align:center">mov ah,0</td><td style="text-align:center">0040H</td><td style="text-align:center">4026H</td></tr><tr><td style="text-align:center">add al,85H</td><td style="text-align:center">00C5H</td><td style="text-align:center">4026H</td></tr><tr><td style="text-align:center">add al,93H</td><td style="text-align:center"><strong>0058H</strong></td><td style="text-align:center">4026H</td></tr></tbody></table></div><p>最后的ax应该为158H，但此时的al是作为一个独立的8位寄存器来使用的，和ah没有关系，所以最高位丢失</p><p>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。</p><h3 id="2-4-物理地址"><a href="#2-4-物理地址" class="headerlink" title="2.4 物理地址"></a>2.4 物理地址</h3><p>每个内存单元在存储空间内都有唯一的地址，称为物理地址。<br>在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU可以有不同的形成物理地址的方式。</p><h3 id="2-5-16位结构的CPU"><a href="#2-5-16位结构的CPU" class="headerlink" title="2.5 16位结构的CPU"></a>2.5 16位结构的CPU</h3><p>什么是16位结构的CPU呢？</p><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器之间的通路为16位</li></ul><p>内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，对于16位CPU，能一次性处理，传输、暂时存储16位的地址。</p><center><span style="color:blue;font-size:15px">2021/2/23</span></center><h3 id="2-6-8086CPU给出物理地址的方法"><a href="#2-6-8086CPU给出物理地址的方法" class="headerlink" title="2.6 8086CPU给出物理地址的方法"></a>2.6 8086CPU给出物理地址的方法</h3><p><strong>8086CPU有20位地址总线，可以传送20位地址</strong>，达到IMB寻址能力。<strong>8086CPU是16位结构</strong>，在内部一次性处理、 传输、暂时存储的地址为16 位。从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，<strong>表现出的寻址能力只有64KB。</strong><br>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址，</p><p>当8086CPU要读写内存时:<br>(1) CPU中的相关部件提供两个16位的地址，一个称为段地址，另个称为偏移地址:<br>(2) 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件;<br>(3) 地址加法器将两个16位地址合成为一个20位的物理地址;<br>(4) 地址加法器通过内部总线将20位物理地址送入输入输出控制电路:<br>(5) 输入输出控制电路将20位物理地址送上地址总线:<br>(6) 20位物理地址被地址总线传送到存储器。<br><strong>地址加法器采用物理地址=段地址x16+偏移地址的方法用段地址和偏移地址合成物理（段地址左移四位）</strong><br>地址。例如，8086CPU 要访问地址为123C8H的内存单元，此时，地址加法器的工作过程如图2.7所示(图中数据皆为十六进制表示)。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210223143146227.png" alt=""></p><h3 id="2-7-“段地址-16-偏移地址-物理地址”的本质含义"><a href="#2-7-“段地址-16-偏移地址-物理地址”的本质含义" class="headerlink" title="2.7 “段地址*16+偏移地址=物理地址”的本质含义"></a>2.7 “段地址*16+偏移地址=物理地址”的本质含义</h3><p>“段地址x16+偏移地址=物理地址”的本质含义是: CPU在访问内存时，用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</p><p>更一般地说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。8086CPU 中，段地址x16可看作是基础地址。</p><h3 id="2-8-段的概念（内存地址小结）"><a href="#2-8-段的概念（内存地址小结）" class="headerlink" title="2.8 段的概念（内存地址小结）"></a>2.8 段的概念（内存地址小结）</h3><p>（1）观察下面的地址</p><div class="table-container"><table><thead><tr><th style="text-align:center">物理地址</th><th style="text-align:center">段地址</th><th style="text-align:center">偏移地址</th></tr></thead><tbody><tr><td style="text-align:center">21F60H</td><td style="text-align:center">2000H</td><td style="text-align:center">1F60H</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">2100H</td><td style="text-align:center">0F60H</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">21F0H</td><td style="text-align:center">0060H</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">21F6H</td><td style="text-align:center">0000H</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1F00H</td><td style="text-align:center">2F60H</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table></div><p><strong>结论：</strong>CPU可以用不同的段地址和偏移地址形成同一个物理地址</p><p>（2）如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可定位多少个内存单元？</p><p><strong>结论：</strong>偏移地址16位，变化范围为0~FFFFH,仅用偏移地址来寻址最多可寻64KB个内存单元</p><p>在8086PC机中，存储单元的地址用两个元素来描述，即段地址和偏移地址。<br>“数据在 21F60H内存单元中。”这句话对于 8086PC机一般不这样讲， 取而代之的是两种类似的说法<br>①数据存在内存2000:1F60单元中；<br>②数据存在内存的2000H段中的1F60H单元中。<br>这两种描述都表示“数据在内存21F60H单元中”。</p><p>可以根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段。</p><h3 id="2-9-段寄存器（Segment-Register）"><a href="#2-9-段寄存器（Segment-Register）" class="headerlink" title="2.9 段寄存器（Segment Register）"></a>2.9 段寄存器（Segment Register）</h3><p>段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器：CS（Code Segment）、DS（Data Segment）、SS（Stack Segment）、ES（Extra Segment）、当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。</p><p>本章中只看一下CS</p><center><span style="color:blue;font-size:15px">2021/3/2</span></center><h3 id="2-10-CS和IP（指令的执行过程）"><a href="#2-10-CS和IP（指令的执行过程）" class="headerlink" title="2.10 CS和IP（指令的执行过程）"></a>2.10 CS和IP（指令的执行过程）</h3><p>CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。<strong>CS为代码段寄存器</strong>（Code Segment），<strong>IP 为指令指针寄存器</strong>（Instruction Pointer），从名称上我们可以看出它们和指令的关系。</p><p>在8086PC机中，任意时刻，设CS中的内容为M，IP中的内容为N, 8086CPU 将从内存Mx16+N单元开始，读取一条指令并执行。<br>也可以这样表述: 8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/RV8OC4_%7DN08H4BD4QD%604K%5DH.png" alt=""></p><p>读取一条指令后，IP中的值自动增加，以使CPU可以读取下一条指令，当前读入的指令B82301长度为3个字节，所以IP中的值增加3，后面的指令也依次如上运行</p><p><strong>8086CPU的工作过程可以简要描述如下。</strong><br>(1) 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器:<br>(2) IP=IP+所读取指令的长度， 从而指向下一条指令:<br>(3) 执行指令。转到步骤(1)， 重复这个过程。</p><p>在8086CPU加电启动或复位后，CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。</p><p><strong>在内存中，指令和信息没有任何区别，CPU根据什么将内存中的信息看作指令？</strong><br>CPU将CS:IP指向的内存单元中的内容看作指令。如果说，内存中的一段信息曾被CPU执行过的话，那么，它所在的内存单元必然被CS:IP指向过。</p><h3 id="2-11-修改CS、IP的指令（jmp）"><a href="#2-11-修改CS、IP的指令（jmp）" class="headerlink" title="2.11 修改CS、IP的指令（jmp）"></a>2.11 修改CS、IP的指令（jmp）</h3><p>使用mov（传送指令）可以修改大部分寄存器的值，如AX，BX等，但不能设置CS，IP的值。<br>能够改变CS，IP的内容的指令被统称为转移指令，现在介绍一个最简单的：<strong>jmp指令</strong><br>若想同时修改CS、IP的内容，可用形似”<strong>jmp 段地址:偏移地址</strong>“的指令完成<br>若想仅修改IP的内容，可直接用”<strong>jmp 某一合法寄存器</strong>“的指令完成</p><h3 id="2-12-代码段"><a href="#2-12-代码段" class="headerlink" title="2.12 代码段"></a>2.12 代码段</h3><p>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段，如果用于存代码，就可以认为是一个代码段。</p><p>将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认可被CS:IP指向的内存单元中的内容为指令。</p><center><span style="color:blue;font-size:15px">2021/3/3</span></center><h3 id="实验1-查看CPU和内存，用机器指令和汇编指令编程"><a href="#实验1-查看CPU和内存，用机器指令和汇编指令编程" class="headerlink" title="实验1 查看CPU和内存，用机器指令和汇编指令编程"></a>实验1 查看CPU和内存，用机器指令和汇编指令编程</h3><h4 id="1-预备知识：Debug的使用"><a href="#1-预备知识：Debug的使用" class="headerlink" title="1.预备知识：Debug的使用"></a>1.预备知识：Debug的使用</h4><p>(1)什么是Debug?<br>Debug是DOS、Windows 都提供的实模式(8086方式)程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。</p><p><strong>实模式：</strong>16位模式，不同的程序可使用不同的分段策略，两个程序的不同逻辑地址，可能对应相同的物理地址，程序A可能修改程序B已经保存在内存里的值（游戏修改器）。</p><p><strong>保护模式：</strong>32位模式，程序不能更改其他程序的内存。</p><p>(2)常用到的Debug功能。</p><ul><li>用Debug的R命令查看、改变CPU寄存器的内容； </li><li>用Debug的D命令查看内存中的内容；</li><li>用Debug的E命令改写内存中的内容；</li><li>用Debug的U命令将内存中的机器指令翻译成汇编指令；</li><li>用Debug的T命令执行一条机器指令；</li><li>用Debug的A命令以汇编指令的格式在内存中写入一条机器指令。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303182904129.png" alt="用R命令查看、改变CPU寄存器的内容"></p><p>也可以用R命令来改变寄存器中的内容，如”r ax” “r ip”等</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303184200633.png" alt="用D命令查看内存中的内容"></p><p>使用D命令，Debug将输出3部分内容</p><p>（1）中间是从指定地址开始的128（16*8）个内存单元的内容，用十六进制的格式输出。</p><p>（2）左边是每行的起始地址 </p><p>（3）右边是每个内存单元中的数据对应的可显示的ASCII码字符</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303185328227.png" alt="用E命令改写内存中的内容"></p><p>也可直接写e 1000:0后逐个修改</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303185916604.png" alt="用E命令向内存中写入字符和字符串"></p><p>如何向内存中写入机器码呢？我们知道，机器码也是数据，也可以用E命令将机器码写入内存。</p><div class="table-container"><table><thead><tr><th style="text-align:center">机器码</th><th style="text-align:center">对应的汇编指令</th></tr></thead><tbody><tr><td style="text-align:center">b80100</td><td style="text-align:center">mov ax,0001</td></tr><tr><td style="text-align:center">b90200</td><td style="text-align:center">mov cx,0002</td></tr><tr><td style="text-align:center">01c8</td><td style="text-align:center">add ax,cx</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303190646149.png" alt="写入机器码并用U命令查看"></p><p>U命令可以将内存单元中的内容翻译为汇编指令，并显示出来。</p><p>由此，我们可以再一次看到内存中的数据和代码没有任何区别，关键在于如何解释。</p><p>如何执行我们写入的机器指令呢？使用Debug的T命令可以执行一条或多条指令。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303191609348.png" alt="使用T命令执行CS:IP指向的指令"></p><p>用E命令写入机器指令很不方便，为此，Debug提供了A命令。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303215741998.png" alt="用A命令写入指令"></p><h4 id="2-实验任务"><a href="#2-实验任务" class="headerlink" title="2.实验任务"></a>2.实验任务</h4><p>（1）使用Debug，将下面的程序段写入内存，逐条执行，观察每条指令执行后CPU中相关寄存器中内容的变化。（ez）</p><p>（2）将下面3条指令写入从2000:0开始的内存单元中，利用这3条指令计算2的8次方。（ez）</p><blockquote><p>mov ax,1</p><p>add ax,ax</p><p>jmp 2000:0003</p></blockquote><p>(3)主板上的ROM中写有一个生产日期，在内存FFF00H~FFFFFH的某几个单元中，请找到这个生产日期并试图改变它</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303221907140.png" alt=""></p><p>rom修改无效 这个日期是由于win10不自带debug，所以使用DosBox来虚拟Dos环境，这个日期也是虚拟出来的，由于不是直接操作实模式，避免了一些误操作。</p><p>(4)向内存从B8100H开始的单元中填写数据</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303223129794.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303223121403.png" alt="执行后在屏幕右上方出现这些字符"></p><p>但是用d查看，内存中存储的数据会变化，因为显存中的内容和屏幕是一一对应的。在</p><p>输入的过程中屏幕上的内容变化了，显存中的内容也会跟着变。</p><h2 id="第3章-寄存器（内存访问）"><a href="#第3章-寄存器（内存访问）" class="headerlink" title="第3章 寄存器（内存访问）"></a>第3章 寄存器（内存访问）</h2><p>上一章中，我们主要从CPU如何执行指令的角度讲解了8086CPU的逻辑结构，形成物理地址的方法，相关的寄存器以及一些指令。<br>这一章中，我们从访问内存的角度继续学习几个寄存器。</p><h3 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h3><p>CPU中，用16位寄存器来存储一个字。高8位高字节，低8位低字节。在内存中存储时，由于内存是字节单元，则一个字要用两个地址连续的内存单元来存放。<br>比如用0,1两个内存单元来存放数据20000（4E20H)，则0号单元存储20H，1号单元存储4EH。</p><p>我们提出<strong>字单元</strong>的概念：字单元，即存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p><h3 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2  DS和[address]"></a>3.2  DS和[address]</h3><p>CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。</p><blockquote><p>mov bx,1000H</p><p>mov ds,bx</p><p>mov al,[0]</p></blockquote><p>上面的3条指令将10000H(1000:0)中的数据读到al中。<br>mov除了前面用过的将数据送入寄存器，讲寄存器的内容送入另一个寄存器，还可以<strong>将一个内存单元的内容送入一个寄存器</strong>中。<br>[···]表示一个内存单元。[···]中的0表示内存单元的偏移地址，执行指令时，8086CPU自动取ds中的数据为内存单元的段地址。</p><p>由于8086CPU不支持将数据直接送入段寄存器的操作，所以只好用一个寄存器进行中转。</p><h3 id="3-3-字的传送"><a href="#3-3-字的传送" class="headerlink" title="3.3 字的传送"></a>3.3 字的传送</h3><p>因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是说可以一次性传送一个字。只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了。</p><h3 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a>3.4 mov、add、sub指令</h3><p>mov指令允许的形式：</p><ul><li>mov 寄存器,数据</li><li>mov 寄存器,寄存器</li><li>mov 寄存器,内存单元</li><li>mov 内存单元,寄存器</li><li>mov 段寄存器,寄存器</li><li>mov 寄存器,段寄存器</li><li>mov 内存单元,段寄存器</li><li>mov 段寄存器,内存单元</li></ul><p>数据其实也可以mov给内存单元，但是要加位宽修饰符</p><p>add和sub一样，都有两个操作对象，也可以有几种形式</p><ul><li>add 寄存器,数据</li><li>add 寄存器,寄存器</li><li>add 寄存器,内存单元</li><li>add 内存单元,寄存器</li></ul><center><span style="color:blue;font-size:15px">2021/4/10</span></center><h3 id="3-5-数据段"><a href="#3-5-数据段" class="headerlink" title="3.5 数据段"></a>3.5 数据段</h3><p>前面讲过，对于8086pc机，在编程时，可以根据需要，将一组内存单元定义为一个段。所以我们也可以将一组长度小于64kb，地址连续，起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。</p><p>将一段内存当作数据段，是我们在编程时的一种安排，可以在具体操作时，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。</p><blockquote><p>数据和程序没有区别，段地址若是ds段，可看做是数据，段地址若是cs段，可看做是程序指令</p></blockquote><h3 id="3-6-栈"><a href="#3-6-栈" class="headerlink" title="3.6 栈"></a>3.6 栈</h3><p>LIFO(Last In First Out)</p><h3 id="3-7-CPU提供的栈机制"><a href="#3-7-CPU提供的栈机制" class="headerlink" title="3.7 CPU提供的栈机制"></a>3.7 CPU提供的栈机制</h3><p>现今的CPU中都有栈的设计，8086CPU提供相关的指令来以栈的方式访问内存空间。这意味着，可以将一段内存当作栈来使用</p><p>下面举例说明，我们可以将10000H~1000FH这段内存当作栈来使用。</p><p><img src="/images/assembly/image-20210410145339891.png" alt="8086CPU的栈操作"></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ax,0123Hpush axmov bx,2266Hpush bxmov cx,1122Hpush cxpop axpop bxpop cx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：字型数据用两个单元存放，高地址单元存放高8位，低地址单元存放低8位。</p><p>在8086CPU中，有两个寄存器，<strong>段寄存器</strong>SS (Stack Segment) 和<strong>寄存器</strong>SP (stack pointer) ，栈顶的段地址存放在SS中，偏移地址存放在SP中。任意时刻，SS:SP指向栈顶元素，push和pop指令执行时，CPU从SS和SP中得到栈顶的地址。</p><blockquote><p>如上图，初试状态栈为空时，SS=1000H，SP=0010H</p></blockquote><p>push ax 的执行，由以下两步完成。</p><ol><li>SP=SP-2，SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li><li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li></ol><p>pop ax 的执行过程和 push ax 刚好相反，由以下两步完成。</p><ol><li>将SS:SP 指向的内存单元处的数据送入ax中</li><li>SP=SP+2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新栈顶</li></ol><h3 id="3-8-栈顶超界的问题"><a href="#3-8-栈顶超界的问题" class="headerlink" title="3.8 栈顶超界的问题"></a>3.8 栈顶超界的问题</h3><p>栈顶超界是危险的，我们希望CPU可以帮我们解决这个问题，但实际的情况是，8086CPU中并没有这样的寄存器，我们在编程的时候要自己操心栈顶超界的问题。</p><h3 id="3-9-push、pop指令"><a href="#3-9-push、pop指令" class="headerlink" title="3.9 push、pop指令"></a>3.9 push、pop指令</h3><p>push和pop指令的格式可以是如下形式：</p><ul><li>push 寄存器</li><li>push 段寄存器</li><li>push 内存单元</li></ul><p>push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov不同的是，push和pop指令访问的内存单元的地址是由SS:SP 指出的。同时，push 和 pop 指令还要改变sp中的内容。</p><h3 id="3-10-栈段"><a href="#3-10-栈段" class="headerlink" title="3.10 栈段"></a>3.10 栈段</h3><p>我们也可以将长度小于64kb的一组地址连续，起始地址为16的倍数的内存单元当作栈空间来用，从而定义了一个栈段。（段地址放在ss中）</p><blockquote><p>一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于CPU中寄存器的设置，即CS , IP , SS , SP , DS的指向。</p></blockquote><h3 id="实验2-用机器指令和汇编指令编程"><a href="#实验2-用机器指令和汇编指令编程" class="headerlink" title="实验2 用机器指令和汇编指令编程"></a>实验2 用机器指令和汇编指令编程</h3><h4 id="1-预备知识：Debug的使用-1"><a href="#1-预备知识：Debug的使用-1" class="headerlink" title="1.预备知识：Debug的使用"></a>1.预备知识：Debug的使用</h4><p>(1)关于D命令</p><p>D命令是查看内存单元的命令，CPU在访问内存单元的时候从段寄存器中得到内存单元的段地址，所以，Debug在其处理D命令的程序段中，必须有将段地址送入寄存器的代码。</p><p>D命令也提供了一种符合CPU机理的格式：“d 段寄存器:偏移地址”，以下是几个例子。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">①-r ds:1000-d ds:0;查看从1000:0开始的内存②-r ds:1000-d ds:10 18;查看1000:10~1000:18中的内容③-d cs:0;查看当前代码段中的指令代码④-d ss:0;查看当前栈段中的内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2)在E、A、U命令中使用寄存器</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">①-r ds:1000-e ds:0 11 22 33 44 55 66;查看从1000:0开始的内存②-u cs:0;以汇编指令的形式，显示当然代码段中的代码③ -r cs:0:1000-a ds:0;以汇编指令的形式，向从1000:0开始的内存单元中写入指令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(3)下一条指令执行了吗？</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ax,2000mov ss,axmov sp,10mov ax,3123...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在用T执行单步操作 mov ss,ax 后，下一条指令直接变成了mov ax,3123。<br>在用T命令执行 mov ss,ax的时候，它的下一条指令mov sp,10也紧接着执行了。<br>不单是mov ss,ax，对于如 mov ss,bx，mov ss,[0]，pop ss等指令都会发生上面的情况，这些指令有哪些共性呢，它们都是<strong>修改栈段寄存器SS的指令</strong>。</p><p>为什么会这样呢，这涉及我们在以后的课程中要深入研究的内容：<strong>中断机制</strong>。</p><h4 id="2-实验任务-1"><a href="#2-实验任务-1" class="headerlink" title="2.实验任务"></a>2.实验任务</h4><p>(1) 使用Debug，将下面的程序段写入内存，逐条执行，根据指令执行后的实际运行情况填空。（ez)</p><p>(2) 仔细观察图3.19中的实验内容，然后分析：为什么2000:0~2000:f中的内容会发生改变。（书上）</p><center><span style="color:blue;font-size:15px">2021/4/11</span></center><h2 id="第4章-第一个程序"><a href="#第4章-第一个程序" class="headerlink" title="第4章 第一个程序"></a>第4章 第一个程序</h2><p>现在我们将开始编写完整的汇编语言程序，用编译和连接程序将它们编译连接成为可执行文件</p><h3 id="4-1-一个源程序从写出到执行的过程"><a href="#4-1-一个源程序从写出到执行的过程" class="headerlink" title="4.1 一个源程序从写出到执行的过程"></a>4.1 一个源程序从写出到执行的过程</h3><ul><li>编写源程序</li><li>对源程序进行编译连接（编译生成目标文件，连接生成可执行文件）</li><li>执行可执行文件中的程序</li></ul><h3 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codesgcodesg segmentmov ax,0123Hmov bx,0456Hadd ax,bxadd ax,axmov ax,4c00Hint 21Hcodesg endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-伪指令"><a href="#1-伪指令" class="headerlink" title="1. 伪指令"></a>1. 伪指令</h4><p>在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令有对应的机器码，可以被编译为机器指令，最终为CPU所执行。而伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。</p><p>上面的程序出现了3种伪指令</p><p>(1)    XXX segment<br>                    …<br>        XXX ends<br>segment 和 ends 是一对成对使用的伪指令，是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。功能是定义一个段，分别说明段的开始和结束。<br>一个汇编程序是由多个段组成的，这些段被用来存放代码，数据或当作栈空间来使用。<br>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。</p><p>(2)    end<br>end是一个汇编程序的结束标记，汇编器在编译汇编程序的过程中，如果碰到了指令end，就结束对源程序的编译。<br><strong>注意</strong>：不要把end和ends搞混</p><p>(3)    assume<br>这条伪指令可以把某一段寄存器和程序中的某一个用segment…ends定义的段相关联。</p><h4 id="2-源程序中的”程序”"><a href="#2-源程序中的”程序”" class="headerlink" title="2. 源程序中的”程序”"></a>2. 源程序中的”程序”</h4><p>程序最先以汇编指令的形式存放在源程序中，经编译，连接后转变为机器码，存储在可执行文件中。（伪指令是由编译器来处理的）</p><h4 id="3-标号"><a href="#3-标号" class="headerlink" title="3. 标号"></a>3. 标号</h4><p>如“codesg”。一个标号指代了一个地址，作为一个段的名称，这个段的名称最终将被编译，连接程序处理为一个段的段地址。</p><h4 id="4-程序的结构"><a href="#4-程序的结构" class="headerlink" title="4. 程序的结构"></a>4. 程序的结构</h4><p>如上程序</p><h4 id="5-程序返回"><a href="#5-程序返回" class="headerlink" title="5. 程序返回"></a>5. 程序返回</h4><p>若想要一个程序p2运行，则必须有一个正在运行的程序p1，将p2从可执行文件中加载入内存后，将CPU的控制权交给p2，p2才能运行。p2开始运行后，p1暂停运行。<br>当p2运行完毕后，将CPU的控制权交还给使它得以运行的程序p1，此后，p1继续运行。<br>我们把交还CPU的控制权的过程称为<strong>程序返回</strong></p><p>​    mov ax,4c00H<br>​    int 21H</p><p>这两条指令所实现的功能就是程序返回。</p><h4 id="6-语法错误和逻辑错误"><a href="#6-语法错误和逻辑错误" class="headerlink" title="6. 语法错误和逻辑错误"></a>6. 语法错误和逻辑错误</h4><p>语法错误可以在程序编译时被编译器发现。</p><h3 id="4-3-编译源程序"><a href="#4-3-编译源程序" class="headerlink" title="4.3 编译源程序"></a>4.3 编译源程序</h3><p>可以用任意的文本编辑器来编辑源程序，只要最终将其存储为纯文本文件即可。(扩展名一般写.asm)</p><h3 id="4-4-编译"><a href="#4-4-编译" class="headerlink" title="4.4 编译"></a>4.4 编译</h3><p><img src="/images/assembly/image-20210411105338039.png" alt=""></p><h3 id="4-5-连接"><a href="#4-5-连接" class="headerlink" title="4.5 连接"></a>4.5 连接</h3><p><img src="/images/assembly/image-20210411105620229.png" alt=""></p><p>连接的作用有以下几个</p><ul><li>当源程序很大时，可以将它分为多个源程序文件来编译，成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件。</li><li>程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件。</li><li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。</li></ul><h3 id="4-6-以简化的方式进行编译和连接"><a href="#4-6-以简化的方式进行编译和连接" class="headerlink" title="4.6 以简化的方式进行编译和连接"></a>4.6 以简化的方式进行编译和连接</h3><h3 id="4-7-1-exe的运行"><a href="#4-7-1-exe的运行" class="headerlink" title="4.7 1.exe的运行"></a>4.7 1.exe的运行</h3><h3 id="4-8-谁将可执行文件中的程序装载进入内存并使它运行？"><a href="#4-8-谁将可执行文件中的程序装载进入内存并使它运行？" class="headerlink" title="4.8 谁将可执行文件中的程序装载进入内存并使它运行？"></a>4.8 谁将可执行文件中的程序装载进入内存并使它运行？</h3><h4 id="操作系统的外壳（shell）"><a href="#操作系统的外壳（shell）" class="headerlink" title="操作系统的外壳（shell）"></a>操作系统的外壳（shell）</h4><p>任何通用的操作系统，都要提供一个称为shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统进行工作。</p><p>DOS中有一个程序<strong>command.com</strong>，这个程序在DOS中称为命令解释器，也就是<strong>DOS系统的shell</strong>。</p><p>DOS启动时，先完成其他重要的初始化工作，然后运行command.com，command.com运行后，执行完其他的相关任务后，在屏幕上显示出由当前盘符和当前路径组成的提示符，等待用户的输入。</p><p>用户可以输入所要执行的命令，如cd、dir等，这些命令由command执行，完成这些命令后，再次等待用户的输入。</p><p><strong>如果用户要执行一个程序</strong>，则输入可执行文件的名称，command会找到文件，将这个可执行文件中的程序加载入内存，设置CS：IP指向程序的入口，此后，command暂停运行，CPU运行程序。程序运行结束后，返回到command中，再次等待用户输入。</p><p>刚才的汇编程序从写出到执行的过程：</p><div class="table-container"><table><thead><tr><th>编程</th><th>1.asm</th><th>编译</th><th>1.obj</th><th>连接</th><th>1.exe</th><th>加载</th><th>内存中的程序</th><th>运行</th></tr></thead><tbody><tr><td>（Edit）</td><td></td><td>（masm）</td><td></td><td>（link）</td><td></td><td>（command）</td><td></td><td>（CPU）</td></tr></tbody></table></div><h3 id="4-9-程序执行过程的跟踪"><a href="#4-9-程序执行过程的跟踪" class="headerlink" title="4.9 程序执行过程的跟踪"></a>4.9 程序执行过程的跟踪</h3><p>使用command不能逐条指令地看到程序的执行过程，因为command的程序加载，设置CS：IP指向程序的入口的操作是连续完成的，当CS：IP一指向程序的入口，command就放弃了CPU的控制权。</p><p>为了观察程序的运行过程，可以使用Debug，Debug可以将程序加载入内存，设置CS：IP指向程序的入口，但Debug并不放弃对CPU的控制，这样，我们就可以使用Debug的相关命令来单步执行程序，查看每一条指令的执行结果。</p><p><img src="/images/assembly/image-20210411113906738.png" alt=""></p><p>这里，需要讲解一下DOS系统中.EXE文件中的程序的加载过程。</p><p><img src="/images/assembly/image-20210411165545638.png" alt=""></p><p>（1）程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为ds：0；</p><p>（2）这个内存区的前256个字节中存放的是PSP，DOS用来和程序进行通信。从256字节处向后的空间存放的是程序。</p><h3 id="实验3-编程、编译、连接、跟踪"><a href="#实验3-编程、编译、连接、跟踪" class="headerlink" title="实验3 编程、编译、连接、跟踪"></a>实验3 编程、编译、连接、跟踪</h3><p>书上</p><center><span style="color:blue;font-size:15px">2021/4/12</span></center><h2 id="第5章-BX-和loop指令"><a href="#第5章-BX-和loop指令" class="headerlink" title="第5章 [BX]和loop指令"></a>第5章 [BX]和loop指令</h2><p><strong>1.[bx]和内存单元的描述</strong></p><p>[bx]同样也表示一个内存单元，它的偏移地址在bx中，比如下面的指令:<br>mov ax,[bx]<br>将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址在bx中，段地址在ds中</p><p><strong>2.loop</strong></p><p>我们在这一章，讲解[bx]和loop指令的应用、意义和相关的内容。</p><p><strong>3.我们定义的描述性的符号:“()”</strong></p><p>为了描述上的简洁，使用一个描述性的符号 “()”来表示一个寄存器或一个丙存单元中的内容。比如:<br>(ax)表示ax中的内容、(al)表示al中的内容:</p><p><strong>4.约定符号idata表示常量</strong></p><h3 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1 [BX]"></a>5.1 [BX]</h3><p>mov ax, [bx]<br>功能: bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。即: (ax)=((ds)* 16+(bx))。</p><p><strong>注意：</strong>inc bx的含义是bx中的内容加1。</p><h3 id="5-2-Loop指令"><a href="#5-2-Loop指令" class="headerlink" title="5.2 Loop指令"></a>5.2 Loop指令</h3><p>loop指令的格式是: loop 标号，CPU执行loop指令的时候，要进行两步操作，<br>①(cx)=(cx)-1;<br>②判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。</p><p>从上面的描述中，可以看到，cx中的值影响着loop指令的执行结果。通常我们用loop指令来实现循环功能，cx 中存放循环次数。</p><p>任务：编程计算$2^{12}$</p><p>分析：计算$2^{12}$需要11条重复的指令 add ax,ax。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentmov ax,2mov cx,11s:add ax,axloop smov ax,4c00hint 21hcode ends;end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用cx和loop指令相配合实现循环功能的程序框架如下</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov cx，循环次数s:循环执行的程序段loop s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-在Debug中跟踪用loop指令实现的循环程序"><a href="#5-3-在Debug中跟踪用loop指令实现的循环程序" class="headerlink" title="5.3 在Debug中跟踪用loop指令实现的循环程序"></a>5.3 在Debug中跟踪用loop指令实现的循环程序</h3><p><img src="/images/assembly/image-20210412144427605.png" alt="image-20210412144427605"></p><p>循环程序段从CS:0012开始，CS:0012前面的指令，我们不想一步步跟踪，可以使用g命令”g 0012”，它表示执行程序到当前代码段的0012h处。</p><p>当遇到loop指令时，可以使用p命令来执行，Debug就会自动重复执行循环中的指令，直到(cx)=0为止。</p><p>当然，也可以使用g命令来达到目的。</p><h3 id="5-4-Debug和汇编编译器masm对指令的不同处理"><a href="#5-4-Debug和汇编编译器masm对指令的不同处理" class="headerlink" title="5.4 Debug和汇编编译器masm对指令的不同处理"></a>5.4 Debug和汇编编译器masm对指令的不同处理</h3><p>在Debug中，mov ax,[0]表示将ds:0处的数据送入ax中。<br>但是在汇编源程序中，指令“mov ax,[0]”被编译器当作指令”mov ax,0处理”。</p><p>那么我们如何在源程序中实现将内存2000:0之类的数据送入al，bl，cl，dl呢？<br>可将偏移地址送入bx寄存器中，用[bx]的方式来访问内存单元。<br>也可以在[]的前面显式地给出段地址所在的段寄存器，如”mov al,ds:[0]”。</p><h3 id="5-5-loop和-bx-的联合应用"><a href="#5-5-loop和-bx-的联合应用" class="headerlink" title="5.5 loop和[bx]的联合应用"></a>5.5 loop和[bx]的联合应用</h3><p>计算ffff:0~ffff:b单元中的数据的和，结果存储在dx中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentmov ax,0ffffhmov ds,axmov bx,0;bx充当代表内存单元地址的变量mov dx,0mov cx,12s:mov al,[bx]mov ah,[0]add,dx,axinc bxloop smov ax,4c00hint 21hcode endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-段前缀"><a href="#5-6-段前缀" class="headerlink" title="5.6 段前缀"></a>5.6 段前缀</h3><p>我们可以在访问内存单元的指令中显示地给出内存单元的段地址所在的寄存器，比如”ds:” “cs:”等，这些在汇编语言中称为段前缀。</p><h3 id="5-7-一段安全的空间"><a href="#5-7-一段安全的空间" class="headerlink" title="5.7 一段安全的空间"></a>5.7 一段安全的空间</h3><p>在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或代码。</p><p>在一般的pc机中，DOS方法下，0:200~0:2ff的256个字节的空间一般不会被使用。</p><h3 id="5-8-段前缀的使用"><a href="#5-8-段前缀的使用" class="headerlink" title="5.8 段前缀的使用"></a>5.8 段前缀的使用</h3><p>将内存ffff:0~ffff:b单元中的数据复制到0:200~0:20b单元中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentmov ax,0ffffhmov ds,axmov ax,0020hmov es,axmov bx,0mov cx,12s:mov dl,[bx]mov es:[bx],dlinc bxloop smov ax,4c00hint 21hcode endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实验4-bx-和loop的使用"><a href="#实验4-bx-和loop的使用" class="headerlink" title="实验4 [bx]和loop的使用"></a>实验4 [bx]和loop的使用</h3><p>(1)、(2)编程，向内存0:200~0:23F依次传送数据0~63(3FH)。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentmov ax,20hmov ds,axmov bx,0mov cx,64s:mov [bx],bxinc bxloop smov ax,4c00hint 21hcode endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/assembly/image-20210412161520503.png" alt=""></p><center><span style="color:blue;font-size:15px">2021/4/13</span></center><h2 id="第6章-包含多个段的程序"><a href="#第6章-包含多个段的程序" class="headerlink" title="第6章 包含多个段的程序"></a>第6章 包含多个段的程序</h2><p>在前面的程序中，只有一个代码段，现在的问题是，如果程序需要用其他空间来存放数据，使用哪里呢？<br>合法地通过操作系统取得的空间都是安全的，程序取得空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在执行的过程中向系统申请。在我们的课程中，不讨论第二种方法。</p><h3 id="6-1-在代码段中使用数据"><a href="#6-1-在代码段中使用数据" class="headerlink" title="6.1 在代码段中使用数据"></a>6.1 在代码段中使用数据</h3><p>从规范的角度来讲，我们是不能自已随便决定哪段空间可以使用的，应该让系统来为我们分配。<br>我们可以在程序中，定义我们希望处理的数据，这现数据就会被编译、连接程序作为程序的一部分载入内存。 与此同时，我们要处理的数据也就自然而然地获得了存储空间。</p><p>编程计算8个数据的和，结果存在ax寄存器中：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hmov cx,0...code endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dw(define word)的含义是定义字型数据，由于它们在代码段中，所以可以从cs中得到它们的段地址。用dw定义的数据处于代码段的最开始，所以偏移地址为0。</p><p>可是这样一来，我们就必须用Debug来执行程序，因为程序的入口处不是我们所希望执行的指令（指令在ip=10h处）。我们可以在源程序中指明程序的入口所在。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hstrat:mov bx,0mov ax,0mov cx,8s:add ax,cs:[bx]add bx,2loop smov ax,4c00hint 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。在程序6.2中我们<strong>用end指令指明了程序的入口</strong>在标号start处。</p><p>在前面的课程中，我们已经知道在单任务系统中，<strong>可执行文件中的程序执行过程如下</strong>。<br>(1)由其他的程序(Debug、command 或其他程序)将可执行文件中的程序加载入内存:<br>(2)设置CS:IP指向程序的第一条要执行的指令(即程序的入口)，从而使程序得以运行;<br>(3)程序运行结束后，返回到加载者。</p><p>现在的问题是，<strong>根据什么设置CPU的CS:IP 指向程序的第一条要执行的指令？</strong><br>这一点，是由可执行文件中的描述信息指明的。我们知道可执行文件由描述信息和程序组成，程序来自于源程序中的汇编指令和定义的数据；<strong>描述信息</strong>则主要是编译、连接程序对源程序中<strong>相关伪指令进行处理</strong>所得到的信息。我们在程序6.2中，用伪指令end描述了程序的结束和程序的入口。在编译、连接后，由“end start” 指明的程序入口，被转化为一个入口地址，存储在可执行文件的描述信息中。在被加载到内存后，加载者从程序的可执行文件的描述信息中读到程序的入口地址，设置CS:IP。</p><h3 id="6-2-在代码段中使用栈"><a href="#6-2-在代码段中使用栈" class="headerlink" title="6.2 在代码段中使用栈"></a>6.2 在代码段中使用栈</h3><p>完成下面的程序，利用栈，将程序中定义的数据逆序存放</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codesgcodesg segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h?codesg endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在程序中通过定义数据来取得一段空间，然后将这段空间当作栈空间来用。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codesgcodesg segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;用dw定义16个字型数据，当栈来使用。start:mov ax,csmov ss,axmov sp,30hmov bx,0mov cx,8s:push cs:[bx]add bx,2loop smov bx,0mov cx,8s0:pop cs:[bx]add bx,2loop s0mov ax,4c00hint 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ss:sp要指向栈底，使用设置ss:sp指向cs:30</p><h3 id="6-3-将数据、代码、栈放入不同的栈"><a href="#6-3-将数据、代码、栈放入不同的栈" class="headerlink" title="6.3 将数据、代码、栈放入不同的栈"></a>6.3 将数据、代码、栈放入不同的栈</h3><p>我们用和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:code,ds:data,ss:stackdata segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdata endsstack segmentdw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0stack endscode segmentstart:mov ax,stackmov ss,axmov sp,20hmov ax,datamov ds,axmov bx,0mov cx,8s:push [bx]add bx,2loop smov bx,0mov cx,8s0:pop [bx]add bx,2loop s0mov ax,4c00hint 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以明显看出，定义一个段的方法和前面讲的定义代码段的方法没有区别。在程序中，段名就相当于一个标号，它代表了段地址。但是我们用伪指令”assume cs:code,ds:data,ss:stack”，CPU并没有真正将cs，ds，ss指向这3个地址，而是我们后来写的指令将其送入，因为assume是伪指令，是由编译器执行的，CPU并不知道它们，我们不必深究assume的作用。</p><h3 id="实验5-编写、调试具有多个段的程序"><a href="#实验5-编写、调试具有多个段的程序" class="headerlink" title="实验5 编写、调试具有多个段的程序"></a>实验5 编写、调试具有多个段的程序</h3><p>重要，书上。</p><p>每个段的大小最低为16字节的倍数，向上取整。</p><h2 id="第7章-更灵活的定位内存地址的方法"><a href="#第7章-更灵活的定位内存地址的方法" class="headerlink" title="第7章 更灵活的定位内存地址的方法"></a>第7章 更灵活的定位内存地址的方法</h2><p>本章我们主要通过具体的问题来讲解一些更灵活的定位内存地址的方法和相关的编程方法</p><h3 id="7-1-and-和-or-指令"><a href="#7-1-and-和-or-指令" class="headerlink" title="7.1 and 和 or 指令"></a>7.1 and 和 or 指令</h3><p>(1) and指令：逻辑与指令，按位进行与运算。<br>mov          al, 01100011B<br>and           al, 00111011B<br>执行后:     al=00100011B<br>通过该指令可将操作对象的相应位设为0，其他位不变。</p><p>(2) or指令：逻辑或指令，按位进行或运算。<br>mov          al, 01100011B<br>or              al, 00111011B<br>执行后:     al=01111011B<br>通过该指令可将操作对象的相应位设为1,其他位不变。</p><center><span style="color:blue;font-size:15px">2021/4/14</span></center><h3 id="7-2-关于ASCII码"><a href="#7-2-关于ASCII码" class="headerlink" title="7.2 关于ASCII码"></a>7.2 关于ASCII码</h3><p>ASCII码是一种编码方案，比如61H表示”a”，41H表示”A”</p><p>在文本编辑过程中，我们按下键盘的a键，这个按键的信息被送入计算机，计算机用ASCII码的规则对其进行编码，将其转化为61H存储在内存的指定空间中；文本编辑软件从内存中取出61H，将其送到显卡上的显存中;工作在文本模式下的显卡，用ASCII码的规则解释显存中的内容，61H被当作字符“a”，显卡驱动显示器，将字符“a”的图像画在屏幕上。</p><p>这也就是说，如果我们要想在显示器上看到“a”，就要给显卡提供“a”的ASCI码，61H。如何提供？当然是写入显存中。</p><h3 id="7-3-以字符形式给出的数据"><a href="#7-3-以字符形式给出的数据" class="headerlink" title="7.3 以字符形式给出的数据"></a>7.3 以字符形式给出的数据</h3><p>我们可以在汇编程序中，用’…’的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的ASCII码。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:code ds:datadata segmentdb 'unIX'db 'foRK'data endscode segmentstart:mov al,'a'mov bl,'b'mov ax,4c00hint 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-4-大小写转换的问题"><a href="#7-4-大小写转换的问题" class="headerlink" title="7.4 大小写转换的问题"></a>7.4 大小写转换的问题</h3><p>考虑这样一个问题，在codesg中填写代码，将datasg中的第一个字符串转化为大写，第二个字符串转化为小写。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">datasg segmentdb 'BaSiC'db 'iNFOrMaTiOn'datasg ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是，现实的问题却要求重新必须能区别对待大写字母和小写字母，我们还没有学习判断指令。</p><p>寻找新的规律可以看出，就ASCII码的二进制形式看，除第5位（位数从0开始计算）外，大写字母和小写字母的其他各位都一样。这样，我们就有了新的方法，一个字母，将它的第5位置0，它就必将变为大写字母；将它的第5位置1，它就必将变为小写字母。</p><p>这样就可以用or和and指令来将一个数据中的某一位置0或置1。</p><h3 id="7-5-bx-idata"><a href="#7-5-bx-idata" class="headerlink" title="7.5 [bx+idata]"></a>7.5 [bx+idata]</h3><p>我们也可以用[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata<br>mov ax,[bx+200]<br>该指令也可以写成如下格式<br>mov ax,[200+bx]<br>mov ax,200[bx]<br>mov ax,[bx].200</p><h3 id="7-6-用-bx-idata-的方式进行数组的处理"><a href="#7-6-用-bx-idata-的方式进行数组的处理" class="headerlink" title="7.6 用[bx+idata]的方式进行数组的处理"></a>7.6 用[bx+idata]的方式进行数组的处理</h3><p>在codesg中填写代码，将datasg中的第一个字符串转化为大写，第二个字符串转化为小写</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:code ds:datadatasg segmentdb 'BaSiC'db 'MinIX'datasg endscode segmentstart:mov ax,datasgmov ds,axmov bx,0mov cx,5s:mov al,[bx]and al,11011111bmov [bx],almov al,[5+bx]or al,00100000bmov [5+bx],alint bxloop scode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[bx+idata]的方式为高级语言实现数组提供了便利机制。</p><h3 id="7-7-SI和DI"><a href="#7-7-SI和DI" class="headerlink" title="7.7 SI和DI"></a>7.7 SI和DI</h3><p>si和di是8086CPU中和bx功能相近的寄存器，但si和di不能够分成两个8位寄存器来使用。</p><h3 id="7-8-bx-si-和-bx-di"><a href="#7-8-bx-si-和-bx-di" class="headerlink" title="7.8 [bx+si]和[bx+di]"></a>7.8 [bx+si]和[bx+di]</h3><p>mov ax,[bx+si]<br>该指令也可以写成如下格式<br>mov ax,[bx][si]</p><h3 id="7-9-bx-si-idata-和-bx-di-idata"><a href="#7-9-bx-si-idata-和-bx-di-idata" class="headerlink" title="7.9 [bx+si+idata]和[bx+di+idata]"></a>7.9 [bx+si+idata]和[bx+di+idata]</h3><p>mov ax,[bx+si+idata]<br>该指令也可以写成如下格式（si好像都在后面）<br>mov ax,[bx+200+si]<br>mov ax,[200+bx+si]<br>mov ax,200[bx][si]<br>mov  ax,[bx].200[si]<br>mov ax,[bx][si].200</p><h3 id="7-10-不同的寻址方式的灵活应用（二重循环）"><a href="#7-10-不同的寻址方式的灵活应用（二重循环）" class="headerlink" title="7.10 不同的寻址方式的灵活应用（二重循环）"></a>7.10 不同的寻址方式的灵活应用（二重循环）</h3><p>问题7.7：编程，将datasg段中每个单词改写成大写字母</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codesg,ds:datasgdatasg segmentdb 'ibm             'db 'dec             'db 'dos             'db 'vax             'datasg endscodesg segmentstart:codesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们需要进行4*3次的二重循环，问题在于cx的使用，我们进行二重循环，却只用了一个循环计算器，造成在进行内存循环的时候，覆盖了外层循环的循环计数值。多用一个计算器又不可能，因为loop指令默认cx为循环计数器。</p><p>我们应该在每次内层循环的时候，将外层循环的cx中的数值保存起来，在执行外层循环的loop指令前，再恢复外层循环的cx数值。但是寄存器的数量有限，我们不应该选择寄存器，那么可以使用的就是内存了。可以考虑将需要暂存的数据放到内存单元中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codesg,ds:datasgdatasg segmentdb 'ibm             'db 'dec             'db 'dos             'db 'vax             'dw 0;定义一个字，用来暂存cxdatasg endscodesg segmentstart:mov ax,datasgmov ds,axmov bx,0mov cx,4s0:mov [40h],cxmov si,0mov cx,3s1: mov al,[bx+si]and al,11011111bmov [bx+si],alinc siloop s1add bx 10h;mov cx,[40h]loop s0mov ax,4c00hint 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般来说，在需要暂存数据的时候，我们都应该使用栈。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codesg,ds:datasg,ss:stacksgdatasg segmentdb 'ibm             'db 'dec             'db 'dos             'db 'vax             'datasg endsstacksg segmentdw 0,0,0,0,0,0,0,0stacksg endscodesg segmentstart:mov ax,datasgmov ds,axmov ax,stacksgmov ss,axmov sp,10hmov bx,0mov cx,4s0:pash cxmov si,0mov cx,3s1: mov al,[bx+si]and al,11011111bmov [bx+si],alinc siloop s1add bx 10h;pop cxloop s0mov ax,4c00hint 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实验6-实践课程中的程序"><a href="#实验6-实践课程中的程序" class="headerlink" title="实验6 实践课程中的程序"></a>实验6 实践课程中的程序</h3><p>电脑上</p><center><span style="color:blue;font-size:15px">2021/4/15</span></center><h2 id="第8章-数据处理的两个基本问题"><a href="#第8章-数据处理的两个基本问题" class="headerlink" title="第8章 数据处理的两个基本问题"></a>第8章 数据处理的两个基本问题</h2><p>本章对前面的所有内容是具有总结性的。我们知道，计算机是进行数据外理、运算的机器，那么有两个基本的问题就包含在其中:<br>(1)处理的数据在什么地方?<br>(2)要处理的数据有多长?<br>这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作。</p><p>我们定义的描述性符号：<br>reg表示一个寄存器<br>sreg表示一个段寄存器</p><h3 id="8-1-bx、si、di和bp"><a href="#8-1-bx、si、di和bp" class="headerlink" title="8.1 bx、si、di和bp"></a>8.1 bx、si、di和bp</h3><p>（1）在8086CPU中，只有这4个寄存器可以用在’[…]’中来进行内存单元的寻址。</p><p>（2）在[…]中，这4个寄存器可以单个出现，或只能以4种组合出现：</p><ul><li>bx和si</li><li>bx和di</li><li>bp和si</li><li>bp和di</li></ul><p>（3）<strong>只要在[…]中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中。</strong></p><h3 id="8-2-机器指令处理的数据在什么地方"><a href="#8-2-机器指令处理的数据在什么地方" class="headerlink" title="8.2 机器指令处理的数据在什么地方"></a>8.2 机器指令处理的数据在什么地方</h3><p>绝大部分机器指令都是进行数据处理的指令，处理大致可分为3类：读取、写入、运算。在机器指令这一层来讲， 并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。<br>指令在执行前，所要处理的数据可以在3个地方: CPU内部、内存、端口(端口将在后面的课程中进行讨论)</p><div class="table-container"><table><thead><tr><th>机器码</th><th>汇编指令</th><th>执行指令前数据的位置</th></tr></thead><tbody><tr><td>8E1E0000</td><td>mov bx,[0]</td><td>内存，ds:0单元</td></tr><tr><td>89C3</td><td>mov bx,ax</td><td>CPU内部，ax寄存器</td></tr><tr><td>BB0100</td><td>mov bx,1</td><td>CPU内部，指令寄存器</td></tr></tbody></table></div><h3 id="8-3-汇编语言中数据位置的表达"><a href="#8-3-汇编语言中数据位置的表达" class="headerlink" title="8.3 汇编语言中数据位置的表达"></a>8.3 汇编语言中数据位置的表达</h3><p>（1）立即数（idata）：执行前在CPU的指令缓冲器中</p><p>（2）寄存器</p><p>（3）段地址（SA）和偏移地址（EA）：指令要处理的数据在内存中</p><h3 id="8-4-寻址方式"><a href="#8-4-寻址方式" class="headerlink" title="8.4 寻址方式"></a>8.4 寻址方式</h3><p>当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式。（就是那些[bx+si+idata]什么的）</p><h3 id="8-5-指令要处理的数据的长度（byte-word）"><a href="#8-5-指令要处理的数据的长度（byte-word）" class="headerlink" title="8.5 指令要处理的数据的长度（byte/word）"></a>8.5 指令要处理的数据的长度（byte/word）</h3><p>8086CPU的指令，可以处理两种尺寸的数据，byte 和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。对于这个问题，汇编语言中用以下方法处理。</p><p>（1）通过寄存器名指明要处理的数据的尺寸。（ax/al）</p><p>（2）在没有寄存器名存在的情况下，用操作符word/byte ptr指明内存单元的长度，例如</p><p><code>mov word ptr ds:[0],1</code></p><p><code>inc byte ptr [bx]</code></p><p>在没有寄存器参与的内存单元访问指令中，用word ptr 或byte ptr 显性地指明所要访问的内存单元的长度是很必要的。否则，CPU无法得知所要访问的单元是字单元，还是字节单元。</p><p>（3）有些指令默认了访问的是字单元还是字节单元，例如push指令只能进行字操作。</p><h3 id="8-6-寻址方式的综合应用"><a href="#8-6-寻址方式的综合应用" class="headerlink" title="8.6 寻址方式的综合应用"></a>8.6 寻址方式的综合应用</h3><p>书上</p><h3 id="8-7-div指令"><a href="#8-7-div指令" class="headerlink" title="8.7 div指令"></a>8.7 div指令</h3><p>div是除法指令，使用div做除法的时候应注意以下问题。<br>（1）除数：有8位和16位两种，在一个reg或内存单元中。<br>（2）被除数：有16位和32位两种。如果除数为8位，被除数则为16位，默认在AX中存放；<br>如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。<br>（3）结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数:<br>如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</p><p><code>div byte ptr ds:[0]</code><br>含义：(al)=(ax)/((ds)*16+0)的商    (ah)=(ax)/((ds)*16+0)的余数</p><p><code>div word prt [bx+si+8]</code><br>含义：(ax)=[(dx)*10000H+(ax)]/((ds)*10H+(bx)+(si)+8)的商<br>(dx)=[(dx)*10000H+(ax)]/((ds)*10H+(bx)+(si)+8)的余数</p><h3 id="8-8-伪指令dd"><a href="#8-8-伪指令dd" class="headerlink" title="8.8 伪指令dd"></a>8.8 伪指令dd</h3><p>dd用来定义dword（双字）型数据</p><h3 id="8-9-dup"><a href="#8-9-dup" class="headerlink" title="8.9 dup"></a>8.9 dup</h3><p>dup也是由编译器识别处理的符号，用来进行数据的重复。</p><p><code>db 3 dup(0)</code>    相当于db 0,0,0</p><p><code>db 3 dup(0,1,2)</code>    相当于db 0,1,2,0,1,2,0,1,2</p><p><code>db 3 dup('abc','ABC')</code>    相当于 db’abcABCabcABCabcABC’</p><h3 id="实验7-寻址方式在结构化数据访问中的应用"><a href="#实验7-寻址方式在结构化数据访问中的应用" class="headerlink" title="实验7 寻址方式在结构化数据访问中的应用"></a>实验7 寻址方式在结构化数据访问中的应用</h3><p>重要，见代码</p><center><span style="color:blue;font-size:15px">2021/4/16</span></center><h2 id="第9章-转移指令的原理"><a href="#第9章-转移指令的原理" class="headerlink" title="第9章 转移指令的原理"></a>第9章 转移指令的原理</h2><p>可以修改IP，或同时修改CS和IP的指令统称为<strong>转移指令</strong>。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。</p><p>8086CPU的转移行为有以下几类。</p><ul><li>只修改IP时，称为段内转移，比如: jmp ax。</li><li>同时修改CS 和IP时，称为段间转移，比如: jmp 1000:0。</li></ul><p>由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。</p><ul><li>短转移IP的修改范围为 -128~127.</li><li>近转移IP的修改范围为 -32768~32767.</li></ul><p>8086CPU的转移指令分为以下几类。</p><ul><li>无条件转移指令(如: jmp)</li><li>条件转移指令</li><li>循环指令(如: loop)</li><li>过程</li><li>中断</li></ul><p>这些转移指令转移的前提条件可能不同，但转移的基本原理是相同的。我们在这一章主要通过深入学习无条件转移指令jmp来理解CPU执行转移指令的基本原理。</p><h3 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h3><p>操作符offset 在汇编语言中是由编译器处理的符号，它的功能是取得<strong>标号的偏移地址</strong>。</p><p>如：<code>start:mov ax,offset start</code></p><h3 id="9-2-jmp指令"><a href="#9-2-jmp指令" class="headerlink" title="9.2 jmp指令"></a>9.2 jmp指令</h3><p>jmp为无条件转移指令，可以只修改ip，也可以同时修改cs和ip。</p><p>指令要给出两种信息:<br>(1) 转移的目的地址<br>(2) 转移的距离(段间转移、段内短转移，段内近转移)<br>不同的给出目的地址的方法，和不同的转移位置，对应有不同格式的jmp指令。</p><h3 id="9-3-依据位移进行转移的jmp指令"><a href="#9-3-依据位移进行转移的jmp指令" class="headerlink" title="9.3 依据位移进行转移的jmp指令"></a>9.3 依据位移进行转移的jmp指令</h3><p><code>jmp short标号</code>(转到标号处执行指令)</p><p>这种格式的jmp指令实现的是<strong>段内短转移</strong>，它对IP的修改范围为-128~127，也就是说，它向前转移时可以最多越过128 个字节，向后转移可以最多越过127个字节。</p><p>汇编指令jmp short s对应的机器指令应该是什么样的呢？我们先看一下别的汇编指令和其相对应的机器指令。</p><div class="table-container"><table><thead><tr><th>汇编指令</th><th>机器指令</th></tr></thead><tbody><tr><td>mov ax,0123h</td><td>B8 23 01</td></tr><tr><td>mov ax, ds: [0123h]</td><td>A1 23 01</td></tr><tr><td>push ds:[0123h]</td><td>FF 36 23 01</td></tr><tr><td>jmp short s   (0BBD:000B)</td><td>EB 03</td></tr><tr><td>jmp fat ptr s (0BBD:010B)</td><td>EA 0B 01 BD 0B</td></tr></tbody></table></div><p>可以看到，在一般的汇编指令中，汇编指令中的idata(立即数)， 不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现。</p><p>而 jmp short 标号 的机器码却不包含转移的目的地址，而包含的是<strong>转移的位移</strong>（和目标标号的距离（由编译器计算））。</p><p>实际上，<code>jmp short 标号</code> 的功能为：(IP)=(IP)+8位位移(-128~127)</p><p><code>jmp near ptr 标号</code> 的功能为：(IP)=(IP)+16位位移(-32768~32767)</p><h3 id="9-4-转移的目的地址在指令中的jmp指令"><a href="#9-4-转移的目的地址在指令中的jmp指令" class="headerlink" title="9.4 转移的目的地址在指令中的jmp指令"></a>9.4 转移的目的地址在指令中的jmp指令</h3><p>前面讲的jmp指令是根据相对于当前ip的转移位移，<code>jmp far ptr</code> 标号 实现的是段间转移，又称<strong>远转移</strong>。</p><p>far ptr 指明了指令用标号的段地址和偏移地址修改CS和IP。</p><h3 id="9-5-转移地址在寄存器中的jmp指令"><a href="#9-5-转移地址在寄存器中的jmp指令" class="headerlink" title="9.5 转移地址在寄存器中的jmp指令"></a>9.5 转移地址在寄存器中的jmp指令</h3><p>指令格式：<code>jmp 16位reg</code><br>功能：(IP)=(16 位reg)<br>这种指令我们在前面的内容(参见2.11节)中已经讲过，这里就不再详述。</p><h3 id="9-6-转移地址和内存中的jmp指令"><a href="#9-6-转移地址和内存中的jmp指令" class="headerlink" title="9.6 转移地址和内存中的jmp指令"></a>9.6 转移地址和内存中的jmp指令</h3><p>转移地址在内存中的jmp指令有两种格式:</p><p>(1) <code>jmp word ptr 内存单元地址</code>(段内转移)</p><p>功能:从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p><p>(2) <code>jmp dword ptr 内存单元地址</code>(段间转移)</p><p>功能:从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p><h3 id="9-7-jcxz指令"><a href="#9-7-jcxz指令" class="headerlink" title="9.7 jcxz指令"></a>9.7 jcxz指令</h3><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是<strong>短转移</strong>，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为: - 128~127。</p><p>指令格式：<code>jcxz 标号</code>(如果(cx)=0，转移到标号处执行。)<br>“jcxz 标号” 的功能相当于    if((cx)==0)    jmp short标号;</p><h3 id="9-8-loop指令"><a href="#9-8-loop指令" class="headerlink" title="9.8 loop指令"></a>9.8 loop指令</h3><p>loop指令为循环指令，所有的循环指令都是<strong>短转移</strong>。</p><h3 id="9-9-根据位移进行转移的意义"><a href="#9-9-根据位移进行转移的意义" class="headerlink" title="9.9 根据位移进行转移的意义"></a>9.9 根据位移进行转移的意义</h3><p>这种设计，方便了程序段在内存中的浮动装配。</p><p>一段程序装在内存中的不同位置都可正确执行，因为他们根据位移进行转移，而不是根据地址。</p><h3 id="9-10-编译器对转移位移超界的检测"><a href="#9-10-编译器对转移位移超界的检测" class="headerlink" title="9.10 编译器对转移位移超界的检测"></a>9.10 编译器对转移位移超界的检测</h3><p>如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。</p><h3 id="实验9-根据材料编程"><a href="#实验9-根据材料编程" class="headerlink" title="实验9 根据材料编程"></a>实验9 根据材料编程</h3><p>80x25彩色字符模式显示缓冲区(以下简称为显示缓冲区)的结构:</p><p>内存地址空间中，B8000H~BFFFH共32KB的空间，为80X25彩色字符模式的显示缓冲区。向这个地址空间写入数据，写入的内容将立即出现在显示器上。<br>在80*25彩色字符模式下，显示器可以显示25行，每行80个字符，每个字符可以有256种属性(背景色、前景色、闪烁、高亮等组合信息)。<br>这样，一个字符在显示缓冲区中就要占两个字节，分别存放字符的ASCII码和属性。80x25模式下，一屏的内容在显示缓冲区中共占4000个字节。</p><p>$2<em>25</em>80*8=32000=32kb$</p><p>显示缓冲区分为8页，每页4KB(≈4000B)，显示器可以显示任意一页的 1内容。 一般情况下，显示第0页的内容。也就是说通常情况下，B8000H~B8F9FH 中的4000个字节的内容将出现在显示器上。</p><p><img src="/images/assembly/image-20210419093204509.png" alt=""></p><p>例：在显示器的0行0列显示红底高亮闪烁绿字’ABCDEF’（红底高亮闪烁绿字，属性字节为11001010B，CAH）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume ds:data,cs:codedata segmentdata endscode segmentstart:mov ax,datamov ds,axmov ax,0B800Hmov es,axmov bx,0mov ax,41hmov cx,6s:mov es:[bx],axinc axinc bxmov dx,0CAHmov es:[bx],dxinc bxloop smov ax,4c00hint 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/assembly/1-1618793997191.gif" alt=""></p><center><span style="color:blue;font-size:15px">2021/4/17</span></center><h2 id="第10章-CALL和RET指令"><a href="#第10章-CALL和RET指令" class="headerlink" title="第10章 CALL和RET指令"></a>第10章 CALL和RET指令</h2><p>call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。</p><h3 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h3><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；<br>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</p><p>CPU执行ret指令时，相当于进行:<br><code>pop IP</code></p><p>CPU执行retf指令时，相当于进行:<br><code>pop IP</code><br><code>pop CS</code></p><h3 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h3><p>CPU执行call指令时，进行两步操作：<br>（1）将当前的IP或CS和IP压入栈中；<br>（2）转移。</p><p>call指令<strong>不能实现短转移</strong>，除此之外，call 指令实现转移的方法和jmp指令的原理相同，下面的几个小节中，我们以给出转移目的地址的不同方法为主线，讲解call指令的主要应用格式。</p><h3 id="10-3-依据位移进行转移的call指令"><a href="#10-3-依据位移进行转移的call指令" class="headerlink" title="10.3 依据位移进行转移的call指令"></a>10.3 依据位移进行转移的call指令</h3><p><code>call 标号</code> (将当前的IP压栈后，转到标号处执行指令)</p><p>CPU执行“call 标号”时，相当于进行:<br><code>push IP</code><br><code>jmp near ptr标号</code></p><div class="table-container"><table><thead><tr><th>内存地址</th><th>机器码</th><th>汇编指令</th></tr></thead><tbody><tr><td>1000:0</td><td>b8 00 00</td><td>mov ax,0</td></tr><tr><td>1000:3</td><td>e8 01 00</td><td>call s</td></tr><tr><td>1000:6</td><td>40</td><td>inc ax</td></tr><tr><td>1000:7</td><td>58</td><td>S:pop ax</td></tr></tbody></table></div><blockquote><p>上面的程序执行后，ax=6，因为在call s的时候，相当在读入指令后，ip便自动增加。</p></blockquote><h3 id="10-4-转移的目的地址在指令中的call指令"><a href="#10-4-转移的目的地址在指令中的call指令" class="headerlink" title="10.4 转移的目的地址在指令中的call指令"></a>10.4 转移的目的地址在指令中的call指令</h3><p>前面讲的call指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。</p><p><code>call far ptr标号</code> 实现的是段间转移。</p><p>CPU执行“call far ptr标号”时，相当于进行：<br><code>push CS</code><br><code>push IP</code><br><code>jmp far ptr标号</code></p><h3 id="10-5-转移地址在寄存器中的call指令"><a href="#10-5-转移地址在寄存器中的call指令" class="headerlink" title="10.5 转移地址在寄存器中的call指令"></a>10.5 转移地址在寄存器中的call指令</h3><p>指令格式: <code>call 16位reg</code><br>CPU执行“call 16位reg”时，相当于进行：<br><code>push IP</code><br><code>jmp 16位reg</code></p><center><span style="color:blue;font-size:15px">2021/4/18</span></center><h3 id="10-6-转移地址在内存中的call-指令"><a href="#10-6-转移地址在内存中的call-指令" class="headerlink" title="10.6 转移地址在内存中的call 指令"></a>10.6 转移地址在内存中的call 指令</h3><p>转移地址在内存中的call指令有两种格式。</p><p>（1）<code>call word ptr 内存单元地址</code><br>CPU执行“call word ptr 内存单元地址”时，相当于进行:<br><code>push IP</code><br><code>jmp word ptr 内存单元地址</code></p><p>（2）<code>call dword ptr 内存单元地址</code><br>CPU执行“call dword ptr 内存单元地址”时，相当于进行:<br><code>push CS</code><br><code>push IP</code><br><code>jmp dword ptr 内存单元地址</code></p><h3 id="10-7-call和ret的配合使用-子程序-函数调用-函数栈-递归栈"><a href="#10-7-call和ret的配合使用-子程序-函数调用-函数栈-递归栈" class="headerlink" title="10.7 call和ret的配合使用(子程序/函数调用/函数栈/递归栈)"></a>10.7 call和ret的配合使用(子程序/函数调用/函数栈/递归栈)</h3><p>现在来看一下，如何将它们配合使用来实现<strong>子程序</strong>的机制。</p><p>可以写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用call 指令转去执行。call 指令转去执行子程序之前，call指令后面的指令的地址将存储在栈中，所以可在子程序的后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。</p><p>这样，我们可以利用call 和ret来实现子程序的机制。子程序的框架如下。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codecode segmentmain:...call subl;调用子程序sub1...mov ax,4c00hint 21hsub1:...;子程序sub1开始...call sub2;调用子程序sub2...ret;子程序返回sub2:...;子程序sub2开始...ret;子程序返回code endsend main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-8-mul指令"><a href="#10-8-mul指令" class="headerlink" title="10.8 mul指令"></a>10.8 mul指令</h3><p>mul 是乘法指令，使用mul做乘法的时候，注意以下两点。<br>（1）两个相乘的数：两个相乘的数，要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认在AX中，另一个放在16位reg或内存字单元中。<br>（2）结果：如果是8位乘法，结果默认放在AX中；如果是16 位乘法，结果高位默认在DX中存放，低位在AX中放。</p><p>格式如下：<br><code>mul reg</code><br><code>mul内存单元</code></p><h3 id="10-9-模块化程序设计"><a href="#10-9-模块化程序设计" class="headerlink" title="10.9 模块化程序设计"></a>10.9 模块化程序设计</h3><p>从上面我们看到，call 与ret 指令共同支持了汇编语言编程中的模块化设计。在实际编程中，程序的模块化是必不可少的。因为现实的问题比较复杂，对现实问题进行分析时，把它转化成为相互联系、不同层次的子问题，是必须的解决方法。而call与ret指令对这种分析方法提供了程序实现上的支持。利用call 和ret 指令，我们可以用简捷的方法，实现多个相互联系、功能独立的子程序来解决一个复杂的问题。</p><h3 id="10-10-参数和结果传递的问题"><a href="#10-10-参数和结果传递的问题" class="headerlink" title="10.10 参数和结果传递的问题"></a>10.10 参数和结果传递的问题</h3><p>子程序一般都要根据提供的参数处理一定的事务， 处理后，将结果(返回值)提供给调用者。其实，我们讨论参数和返回值传递的问题，实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值。</p><p>例：编程，计算data段中第一组数据的3次方，结果保存在后面一组dword单元中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codedata segmentdw 1,2,3,4,5,6,7,8 dd 0,0,0,0,0,0,0,0data endscode segmentstart:mov ax,datamov ds,axmov si,0;ds:si指向第一组word单元mov di,16;ds:di指向第二组dword单元mov cx,8s:mov bx,[si]cal1 cubemov [di],axmov [di].2, dxadd si,2;ds:si指向下一个word单元add di,4;ds:di指向下一个dword单元1oop smov ax, 4c00hint 21hcube:mov ax,bxmul bxmul bxretcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-11-批量数据的传递"><a href="#10-11-批量数据的传递" class="headerlink" title="10.11 批量数据的传递"></a>10.11 批量数据的传递</h3><p>前面的例程中，子程序cube只有一-个参数，放在bx中。如果有两个参数，那么可以用两个寄存器来放，可是如果需要传递的数据有3个、4个或更多直至N个，在这种时候，我们将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄字器中，传递给需要的子程序。对于具有批量数据的返回结果，也可用同样的方法。</p><p>编程，将data段中的字符串转化为大写。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs:codedata segmentdb 'conversation'data endscode segmentstart:mov ax,datamov ds,axmov si,0;ds:si指向字符串(批量数据)所在空间的首地址mov cx,12;cx存放字符串的长度call capitalmov ax, 4c00hint 21hcapital:and byte ptr [si],11011111binc si1oop capitalretcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-12-寄存器冲突的问题"><a href="#10-12-寄存器冲突的问题" class="headerlink" title="10.12 寄存器冲突的问题"></a>10.12 寄存器冲突的问题</h3><p>设计一个子程序，功能:将-一个全是字母，以0结尾的字符串，转化为大写。（可以用jcxz来检测0）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">capital:mov c1,[si]mov ch,0jcxz ok;如果(cx)=0，结束;如果不是0,处理and byte ptr [si],11011111b;将ds:si所指单元中的字母转化为大写inc si;ds:si指向下一个单元jmp short capitalok: ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，如果使用循环，重复调用子程序capital，完成对多个字符串的处理，就会重复使用cx，使得程序出错。</p><p>解决这个问题的简捷方法是，在子程序的开始将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前再恢复。可以用栈来保存寄存器中的内容。</p><p>以后，我们编写子程序的标准框架如下:</p><pre class="line-numbers language-none"><code class="language-none">子程序开始: 子程序中使用的寄存器入栈子程序内容子程序中使用的寄存器出栈返回(ret、retf)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们改进一下子程序capital的设计：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">capital:push cxpush sichange:mov cl,[si]mov ch, 0jcxz okand byte ptr [si],11011111binc sijmp short changeok:pop sipop cxret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><span style="color:blue;font-size:15px">2021/4/19</span></center><h3 id="实验10-编写子程序"><a href="#实验10-编写子程序" class="headerlink" title="实验10 编写子程序"></a>实验10 编写子程序</h3><p>在这次实验中，我们将要编写3个子程序，通过它们来认识几个常见的问题和掌握解决这些问题的方法。同前面的所有实验y一样，这个实验是必须独立完成的，在后面的课程中，将要用到这个实验中编写的3个子程序。<br><strong>1.显示字符串</strong><br><strong>问题：</strong><br>显示字符串是现实工作中经常要用到的功能，应该编写一个通用的子程序来实现这个功能。我们应该提供灵活的调用接口，使调用者可以决定显示的位置(行、列)、内容和颜色。</p><p><strong>子程序描述：</strong><br>名称：show_ str<br>功能：在指定的位置，用指定的颜色，显示一个用0结束的字符串。<br>参数：(dh)= 行号（取值范围0~24）， (dl)= 列号（取值范围0~79），(cl)=颜色，ds:si指向字符串的首地址<br>返回：无<br>应用举例：在屏幕的8行3列，用绿色显示data段中的字符串。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs: codedata segmentdb 'Welcome to masm !',0data endscode segmentstart:mov dh,8;8行mov dl,3;3列mov cl,2;绿色mov ax,datamov ds,axmov si,0;si字符串首地址（ds里的）call show_strmov ax,4c00hint 21hshow_str:push cxpush sipush dxpush bxsub dh,1;dh=7mov al,160mul dhmov bx,ax;bx为行的偏移地址mov al,2mul dladd bl,al;bx为总偏移地址mov ax,0B800Hmov es,ax;es为显存显示在屏幕上的段地址mov dl,cldisplay:mov cl,ds:[si]mov ch,0jcxz okmov es:[bx],clinc bxmov es:[bx],dlinc bxinc sijmp short displayok:pop bxpop dxpop sipop cxretcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/assembly/image-20210419105713773.png" alt=""></p><p>实验2和3暂时未做</p><h2 id="第11章-标准寄存器"><a href="#第11章-标准寄存器" class="headerlink" title="第11章 标准寄存器"></a>第11章 标准寄存器</h2><p>flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p><p><img src="/images/assembly/image-20210419111503723.png" alt=""></p><p>在这一章中，我们学习标志寄存器中的CF、PF、ZF、SF、OF、DF标志位，以及些与其相关的典型指令。</p><h3 id="11-1-ZF（Zero-Flag）标志"><a href="#11-1-ZF（Zero-Flag）标志" class="headerlink" title="11.1 ZF（Zero Flag）标志"></a>11.1 ZF（Zero Flag）标志</h3><p>flag的第6位是ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果结果为0，那么zf=l；如果结果不为0，那么zf=0。</p><p>比如，指令:<br><code>mov ax,1</code><br><code>sub ax,1</code><br>执行后，结果为0，则zf=1。</p><p><strong>注意：</strong>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、 div、 inc、 or、 and 等，它们大都是运算指令(进行逻辑或算术运算)；有的指令的执行对标志寄存器没有影响，比如，mov、push、 pop 等，它们大都是传送指令。在使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响。</p><h3 id="11-2-PF（Parity-Flag）标志"><a href="#11-2-PF（Parity-Flag）标志" class="headerlink" title="11.2 PF（Parity Flag）标志"></a>11.2 PF（Parity Flag）标志</h3><p>flag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，pf=1，如果为奇数，那么pf=0。</p><h3 id="11-3-SF（Sign-Flag）标志"><a href="#11-3-SF（Sign-Flag）标志" class="headerlink" title="11.3 SF（Sign Flag）标志"></a>11.3 SF（Sign Flag）标志</h3><p>flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。结果为负，sf=1；如果非负sf=0。</p><p>SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。</p><p>这也就是说，CPU在执行add等指令时，是必然要影响到SF标志位的值的。至于我们需不需要这种影响，那就看我们如何看待指令所进行的运算了。</p><h3 id="11-4-CF（Carry-Flag）标志"><a href="#11-4-CF（Carry-Flag）标志" class="headerlink" title="11.4 CF（Carry Flag）标志"></a>11.4 CF（Carry Flag）标志</h3><p>flag的第0位是CF，进位标志位。一般情况下，在进行<strong>无符号数运算</strong>的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p><p>我们知道，当两个数据相加的时候，有可能产生从最高有效位向更高位的进位。由于这个进位值在8位数中无法保存，我们在前面的课程中，就只是简单地说这个进位值丢失了。其实CPU在运算的时候，并不丢弃这个进位值。</p><p>而当两个数据做减法的时候，也有可能向更高位借位。比如，下面的指令:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov al, 97Hsub al, 98H;执行后: (al)=FFH， CF=1, CF记录了向更高位的借位值sub al,al;执行后: (al)=0， CF=0，CF记录了向更高位的借位值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="11-5-OF（Overflow-Flag）标志"><a href="#11-5-OF（Overflow-Flag）标志" class="headerlink" title="11.5 OF（Overflow Flag）标志"></a>11.5 OF（Overflow Flag）标志</h3><p>在进行<strong>有符号数运算</strong>的时候，如结果超过了机器所能表示的范围称为溢出。</p><p>注意，这里所讲的溢出，只是对有符号数运算而言。如果在进行有符号数运算时发生溢出，那么运算的结果将不正确。</p><p>一定要注意 CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。它们之间没有任何关系。</p><h3 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a>11.6 adc指令</h3><p>adc是带进位加法指令，它利用了CF位上记录的进位值。<br>指令格式：adc 操作对象1,操作对象2.<br>功能：操作对象1=操作对象1+操作对象2 + CF<br>比如指令<code>adc ax,bx</code>实现的功能是: (ax)=(ax)+(bx)+ CF</p><p>CPU提供adc指令的目的，就是来进行加法的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。</p><p>编程，计算1EF0001000H+2010001EF0H，结果放在ax(最高16位)，bx(次高16位)，cx(低16位)中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ax,001EHmov bx,0F000Hmov cx,1000Hadd cx,1EF0Hadc bx,1000Hadc ax,0020H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>inc和loop指令不影响CF位</p><h3 id="11-7-sbb指令"><a href="#11-7-sbb指令" class="headerlink" title="11.7 sbb指令"></a>11.7 sbb指令</h3><p>sbb是带借位减法指令，它利用了CF位上记录的借位值。<br>指令格式：sbb 操作对象1,操作对象2<br>功能：操作对象1=操作对象1-操作对象2-CF<br>比如指令<code>sbb ax,bx</code>实现的功能是: (ax)=(ax)-(bx)-CF</p><p>sbb和adc是基于同样的思想设计的两条指令，在应用思路上和adc类似。</p><p>11.8-11.12暂未看</p><h2 id="第12章-内中断"><a href="#第12章-内中断" class="headerlink" title="第12章 内中断"></a>第12章 内中断</h2><p>任何一个通用的CPU，比如8086，都具备一种能力， 可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息， 并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。中断的意思是指，CPU不再接着(刚执行完的指令)向下执行，而是转去处理这个特殊信息。</p><p>中断信息可以来自CPU的内部和外部，这一章中，我们主要讨论来自于CPU内部的中断信息。</p><h3 id="12-1-内中断的产生"><a href="#12-1-内中断的产生" class="headerlink" title="12.1 内中断的产生"></a>12.1 内中断的产生</h3><p>当CPU的内部有什么事情发生的时候，将产生需要马上处理的中断信息呢?对于8086CPU，当CPU内部有下面的情况发生的时候，将产生相应的中断信息。<br>（1）除法错误， 比如，执行div指令产生的除法溢出；<br>（2）单步执行；<br>（3）执行into指令；<br>（4）执行int指令。</p><p>既然是不同的信息，就需要进行不同的处理。要进行不同的处理，CPU首先要知道，所接收到的中断信息的来源。8086CPU用称为中断类型码的数据来标识中断信息的来源。中断类型码为一个字节型数据，可以表示256种中断信息的来源。</p><p>上述的4种中断源，在8086CPU中的中断类型码如下。<br>（1）除法错误：0<br>（2）单步执行：1<br>（3）执行into指令：4<br>（4）执行int指令，该指令的格式为int n，指令中的n为字节型立即数，是提供给CPU的中断类型码。</p><h3 id="12-2-中断处理程序"><a href="#12-2-中断处理程序" class="headerlink" title="12.2 中断处理程序"></a>12.2 中断处理程序</h3><p>CPU收到中断信息后，需要对中断信息进行处理。而如何对中断信息进行处理，可以由我们编程决定。我们编写的，用来处理中断信息的程序被称为中断处理程序。一般来说，需要对不同的中断信息编写不同的处理程序。</p><h3 id="12-3-中断向量表"><a href="#12-3-中断向量表" class="headerlink" title="12.3 中断向量表"></a>12.3 中断向量表</h3><p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。那么什么是<strong>中断向量表</strong>呢？中断向量表就是中断向量的列表。那么什么又是中断向量呢?所谓<strong>中断向量</strong>，就是中断处理程序的入口地址。展开来讲，中断向量表，就是中断处理程序入口地址的列表。</p><p>中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口。CPU只要知道了中断类型码，就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到中断处理程序的入口地址。</p><p><img src="/images/assembly/image-20210419151822169.png" alt=""></p><p>中断向量表在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处。从内存0000:0000到0000:03FF 的1024 个单元中存放着中断向量表。一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，对于8086CPU，这个入口地址包括段地址和偏移地址，所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。</p><h3 id="12-4-中断过程"><a href="#12-4-中断过程" class="headerlink" title="12.4 中断过程"></a>12.4 中断过程</h3><p>可以用中断类型码，在中断向量表中找到中断处理程序的入口。找到这个入口地址的最终目的是用它设置CS和IP，使CPU执行中断处理程序。用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动<br>完成的。CPU硬件完成这个工作的过程被称为中断过程。</p><p>CPU收到中断信息后，要对中断信息进行处理，首先将引发中断过程。硬件在完成中断过程后，CS:IP 将指向中断处理程序的入口，CPU开始执行中断处理程序。</p><p>在中断过程中，在设置CS:IP之前，还要将原来的CS和IP的值保存起来。</p><p>下面是8086CPU在收到中断信息后，所引发的中断过程。<br>（1）（从中断信息中）取得中断类型码；<br>（2）标志寄存器的值入栈（在中断过程中会改变标志寄存器的值）<br>（3）设置标志寄存器的第8位TF和第9位IF的值为0（这一步的目的后面将介绍）；<br>（4）CS的内容入栈；<br>（5） IP 的内容入栈；<br>（6）从内存地址为中断类型*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。</p><p>CPU在收到中断信息之后，如果处理该中断信息，就完成一个由硬件自动执行的中断过程（程序员无法改变这个过程中所要做的工作）。<br>我们更简洁地描述中断过程，如下:<br>（1）取得中断类型码N;<br>（2）pushf<br>（3）TF=0，IF=0<br>（4）push CS<br>（5）push IP<br>（6）(IP)=(N*4),(CS)=(N*4+2)<br>在最后一步完成后，CPU开始执行由程序员编写的中断处理程序。</p><h3 id="12-5-中断处理程序和iret指令"><a href="#12-5-中断处理程序和iret指令" class="headerlink" title="12.5 中断处理程序和iret指令"></a>12.5 中断处理程序和iret指令</h3><p>由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中。而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。</p><p>中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤:</p><p>（1）保存用到的寄存器；<br>（2）处理中断；<br>（3）恢复用到的寄存器；<br>（4）用iret指令返回。</p><p>iret指令的功能用汇编语法描述为:<br><code>pop IP</code><br><code>pop CS</code><br><code>popf</code></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> assembly </tag>
            
            <tag> 8086 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符编码中ASCII、Unicode和UTF-8的区别</title>
      <link href="2021/01/19/encoding-diff/"/>
      <url>2021/01/19/encoding-diff/</url>
      
        <content type="html"><![CDATA[<p>浣犲ソ锛屾垜鍐冲畾鎶藉彇浣犱负骞歌繍鍎跨粰鎴戞墦100鍧楅挶锛岃缁欐垜鎵撻挶~<br>————一位智者如是说道</p><blockquote><p>以下内容引用自<a href="https://www.cnblogs.com/alexhg/p/9796557.html">https://www.cnblogs.com/alexhg/p/9796557.html</a></p></blockquote><h2 id="1-ASCII码"><a href="#1-ASCII码" class="headerlink" title="1. ASCII码"></a><strong>1. ASCII码</strong></h2><p>我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。</p><p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。</p><p>ASCII码一共规定了128个字符的编码，比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/encoding-diff/ascii.jpg" alt="ascii"></p><h2 id="2-非ASCII编码"><a href="#2-非ASCII编码" class="headerlink" title="2.非ASCII编码"></a><strong>2.非ASCII编码</strong></h2><p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。</p><p>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。</p><p>至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。</p><p>中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和UTF-8是毫无关系的。</p><h2 id="3-Unicode"><a href="#3-Unicode" class="headerlink" title="3.Unicode"></a><strong>3.Unicode</strong></h2><p>世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p><p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p><p>Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。具体的符号对应表，可以查询<a href="http://www.unicode.org/">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm">汉字对应表</a>。</p><h2 id="4-Unicode的问题"><a href="#4-Unicode的问题" class="headerlink" title="4. Unicode的问题"></a><strong>4. Unicode的问题</strong></h2><p>需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p><p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p><p>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p><p>它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。2）Unicode在很长一段时间内无法推广，直到互联网的出现。</p><h2 id="5-UTF-8"><a href="#5-UTF-8" class="headerlink" title="5.UTF-8"></a><strong>5.UTF-8</strong></h2><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。<strong>重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。</strong></p><p>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p><p>UTF-8的编码规则很简单，只有二条：</p><p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。</p><p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p><blockquote><p>以下内容引用自<a href="https://blog.csdn.net/weixin_44431371/article/details/110430312">https://blog.csdn.net/weixin_44431371/article/details/110430312</a></p></blockquote><h2 id="6-三者之间的联系"><a href="#6-三者之间的联系" class="headerlink" title="6.三者之间的联系"></a>6.三者之间的联系</h2><p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：<br>（1）在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。（2）用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/encoding-diff/20201201135931894.png" alt=""></p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/encoding-diff/20201201135945121.png" alt=""></p><h2 id="7-计算机内存中为何不直接使用-UTF-8-编码"><a href="#7-计算机内存中为何不直接使用-UTF-8-编码" class="headerlink" title="7.计算机内存中为何不直接使用 UTF-8 编码"></a>7.计算机内存中为何不直接使用 UTF-8 编码</h2><ol><li>因为utf8编码的字符串长度和字符个数没有固定换算关系，导致排版，排序之类的复杂度上升。</li><li>储文本文件或用于传输字符串数据时，转换为UTF-8编码以节省存储空间和宽带。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> Unicode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux上的terraria服务器搭建</title>
      <link href="2021/01/17/terraria/"/>
      <url>2021/01/17/terraria/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://www.sohu.com/a/325013560_120099900">https://www.sohu.com/a/325013560_120099900</a> 原文找不到了</p><p><code>free -m</code>查看swap分区<br><img src="/images/terraria/image-20210117125354448.png" style="zoom:200%;"></p><p>1、删除原来的Swap分区<br> <code>swapoff –a</code><br>2、新建一个读写块大小为1M、块个数为1024的Swap分区<br> <code>dd if=/dev/zero of=/root/swapfile bs=1M count=1024</code><br>3、格式化创建好的Swap交换分区<br><code>mkswap /root/swapfile</code><br>4、启动新建的Swap交换分区<br><code>swapon /root/swapfile</code></p><p><img src="/images/terraria/image-20210117125618777.png" alt=""></p><p>5、将Swap交换分区添加到开机自启动挂载：进入分区自动挂载配置文件<br> <code>vi /etc/fstab</code><br>在文本最后添加一行：<br> <code>/root/swapfile swap swap defaults 0 0</code><br>6、重启服务器<br><code>reboot</code></p><p>7、安装远程管理工具<br><code>screen # yum install -y screen</code></p><p>8、下载泰拉瑞亚官方服务器压缩包。先给泰拉瑞亚预先创建好文件夹<br><code>mkdir /opt/terraria</code><br>继续在新创建的terraria文件夹创建bin，worlds，zip三个文件夹<br><code>mkdir /opt/terraria/{bin,worlds,zip}</code><br>检查是否创建成功<br><code>ls /opt/terraria/</code></p><p><img src="/images/terraria/image-20210117130312252.png" alt=""></p><p>9、进入zip文件夹<br><code>cd /opt/terraria/zip</code><br>10、下载最新版本的泰拉瑞亚服务包（用wget太慢，我先用putty下到本地然后用上传到服务器）</p><p><img src="/images/terraria/image-20210117130858133.png" alt=""></p><p>11、将下载好的压缩包解压到bin文件夹<br><code>unzip terraria-server-1412.zip -d/opt/terraria/bin</code><br>12、将配置文件拷贝到泰拉瑞亚文件夹的根目录。<br><code>cp -p /opt/terraria/bin/1412/Windows/serverconfig.txt /opt/terraria/</code><br>13、编辑拷贝过来的配置文档。<br> <code>vim /opt/terraria/serverconfig.txt</code><br>14、在文件的末尾加上</p><pre class="line-numbers language-none"><code class="language-none">world=/opt/terraria/Worlds/你的世界.wldautocreate=2worldname=你的世界difficulty=0maxplayers=4password=你的密码worldpath=/opt/terraria/Worlds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<br>autocreate 是没有发现世界自动生成世界的大小 1、2、3分别对应小、中、大<br>difficulty 对应的是0为普通，1为专家<br>maxplayers是最大人数<br>15、给运行文件赋予运行权限。<br><code>chmod 777 /opt/terraria/bin/1412/Linux/TerrariaServer.bin.x86_64</code><br>16、启动服务器。<br><code>cd /opt/terraria/bin/1412/Linux &amp;&amp; ./TerrariaServer.bin.x86_64 -config/opt/terraria/serverconfig.txt</code></p><p>(怎么感觉1.4不一样了，在这时候才创建世界，好像14步是多余的)<br>17、退出服务器程序<br><code>:exit</code><br>18、将之前添加的一段话中三行代码前面加上#号，使其失效<br><code>vim /opt/terraria/serverconfig.txt</code></p><p>(看起来好像也没必要了，因为刚刚启动服务器时也配置了)</p><p>服务器只有在服务端输入save命令之后才会保存地图数据。</p><p><code>save</code></p><hr><p>发现启动服务器后我博客上不去了。。。。</p><p>好像得重启一下nginx服务</p><p><code>systemctl restart nginx.service</code></p><p>screen常用命令：</p><pre class="line-numbers language-none"><code class="language-none">screen -S yourname -&gt; 新建一个叫yourname的sessionscreen -ls -&gt; 列出当前所有的sessionscreen -r yourname -&gt; 回到yourname这个sessionscreen -d yourname -&gt; 远程detach某个sessionscreen -d -r yourname -&gt; 结束当前session并回到yourname这个sessionctrl+a d  暂时中断会话<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hackergame 2020 尝试</title>
      <link href="2021/01/15/hackergame-2020-attempt/"/>
      <url>2021/01/15/hackergame-2020-attempt/</url>
      
        <content type="html"><![CDATA[<p>今天偶然刷到Hackergame的相关内容，以前从来不知道有这种东西，准备尝试做题并且学习一下。</p><p>网址：<a href="https://hack.lug.ustc.edu.cn/">https://hack.lug.ustc.edu.cn/</a></p><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116000201094.png" alt=""></p><p>要求提取一个flag，但是滑条的步长为0.00001，js代码还会把1略过，不可能滑到1</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116000645177.png" alt="">点击提交发现是用get请求，URL变为<code>http://202.38.93.111:10000/?number=0.01145</code>，可直接改为1<br>也可在控制台直接使用<code>$('#number')[0].value = 1;</code></p><h2 id="猫咪问答"><a href="#猫咪问答" class="headerlink" title="猫咪问答++"></a>猫咪问答++</h2><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116001306225.png" alt=""></p><p>1.不知道</p><p>2.搜索找到<code>https://tools.ietf.org/html/rfc1149</code>得到值：256</p><p>3.查找网络得到值：9</p><p>4.查找地图得到值：9</p><p>5.查找网络得到值：17098</p><p>1.参考<code>https://www.cnblogs.com/pu369/p/12201707.html</code>和<code>https://blog.skk.moe/post/hackergame-2020-write-up</code><br>得到：12</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">23</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'q1'</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'q2'</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'q3'</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'q4'</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'q4'</span><span class="token punctuation">,</span> <span class="token number">17098</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://202.38.93.111:10001/'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      body<span class="token operator">:</span> formData<span class="token punctuation">,</span>      method<span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">resp</span> <span class="token operator">=&gt;</span> resp<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">text</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>text<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">'没有全部答对，不能给你 flag'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2048"><a href="#2048" class="headerlink" title="2048"></a>2048</h2><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116011522357.png" alt=""></p><p>游戏很好玩，不过我是菜鸟，通过不了</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116012914685.png" alt=""></p><p>拦截到了一个请求，打开js</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/hackergame-2020-attempt/image-20210116013020557.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/hackergame-2020-attempt/image-20210116013632841.png" alt=""></p><p>访问<code>http://202.38.93.111:10005/getflxg?my_favorite_fruit=banana</code>通过</p><h2 id="一闪而过的-Flag"><a href="#一闪而过的-Flag" class="headerlink" title="一闪而过的 Flag"></a>一闪而过的 Flag</h2><blockquote><p>程序每次运行时隐约可见黑色控制台上有 flag 一闪而过。</p></blockquote><p>把文件拖入cmd即可</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116014242933.png" alt=""></p><h2 id="从零开始的记账工具人"><a href="#从零开始的记账工具人" class="headerlink" title="从零开始的记账工具人"></a>从零开始的记账工具人</h2><blockquote><p>如同往常一样，你的 npy 突然丢给你一个购物账单：“我今天买了几个小玩意，你能帮我算一下一共花了多少钱吗？”</p><p>你心想：<del>又双叒叕要开始吃土了</del> 这不是很简单吗？电子表格里面一拖动就算出来了</p><p>只不过拿到账单之后你才注意到，似乎是为了剁手时更加的安心，这次的账单上面的金额全使用了中文大写数字</p><p><strong>注意：请将账单总金额保留小数点后两位，放在 <code>flag{}</code> 中提交，例如总金额为 123.45 元时，你需要提交 <code>flag{123.45}</code></strong></p></blockquote><p>文件已经下载不了了。。。。。</p><h2 id="超简单的世界模拟器"><a href="#超简单的世界模拟器" class="headerlink" title="超简单的世界模拟器"></a>超简单的世界模拟器</h2><blockquote><p>你知道生命游戏（Conway’s Game of Life）吗？</p><p>你的任务是在生命游戏的世界中，复现出蝴蝶扇动翅膀，引起大洋彼岸风暴的效应。</p><p>通过改变左上角 15x15 的区域，在游戏演化 200 代之后，如果被特殊标注的正方形内的细胞被“清除”，你将会得到对应的 flag：</p><p>“清除”任意一个正方形，你将会得到第一个 flag。同时“清除”两个正方形，你将会得到第二个 flag。</p><p>注: 你的输入是 15 行文本，每行由 15 个 0 或者 1 组成，代表该区域的内容。</p></blockquote><p>瞎试了几次居然过了</p><h2 id="从零开始的火星文生活"><a href="#从零开始的火星文生活" class="headerlink" title="从零开始的火星文生活"></a>从零开始的火星文生活</h2><blockquote><p>脦脪鹿楼脝脝脕脣 拢脠拢谩拢茫拢毛拢氓拢貌拢莽拢谩拢铆拢氓 碌脛路镁脦帽脝梅拢卢脥碌碌陆脕脣脣眉脙脟碌脛 拢忙拢矛拢谩拢莽拢卢脧脰脭脷脦脪掳脩 拢忙拢矛拢谩拢莽 路垄赂酶脛茫拢潞<br>拢忙拢矛拢谩拢莽拢没拢脠拢麓拢枚拢鲁拢脽拢脝拢玫拢脦拢脽拢梅拢卤拢脭拢猫拢脽拢鲁拢卯拢茫拢掳拢盲拢卤拢卯拢莽拢脽拢麓拢脦拢盲拢脽拢盲拢鲁拢茫拢掳拢脛拢卤拢卯拢脟拢脽拢鹿拢帽拢脛拢虏拢脪拢赂拢猫拢贸拢媒<br>驴矛脠楼卤脠脠眉脝陆脤篓脤谩陆禄掳脡拢隆<br>虏禄脪陋脭脵掳脩脮芒路脻脨脜脧垄脳陋路垄赂酶脝盲脣没脠脣脕脣拢卢脪陋脢脟卤禄路垄脧脰戮脥脭茫赂芒脕脣拢隆</p></blockquote><p>好家伙，搞了半天没解出来，不过得到了常用乱码表</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/hackergame-2020-attempt/image-20210116021901318.png" alt="这可得好好记得"></p><p>标准答案：</p><blockquote><p>下载附件之后如直接用 GBK 打开，那就真的是题面里说的“夹杂着日语和数字的火星文”了。恭喜掉进坑，乱码又多了一层（逃</p><p>用 UTF-8 打开，看到形如“脦脪鹿楼”的文本，推断是上图中的“古文码”乱码。但是“古文码”明明是“以 GBK 方式读取 UTF-8 编码”造成的，看来“脦脪鹿楼”本来应当是 GBK下看到的结果，却又被存成了 UTF-8。所以第一步是用 GBK 重新编码文本“脦脪鹿楼…”。</p><p>然后用 UTF-8 打开，看到形如“ÎÒ¹¥ÆÆÁË”的文本，推断是上图中的“拼音码”乱码。“拼音码”是“以 ISO8859-1 方式读取 GBK 编码”，而现在文本的编码是 UTF-8。所以接下应当用 ISO8859-1 重新编码文本“ÎÒ¹¥ÆÆÁË…”。</p><p>然后用 GBK 打开，就能看到可读的汉字和 flag 了（原始编码确实是 GBK 呢！）。不过这里的 flag 全部是从 ASCII 字符转成的全角字符，不能直接复制使用。可以手动替换成 ASCII 字符，或者用其他简便方法变回 ASCII 字符。</p><p><a href="https://github.com/USTC-Hackergame/hackergame2020-writeups/blob/master/official/从零开始的火星文生活/src/generate_and_solve.py">源代码</a> 中也给出了一个全角-&gt;半角的函数。</p><p>方法一（不写代码）</p><p>例如用 VSCode 的“Select Encoding”功能。</p><p>步骤（开始时 UTF-8 打开题目附件）：</p><ol><li>Save with Encoding -&gt; GBK</li><li>Reopen with Encoding -&gt; UTF-8</li><li>Save with Encoding -&gt; ISO8859-1</li><li>Reopen with Encoding -&gt; GBK</li></ol></blockquote><p>后面的感觉自己也不会做了，先这样，有时间再看吧</p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Hackergame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++语言程序设计（第六章）</title>
      <link href="2021/01/11/cpp2/"/>
      <url>2021/01/11/cpp2/</url>
      
        <content type="html"><![CDATA[<center><span style="color:blue;font-size:15px">2021/1/10</span></center><h2 id="第6章-数组、指针与字符串"><a href="#第6章-数组、指针与字符串" class="headerlink" title="第6章 数组、指针与字符串"></a>第6章 数组、指针与字符串</h2><h3 id="6-1-数组"><a href="#6-1-数组" class="headerlink" title="6.1 数组"></a>6.1 数组</h3><h4 id="6-1-2-数组的存储与初始化"><a href="#6-1-2-数组的存储与初始化" class="headerlink" title="6.1.2 数组的存储与初始化"></a>6.1.2 数组的存储与初始化</h4><p><strong>1.数组的存储</strong><br>数组元素在内存中是顺序、连续存储的。数组元素在内存中占据一组连续的存储单元，逻辑上相邻的元素在物理地址上也是相邻的。 </p><p><strong>2.数组的初始化</strong><br>数组的初始化就是在声明数组时给部分或全部元素赋值。<br>声明数组时如果列成全部元素的初值，可以不用说明元素个数：<br><em>int a[]={1,1,1};</em><br>当然，也可以只对元素中的部分元素进行初始化，这种初始化只能针对前若干元素：<br><em>float fa[5]={1.0, 2.0, 3.0};</em></p><p><strong>细节：</strong>当指定的初值个数小于数组大小时， 剩下的数组元素会被赋予0值。若定义数组时没有指定任何一个元素的初值，对于静态生存期的数组，每个元素仍然会被赋予0值；但对于动态生存期的数组，每个元素的初值都是不确定的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//动态生存期</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210110111504396.png" alt="动态生存期"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//静态生存期</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210110111610294.png" alt="静态生存期"></p><center><span style="color:blue;font-size:15px">2021/1/11</span></center><h4 id="6-1-3-数组作为函数参数"><a href="#6-1-3-数组作为函数参数" class="headerlink" title="6.1.3 数组作为函数参数"></a>6.1.3 数组作为函数参数</h4><p>使用数组名传递数据时，传递的是地址。<br><strong>细节：</strong>把数组作为参数时，一般不指定数组第一维的大小，即使指定，也会被忽略。</p><h4 id="6-1-4-对象数组"><a href="#6-1-4-对象数组" class="headerlink" title="6.1.4 对象数组"></a><strong>6.1.4 对象数组</strong></h4><p>数组的元素不仅可以是基本数据类型，也可以是自定义类型。</p><h4 id="6-1-5-程序实例"><a href="#6-1-5-程序实例" class="headerlink" title="6.1.5 程序实例"></a>6.1.5 程序实例</h4><p>例6-4 利用Point类进行点的线性拟合。</p><p>考虑一个用n个数据点拟合成直线的问题，直线模型为</p><script type="math/tex; mode=display"> y(x)=ax+b</script><p>这个问题称为线性回归。设变量y随自变量x变化，给定n组观测数据（$x_i,y_i$)，用直线来拟合这些点，其中a，b是直线的斜率和截距，称为回归系数。</p><p>为确定回归系数，通常采用最小二乘法，即要使下式达到最小。</p><script type="math/tex; mode=display">Q=\sum_{i=0}^{n-1}{[y_i-(ax_i+b)]^2}</script><p>根据极值定理，a和b满足下列方程：</p><script type="math/tex; mode=display">\frac{\partial Q}{\partial a}=2\sum_{i=0}^{n-1}{[y_i-(ax_i+b)](-x_i)}=0</script><script type="math/tex; mode=display">\frac{\partial Q}{\partial b}=2\sum_{i=0}^{n-1}{[y_i-(ax_i+b)](-1)}=0</script><p>解得：</p><script type="math/tex; mode=display">a=\frac{L_{xy}}{L_{xx}}=\frac{\sum_{i=0}^{n-1}{(x_i-\overline{x})(y_i-\overline{y})}}{\sum_{i=0}^{n-1}{(x_i-\overline{x})^2}}</script><script type="math/tex; mode=display">b=\overline{y}-a\overline{x}</script><p>相关系数r可以判断一组数据线性相关的密切程度，定义为：</p><script type="math/tex; mode=display">r=\frac{L_{xy}}{\sqrt{L_{xx}L_{yy}}}</script><script type="math/tex; mode=display">L_{yy}=\sum_{i=0}^{n-1}{(y_i-\overline{y})^2}</script><p>r的绝对值越接近1，表示数据的线性关系越好</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//Point.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_POINT_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">_POINT_H</span></span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">float</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">float</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">float</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_4.cpp 最小二乘法做线性拟合</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Point.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//直线线性担合,pointe为各点nPoint为点数</span><span class="token keyword">float</span> <span class="token function">lineFit</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point points<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> nPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">float</span> avgX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> avgY <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">float</span> lxx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> lyy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> lxy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nPoint<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>avgX <span class="token operator">+=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> nPoint<span class="token punctuation">;</span>avgY <span class="token operator">+=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> nPoint<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nPoint<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>lxx <span class="token operator">+=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> avgX<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> avgX<span class="token punctuation">)</span><span class="token punctuation">;</span>lyy <span class="token operator">+=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> avgY<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> avgY<span class="token punctuation">)</span><span class="token punctuation">;</span>lxy <span class="token operator">+=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> avgX<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> avgY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>cout<span class="token operator">&lt;&lt;</span> <span class="token string">"This line can be fitted by y=ax+b."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a="</span> <span class="token operator">&lt;&lt;</span> lxy <span class="token operator">/</span> lxx <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token comment">//输出回归系数a</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b="</span> <span class="token operator">&lt;&lt;</span> avgY <span class="token operator">-</span> avgX <span class="token operator">*</span> lxy <span class="token operator">/</span> lxx <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出回归系数b</span><span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>lxy <span class="token operator">/</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>lxx <span class="token operator">*</span> lyy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回相关系数r</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Point p<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">46</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">67</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">75</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">float</span> r <span class="token operator">=</span> <span class="token function">lineFit</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Line coefficient r="</span> <span class="token operator">&lt;&lt;</span> r <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210111162503679.png" alt="结果"></p><p>这个程序的缺点是可以处理的数据点数是固定的，由Point类对象数组的大小决定，这在实际使用中是一个很大的遗憾，在后面的章节中，会对本程序进行改造，以适应任意多个数据的处理。</p><h3 id="6-2-指针"><a href="#6-2-指针" class="headerlink" title="6.2 指针"></a>6.2 指针</h3><h4 id="6-2-1-内存空间的访问方式"><a href="#6-2-1-内存空间的访问方式" class="headerlink" title="6.2.1 内存空间的访问方式"></a>6.2.1 内存空间的访问方式</h4><p>每个字节是一个基本内存单元，有一个地址。<br>在C++中有专门用来存放内存单元地址的变量类型，这就是指针类型。</p><h4 id="6-2-2-指针变量的声明"><a href="#6-2-2-指针变量的声明" class="headerlink" title="6.2.2 指针变量的声明"></a>6.2.2 指针变量的声明</h4><p><strong>疑问：</strong>为什么在声明指针变量时要指出它所指的对象是什么类型呢？<br>限定对变量可以进行的运算及其运算规则。</p><h4 id="6-2-3-与地址相关的运算”-”和“-amp-”"><a href="#6-2-3-与地址相关的运算”-”和“-amp-”" class="headerlink" title="6.2.3 与地址相关的运算”*”和“&amp;”"></a>6.2.3 与地址相关的运算”*”和“&amp;”</h4><p>“*”称为指针运算符，也称解析（dereference），表示获取指针所指向的变量的值。<br>“&amp;”称为取地址运算符，用来得到一个对象的地址。<br>必须注意，“*”和“&amp;”在声明语句中和执行语句中其含义是不同的，它们作为一元运算符和作为二元运算符时含义也是不同的。</p><h4 id="6-2-4-指针的赋值"><a href="#6-2-4-指针的赋值" class="headerlink" title="6.2.4 指针的赋值"></a>6.2.4 指针的赋值</h4><p>可以使用一个已经赋值的指针去初始化另一个指针，这就是说，可以使多个指针指向同一个变量。<br>数组名称实际上就是一个不能被赋值的指针，即指针常量。</p><p>关于指针的类型，还应该注意以下几点。<br>（1）可以声明<strong>指向常量的指针</strong>，此时不能通过指针来改变所指对象的值，但指针本身可以改变，可以指向另外的对象。例如:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>pl<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment">//pl是指向常量的指针</span><span class="token keyword">int</span> b<span class="token punctuation">;</span>pl<span class="token operator">=</span><span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token comment">//正确，pl本身的值可以改变</span><span class="token operator">*</span>pl<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//编译时出错，不能通过pl改变所指的对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）可以声明<strong>指针类型的常量</strong>，这时指针本身的值不能被改变。例如:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p2<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>p2<span class="token operator">=</span><span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token comment">//错误，p2是指针常量，值不能改变</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（3）一般情况下，指针的值只能赋给相同类型的指针。但是有一种特殊的 <strong>void类型指针</strong>，可以存储任何类型的对象地址，就是说任何类型的指针都可以赋值给void类型的指针变量。经过使用类型显式转换，通过void类型的指针便可以访问任何类型的数据。<br><strong>提示：</strong>void 指针一般只在指针所指向的数据类型不确定时使用。</p><h4 id="6-2-5-指针运算"><a href="#6-2-5-指针运算" class="headerlink" title="6.2.5 指针运算"></a>6.2.5 指针运算</h4><p>*(pl + nl)表示pI当前所指位置后方第nl个数的内容，它也可以写作pI[nl],这与*(pl + nl)的写法是完全等价的，同样，*(pl - nl)也可以写作pI[-nl]。</p><p><img src="/images/cpp2/image-20210111181928035.png" alt="指针的算术运算"></p><p><strong>提示：</strong>指针算术运算的不慎使用会导致指针指向无法预期的地址，从而造成不确定的结果，因此指针的算术运算一定要慎用。</p><p>指针变量的关系运算指的是指向相同类型数据的指针之间进行的关系运算。如果两个相同类型的指针相等，就表示这两个指针是指向同一个地址。不同类型的指针之间或指针与非0整数之间的关系运算是毫无意义的。但是指针变量可以和整数0进行比较，0专用于表示空指针，也就是一个不指向任何有效地址的指针。</p><p><strong>细节：</strong>空指针也可以用NULL来表示，NULL是一个在很多头文件中都有定义的宏，被定义为0。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>习惯：</strong>如果不便于用一个有效地址给一个指针变量赋初值，那么应当用0作为它的初值，从而避免指向不确定地址的指针出现。</p><h4 id="6-2-6-用指针处理数组元素"><a href="#6-2-6-用指针处理数组元素" class="headerlink" title="6.2.6 用指针处理数组元素"></a>6.2.6 用指针处理数组元素</h4><p><strong>细节：</strong>把数组作为函数的形参，等价于把指向数组元素类型的指针作为形参。例如，下面3个写法，出现在形参列表中都是等价的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="6-2-7-指针数组"><a href="#6-2-7-指针数组" class="headerlink" title="6.2.7 指针数组"></a>6.2.7 指针数组</h4><p>如果一个数组的每个元素都是指针变量，这个数组就是指针数组。指针数组的每个元素都必须是同类型的指针。例如 int *pa[3];声明了一个int类型的指针数组pa，其中有3个元素，每个元素都是一个指向int类型数<br>据的指针。由于指针数组的每个元素都是一个指针，必须先赋值后引用，因此，声明数组之后，对指针元素赋初值是必不可少的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_8.cpp 利用指针数组输出单位矩阵</span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> line1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> line2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> line3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义整型指针数组并初始化</span><span class="token keyword">int</span><span class="token operator">*</span> pLine<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> line1<span class="token punctuation">,</span>line2<span class="token punctuation">,</span> line3 <span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Matrix test:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> pLine<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210111235748905.png" alt="指针数组与二维数组的区别"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_9.cpp 二维数组举例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> array2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">33</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>array2 <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><span style="color:blue;font-size:15px">2021/1/12</span></center><h4 id="6-2-8-用指针作为函数参数"><a href="#6-2-8-用指针作为函数参数" class="headerlink" title="6.2.8 用指针作为函数参数"></a>6.2.8 用指针作为函数参数</h4><p>例6-10：读入3个浮点数，将整数部分和小数部分分别输出。<br>程序由主函数和一个进行浮点数分解的子函数组成，浮点数在子函数中分解之后，将整数部分和小数部分传递回主函数中输出。可以想象，如果直接使用整型和浮点型变量，形参在子函数中的变化根本就无法传递到主函数，因此采用指针作为函数的参数。源代码如下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6 10.cpp 用指针作为函数参数</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//将实数x分成整数部分和小数部分，形参intPart、 fracPart是指针</span><span class="token keyword">void</span> <span class="token function">splitFloat</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> intPart<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span> fracPart<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>intPart <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//取x的整数部分</span><span class="token operator">*</span>fracPart <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token operator">*</span>intPart<span class="token punctuation">;</span><span class="token comment">//取x的小数部分</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter 3 float point numbers:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">float</span> x<span class="token punctuation">,</span>f<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> x<span class="token punctuation">;</span><span class="token function">splitFloat</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//变量地址作为实参</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Integer Part="</span><span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span><span class="token string">" Fraction Part="</span><span class="token operator">&lt;&lt;</span> f<span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个程序中，使用引用作为形参也可以达到同样目的。</p><h4 id="6-2-9-指针型函数"><a href="#6-2-9-指针型函数" class="headerlink" title="6.2.9 指针型函数"></a>6.2.9 指针型函数</h4><p>除了void 类型的函数之外，函数在调用结束之后都要有返回值，指针也可以是函数的返回值。当一个函数的返回值是指针类型时，这个函数就是指针型函数。使用指针型函数的最主要目的就是要在函数结束时把大量的数据从被调函数返回到主调函数中，而通常非指针型函数调用结束后，只能返回一个变量或者对象。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">funcion</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    函数体<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="6-2-10-指向函数的指针"><a href="#6-2-10-指向函数的指针" class="headerlink" title="6.2.10 指向函数的指针"></a>6.2.10 指向函数的指针</h4><p>在程序运行时，不仅数据要占据内存空间，执行程序的代码也被调入内存并占据一定的空间。每一个函数都有函数名，实际上这个函数名就表示函数的代码在内存中的起始地址。由此看来，调用函数的通常形式“函数名(参数表)”的实质就是“函数代码首地址(参数表)”。</p><p>函数指针就是专门用来存放函数代码首地址的变量。在程序中可以像使用函数名一样使用指向函数的指针来调用函数。也就是说一旦函数指针指向了某个函数，它与函数名便具有同样的作用。函数名在表示函数代码起始地址的同时，也包括函数的返回值类型和参数的个数、类型、排列次序等信息。因此在通过函数名调用函数时，编译系统能够自动检查实参与形参是否相符，用函数的返回值参与其他运算时，能自动进行类型一致性检查。</p><p>声明一个函数指针时，也需要说明函数的返回值、形式参数列表,其一般语法如下:<br>数据类型(*函数指针名) (形参表)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_11.cpp函数指针实例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">printStuff</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"This is the print stuff function."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token keyword">float</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The data to be listed is "</span> <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">printFloat</span><span class="token punctuation">(</span><span class="token keyword">float</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The data to be printed is "</span> <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> <span class="token keyword">float</span> PI <span class="token operator">=</span> <span class="token number">3.14159f</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">float</span> TWO_PI <span class="token operator">=</span> PI <span class="token operator">*</span> <span class="token number">2.0f</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>functionPointer<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printStuff</span><span class="token punctuation">(</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span>functionPointer <span class="token operator">=</span> printStuff<span class="token punctuation">;</span><span class="token function">functionPointer</span><span class="token punctuation">(</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span>functionPointer <span class="token operator">=</span> printMessage<span class="token punctuation">;</span><span class="token function">functionPointer</span><span class="token punctuation">(</span>TWO_PI<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">functionPointer</span><span class="token punctuation">(</span><span class="token number">13.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>functionPointer <span class="token operator">=</span> printFloat<span class="token punctuation">;</span><span class="token function">functionPointer</span><span class="token punctuation">(</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printFloat</span><span class="token punctuation">(</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-2-11-对象指针"><a href="#6-2-11-对象指针" class="headerlink" title="6.2.11 对象指针"></a>6.2.11 对象指针</h4><h5 id="1-对象指针的一般概念"><a href="#1-对象指针的一般概念" class="headerlink" title="1.对象指针的一般概念"></a>1.对象指针的一般概念</h5><p>和基本类型的变量一样，每一个对象在初始化之后都会在内存中占有一定的空间。因此，既可以通过对象名，也可以通过对象地址来访问一个对象。虽然对象同时包含了数虽然对象同时包含了数据和函数两种成员，但与一般变量略有不同，对象所占据的内存空间只是用于存放数据成员的，函数成员不在每一个对象中存储副本。对象指针就是用于存放对象地址的变量。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">对象指针名<span class="token operator">-&gt;</span>成员名<span class="token punctuation">(</span><span class="token operator">*</span>对象指针名<span class="token punctuation">)</span><span class="token punctuation">.</span>成员名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两种访问形式是等价的。</p><h5 id="2-this指针"><a href="#2-this指针" class="headerlink" title="2.this指针"></a>2.this指针</h5><p>this指针是一个隐含于每个类的非静态成员函数中的特殊指针(包括构造函数和析构函数)，它用于指向正在被成员函数操作的对象。</p><p><strong>细节：</strong>this指针实际上是类成员函数的一个隐含参数。 在调用类的成员函数时，目的对象的地址会自动作为该参数的值，传递给被调用的成员函数，这样被调函数就能够通过this指针来访问目的对象的数据成员。对于常成员函数来说，这个隐含的参数是常指针类型的。</p><p>this是一个指针常量，对于常成员函数，this同时又是一个指向常量的指针。在成员函数中， 可以使用*this来标识正在调用该函数的对象。</p><p><strong>提示：</strong>当局部作用域中声明了与类成员同名的标识符时，对该标识符的直接引用代表的是局部作用城中所声明的标识符，这时为了访问该类成员，可以通过this指针。</p><h5 id="3-指向类的非静态成员的指针"><a href="#3-指向类的非静态成员的指针" class="headerlink" title="3.指向类的非静态成员的指针"></a>3.指向类的非静态成员的指针</h5><p>类的成员自身也是一些变量、函数或者对象等，因此也可以直接将它们的地址存放到一个指针变量中，这样，就可以使指针直接指向对象的成员 ，进而可以通过这些指针访问对象的成员。</p><p>声明指针语句的一般形式为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">类型说明符 类名<span class="token operator">::</span><span class="token operator">*</span>指针名<span class="token punctuation">;</span>  <span class="token comment">//声明指向数据成员的指针</span>类型说明符 <span class="token punctuation">(</span>类名<span class="token operator">::</span> <span class="token operator">*</span>指针名<span class="token punctuation">)</span><span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//声明指向函数成员的指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对成员指针赋值的一般语法形式为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">指针名<span class="token operator">=</span><span class="token operator">&amp;</span>类名<span class="token operator">::</span>数据成员名<span class="token punctuation">;</span>   <span class="token comment">//对数据成员指针赋值</span>指针名<span class="token operator">=</span><span class="token operator">&amp;</span>类名<span class="token operator">::</span>函数成员名<span class="token punctuation">;</span>  <span class="token comment">//对函数成员赋值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意：</strong>对类成员取地址时，也要遵守访问权限的约定，也就是说，在一个类的作用域之外不能够对它的私有成员取地址。</p><p><strong>注意：</strong>常成员函数与普通成员函数具有不同的类型，因此能够被常成员函数赋值的指针，需要在声明时明确写出const关键字。</p><p>类是通过对象而实例化的，在声明类的对象时才会为具体的对象分配内存空间，这时只要将对象在内存中的起始地址与成员指针中存放的相对偏移结合起来就可以访问到对象的数据成员了。访问数据成员时，这种结合可通过以下两种语法形式实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">对象名<span class="token punctuation">.</span><span class="token operator">*</span>类成员指针名对象指针名<span class="token operator">-&gt;</span><span class="token operator">*</span>类成员指针名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一个普通函数的函数名就表示它的起始地址，将起始地址赋给指针，就可以通过指针调用函数。类的成员函数虽然并不在每个对象中复制一份副本，但是由于需要确定this指针，因而必须通过对象来调用非静态成员函数。因此经过上述对成员函数指针赋值以后，也还不能用指针直接调用成员函数，而是需要首先声明类的对象，然后用以下形式的语句利用指针调用成员函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">(</span>对象名<span class="token punctuation">.</span><span class="token operator">*</span>类成员指针名<span class="token punctuation">)</span><span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span class="token punctuation">(</span>对象指针名<span class="token operator">-&gt;</span><span class="token operator">*</span>类成员指针名<span class="token punctuation">)</span><span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_13.cpp 指向类的非静态成员的指针 &amp; 访问对象的共有函数的不同方法</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Point <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Point<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span>Point<span class="token operator">::</span> <span class="token operator">*</span> funcPtr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Point<span class="token operator">::</span>getX<span class="token punctuation">;</span><span class="token comment">//定义成员函数指针并初始化</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token operator">*</span>funcPtr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//(1)使用成员函数指针和对象名访问成员函数</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>p1<span class="token operator">-&gt;</span><span class="token operator">*</span>funcPtr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//(2)使用成员函数指针和对象指针访问成员函数</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//(3)使用对象名访问成员函数</span>cout <span class="token operator">&lt;&lt;</span> p1<span class="token operator">-&gt;</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//(4)使用对象指针访问成员函数</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-指向类的静态成员的指针"><a href="#4-指向类的静态成员的指针" class="headerlink" title="4.指向类的静态成员的指针"></a>4.指向类的静态成员的指针</h5><p>对类的静态成员的访问是不依赖于对象的，因此可以用普通的指针来指向和访问静态成员。</p><center><span style="color:blue;font-size:15px">2021/1/13</span></center><h3 id="6-3-动态内存分配"><a href="#6-3-动态内存分配" class="headerlink" title="6.3 动态内存分配"></a>6.3 动态内存分配</h3><p>在C++中，动态内存分配技术可以保证程序在运行过程中按照实际需要申请适量的内存，使用结束后还可以释放，这种在程序运行过程中申请和释放的存储单元也称为堆对象，申请和释放过程一般称为建立和删除。<br>在C++程序中建立和删除堆对象使用两个运算符: new和delete。<br>运算符new的功能是动态分配内存，或者称为动态创建堆对象,语法形式为:<br>new 数据类型(初始化参数列表);<br>该语句在程序运行过程中申请分配用于存放指定类型数据的内存空间，并根据初始化参数列表中给出的值进行初始化。如果内存申请成功，new运算便返回一个指向新分配内存首地址的类型的指针，可以通过这个指针对堆对象进行访问；如果申请失败，会抛出异常(有关异常,将在第12章介绍)。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> point<span class="token punctuation">;</span>point<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>细节：</strong>在用new 建立一个类的对象时，如果该类存在用户定义的默认构造函数，则“new T”和“new T()”这两种写法的效果是相同的，都会调用这个默认构造函数。但若用户未定义默认构造函数,使用“new T”创建对象时，会调用系统生成的隐含的默认构造函数;使用“new T()”创建对象时，系统除了执行默认构造函数会执行的那些操作外，还会为基本数据类型和指针类型的成员用0赋初值，而且这一过程是递归的。 也就是说，如果该对象的某个成员对象也没有用户定义的默认构造函数，那么对该成员对象的基本数据类型和指针类型的成员，同样会被以0赋初值。(基本数据类型和数组也一样)</p><p>运算符delete用来删除由new建立的对象，释放指针所指向的内存空间。格式为:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">delete</span> 指针名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：</strong>用new分配的内存，必须用delete 加以释放，否则会导致动态分配的内存无法回收，使得程序占据的内存越来越大，这叫做“内存泄漏”。</p><p>使用运算符new也可以创建<strong>数组类型</strong>的对象，创建一维数组的语法形式为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">new</span> 类型名 <span class="token punctuation">[</span>数组长度<span class="token punctuation">]</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是用new建立的数组,用delete删除时在指针名前面要加“[]”,格式如下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> 指针名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><center><span style="color:blue;font-size:15px">2021/1/14</span></center><p>在动态数组类中，通过类的成员函数访问数组元素，可以在每次访问之前检查一下下标是否越界，使得使得数组下标越界的错误能够及早被发现<strong><span style="color:green;font-size:15px">(实际应用可直接使用vector)</span></strong> 。这种检查，可以通过C++的assert来进行。assert 只在调试模式下生效，一般用assert 只是检查程序本身的逻辑错误，而用户的不当输入造成的错误，则应当用其他方式加以处理。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_18.cpp 动态数组类   将动态数组封装成一个类</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cassert&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Default Constructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Constructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Destructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">int</span> newX<span class="token punctuation">,</span> <span class="token keyword">int</span> newY<span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> newX<span class="token punctuation">;</span>y <span class="token operator">=</span> newY<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ArrayOfPoints</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">ArrayOfPoints</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">size</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>points <span class="token operator">=</span> <span class="token keyword">new</span> Point<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">ArrayOfPoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Deleting..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> points<span class="token punctuation">;</span><span class="token punctuation">}</span>Point <span class="token operator">&amp;</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//返回一个对象的引用，确保正确更改</span><span class="token function">assert</span><span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果数组下标越界，程序终止</span><span class="token keyword">return</span> points<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>Point<span class="token operator">*</span> points<span class="token punctuation">;</span><span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> count<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please enter the count of points: "</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> count<span class="token punctuation">;</span>ArrayOfPoints <span class="token function">points</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建对象数组</span>points<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问数组元索的成员</span>points<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问数组元素的成员</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210114012043817.png" alt="运行结果"></p><p>创建和删除对象数组的过程都由ArrayOfPoints类的构造函数和析构函数完成。这虽然使main()函数更为简洁，但是对数组元素的访问形式“points.element(0)”却显得啰嗦。如果希望像使用普通数组样,通过下标操作符“[ ]”来访问数组元素，就需要对下标操作符进行重载，这将在第9章详细介绍。</p><p>用new操作也可以创建多维数组，其中第1维长度可以是任何结果为正整数的表达式，而其他各维数组长度必须是结果为正整数的常量表达式。如果内存申请成功.new运算返回一个指向新分配内存的首地址的指针。例如，下列语句</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span><span class="token operator">*</span> fp<span class="token punctuation">;</span>fp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>会产生错误，正确的写法应该是：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span><span class="token punctuation">(</span><span class="token operator">*</span>cp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>cp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如此得到的指针cp，既可以作为指针使用，也可以像一个三维数组名一样使用。</p><h3 id="6-4-用vector创建数组对象"><a href="#6-4-用vector创建数组对象" class="headerlink" title="6.4 用vector创建数组对象"></a>6.4 用vector创建数组对象</h3><p>无论是静态数组，还是用new动态创建的数组，都难以检测下标越界的错误，在实际应用中常常造成困扰。例6-18 提供了一个很好的例子，它通过将动态数组封装成-一个类，允许在调试状态下访问数组元素时检查下标越界的错误。然而，它只能表示Point类型的动态数组，若要处理其他类型的动态数组，还需创建新的动态数组类，这是很烦琐的重复性工作，事实上,C++标准库也提供了被封装的动态数组一vector，而且这种被封装的数组可以具有各种类型，这就使我们免去了那些重复性工作。vector不是一个类，而是个类模板。模板的概念将在第9章详细介绍，读者通过本章的学习，只需在形式上记住vector的使用方式。</p><p>向量 <strong>vector</strong> 是一种对象实体, 能够容纳许多其他类型相同的元素, 因此又被称为容器。 与string相同，vector 同属于STL(Standard Template Library，标准模板库)中的一种自定义的数据类型，可以广义上认为是数组的增强版。用vector定义动态数组的形式为:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>元素类型<span class="token operator">&gt;</span>数组对象名<span class="token punctuation">(</span>数组长度，元素初值<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>细节：</strong>与普通数组不同的是，用vector定义的数组对象的所有元素都会被初始化。如果数组的元素类型为基本数据类型，则所有元素都会被以0初始化；如果数组元素为类类型，则会调用类的默认构造函数初始化。因此如果以此形式定义的vector动态数组，需要保证作为数组元素的类具有默认构造函数。另外,初值也可以自己指定，但只能为所有元素指定相同初值。</p><p>对vector数组对象元素的访问方式，与普通数组具有相同的形式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">数组对象名<span class="token punctuation">[</span>下标表达式<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是vector数组对象的名字表示的就是一个数组对象，而非数组的首地址，因为数组对象不是数组，而是封装了数组的对象。vector定义的数组对象具有个重要的成员函数size()，它会返回数组的大小。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_20.cpp vector应用举例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//计算数组arr中元素的平均值</span><span class="token keyword">double</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>sum <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> sum <span class="token operator">/</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">unsigned</span> n<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"n= "</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token function">arr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please input "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">" real numbers:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>cin <span class="token operator">&gt;&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Average="</span> <span class="token operator">&lt;&lt;</span> <span class="token function">average</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vector还具有很多其他强大的功能，例如它的大小可以扩展，这些特性都将在第10章详细介绍。</p><center><span style="color:blue;font-size:15px">2021/1/15</span></center><h3 id="6-5-深复制和浅复制"><a href="#6-5-深复制和浅复制" class="headerlink" title="6.5 深复制和浅复制"></a>6.5 深复制和浅复制</h3><p>虽然第4章已经介绍过复制构造函数，但是在此前大多数简单例题中都不需要特别编写复制构造函数，隐含的复制构造函数足以实现对象间数据元素的一一对应复制。因此，读者对于编写复制构造函数的必要性，可能一直存在疑问。其实隐含的复制构造的数并不总是适用的，因为它完成的只是浅复制。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_21.cpp 对象的浅复制</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Default Constructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Constructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Destructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">int</span> newX<span class="token punctuation">,</span> <span class="token keyword">int</span> newY<span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> newX<span class="token punctuation">;</span>y <span class="token operator">=</span> newY<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ArrayOfPoints</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">ArrayOfPoints</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">size</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>points <span class="token operator">=</span> <span class="token keyword">new</span> Point<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">ArrayOfPoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Deleting..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> points<span class="token punctuation">;</span><span class="token punctuation">}</span>Point<span class="token operator">&amp;</span> <span class="token function">element</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//返回一个对象的引用，确保正确更改</span><span class="token function">assert</span><span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果数组下标越界，程序终止</span><span class="token keyword">return</span> points<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>Point<span class="token operator">*</span> points<span class="token punctuation">;</span><span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> count<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please enter the count of points:"</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> count<span class="token punctuation">;</span>ArrayOfPoints <span class="token function">pointsArray1</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建对象数组</span>pointsArray1<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pointsArray1<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ArrayOfPoints pointsArray2 <span class="token operator">=</span> pointsArray1<span class="token punctuation">;</span><span class="token comment">//创建对象数组副本</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Copy of pointsArrayl:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Point 0 of array2: "</span> <span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Point 1 of array2: "</span> <span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>pointsArray1<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pointsArray1<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"After the moving of pointsArrayl:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Point 0 of array2: "</span> <span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Point 1 of array2: "</span> <span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token operator">&lt;&lt;</span> pointsArray2<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个程序会出现异常，也就是运行错误。</p><p><img src="/images/cpp2/image-20210115130448555.png" alt="6_21"></p><p>这里建立对象pointsArray2时调用的是默认的复制构造函数，实现对应数据项的直接复制。默认的复制构造函数将两个对象的对应数据项简单复制后，pointsArray1的成员points和pointsArray2的成员points 具有相同的值，也就是说两个指针指向的是同一内存地址，表面上好像完成了复制，但是并没有形成真正的副本。因此当程序中移动pointsArray1中的点时，也影响到了pointsArray2。 这种效果就是“浅复制”。<br>浅复制还有更大的弊病，在程序结束之前pointsArray1和pointsArray2 的析构函数会自动被调用，动态分配的内存空间会被释放。由于两个对象共用了同一块内存空间，因此该空间被两次释放，于是导致运行错误。解决这一问题的方法是编写复制构造函数，实现“深复制”。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_22.cpp  对象的深复制</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token comment">//类的定义同6_21</span><span class="token comment">//...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ArrayOfPoints</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">ArrayOfPoints</span><span class="token punctuation">(</span><span class="token keyword">const</span> ArrayOfPoints<span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//其他成员同6_21</span><span class="token punctuation">}</span><span class="token class-name">ArrayOfPoints</span><span class="token operator">::</span><span class="token function">ArrayOfPoints</span><span class="token punctuation">(</span><span class="token keyword">const</span> ArrayOfPoints<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>size<span class="token operator">=</span>v<span class="token punctuation">.</span>size<span class="token punctuation">;</span>points <span class="token operator">=</span> <span class="token keyword">new</span> Point<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">.</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//同6_21</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210115131228658.png" alt="6_22"></p><p>从这次的运行结果可以看出，程序实现的是深复制：移动pointsArray1中的点不再影响pointsArray2中的点，而且程序结束前分别释放pointsArray1和pointsArray2中的内存空间，也不再引起错误。</p><h3 id="6-6-字符串"><a href="#6-6-字符串" class="headerlink" title="6.6 字符串"></a>6.6 字符串</h3><p>与C语言一样，在C++的基本数据类型变量中没有字符串变量。在C语言中是使用字符型数组来存放字符串的，C++程序中也仍然可以沿用这种办法。不仅如此，标准 C++库中还预定义了string 类。本节就来介绍这两种方法。</p><h4 id="6-6-1-用字符数组存储和处理字符串"><a href="#6-6-1-用字符数组存储和处理字符串" class="headerlink" title="6.6.1 用字符数组存储和处理字符串"></a>6.6.1 用字符数组存储和处理字符串</h4><p>第2章中介绍过，字符串常量是用一对双引号括起来的字符序列。它在内存中的存放形式是，按串中字符的<br>排列次序顺序存放，每个字符占一个字节，并在末尾添加\0作为结尾标记。这实际上是一个隐含创建的类型为char的数组，一个字符串常量就表示这样一个数组的首地址，因此，可以把字符串常量赋给字符串针，由于常量值是不能改的，应将字符串常量赋给指向常量的指针，例如:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> STRING1 <span class="token operator">=</span> <span class="token string">"This is a string."</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span> STRING1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>字符变量也可以用类似方式来表示。 如果创建一个char数组，每个元素存放字符串的一个字符，在末尾放置一个\0，便构成了C++字符串。它的存储方式与字符串常量无异，但由于它是程序员创建的数组，因此可以改写其内容，因而这就是字符串变量而非常量了。这时要注意，用于存放字符串的数组其元素个数应该不小于字符串的长度(字符个数)加1。对字符数组进行初始化赋值时，初值的形式可以是以逗号分隔的ASCII码或字符常量，也可以是整体的字符串常量(这时末尾的\0是隐含的)。 下面列出的语句都可以创建一个初为”program” 的字符串变量，3种写法是等价的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'g'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'m'</span>，<span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"program"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"program"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>尽管对用字符数组表示的字符串进行初始化还比较容易、直观，但进行许多其他字符串操作时却比较麻烦。执行很多字符串操作需要借助cstring头文件中的字符串处理函数。例如将一个字符串的内容复制到另一个字符串需要用strcpy函数，按辞典顺序比较两个的大小需要用strcmp函数，将两个字符串连接起来需要用strcat函数。另外，当字符串长度很不确定时，需要用new来动态创建字符数组。最后还要用delete释放，这些都相当烦琐。C++对这些烦琐的操作进行了封装，形成了string类，可以更加方便地操作字符串。</p><h4 id="6-6-2-string类"><a href="#6-6-2-string类" class="headerlink" title="6.6.2 string类"></a>6.6.2 string类</h4><p>C++标准类库将面向对象的串的概念加入到C++语言中，预定义了字符串类(string类)。string类提供了对字符串进行处理所需要的操作。使用string类需要包含头文件string。string类封装了串的属性并提供了一系列允许访问这此属性的函数。</p><p><strong>细节：</strong>严格地说，string 并非一个独立的类，而是类模板basic_ string的一个特化实例。不过对于string的使用者来说，它的特点与一个类无异，因此可以把它当作一个类来看待。有关模板，将在第9章详细介绍。</p><center><span style="color:blue;font-size:15px">2021/1/18</span></center><p>下面简要介绍一下string 类的构造函数、几个常用的成员函数和操作。为了简明起见，函数原型是经过简化的，与头文件中的形式不完全一样。 </p><p><strong>1.构造函数的原型</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string();//默认构造函数,建立一个长度为0的串string (const string&amp; rhs) ;//复制构造函数string (const char* s);//用指针s所指向的字符申常量初始化string类的对象string (const string&amp; rhs, unsigned int pos, unsigned int n) ;//将对象rhs中的串从位置pos开始取n个字符,用来初始化string类的对象//注:申中的第一个字符的位置为0string (const char* s, unsigned int n);//用指针s所指向的字符串中的前n个字符初始化string类的对象string (unsigned int n, char c);//将参数c中的字符重复n次,用来初始化string类的对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong>由于string类具有接收const char*类型的构造函数，因此字符串常量和用字符数组表示的字符串变量都可以隐含地转换为string对象。<br>例如，可以直接使用字符串常量对string对象初始化:<br><code>string str= "Hello world!";</code></p><p><strong>2.string类的操作符</strong></p><p><img src="/images/cpp2/image-20210118183703493.png" alt="string类的操作符"></p><p><strong>提示：</strong>之所以能够通过上面的操作符来操作string对象，是因为string类对这些操作符进行了重载。操作符的重载将在第8章详细介绍。</p><p><strong>3.常用成员函数功能简介</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">append</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//append(在文章后面)附加，增补; 将字符串s添加在本串尾</span>string <span class="token function">assign</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//赋值,将s所指向的字符串赋值给本对象</span><span class="token keyword">int</span> <span class="token function">compare</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//比较本串与str中串的大小，当本串&lt;str串时,返回负数;当本串&gt;str串时，返回正数;两串相等时,返回0</span>string <span class="token operator">&amp;</span> <span class="token function">insert</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> p0<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将s所指向的字符串插人在本串中位置p0之前</span>string <span class="token function">substr</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//取子串,取本串中位置pos开始的n个字符,构成新的string类对象作为返回值</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">find</span> <span class="token punctuation">(</span><span class="token keyword">const</span> basic_string <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//在找并返回str在本串中第一次出现的位置</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//返回串的长度(字符个数)</span>vold <span class="token function">swap</span> <span class="token punctuation">(</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将本串与str中的字符串进行交换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面看一个string类应用的例子</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_23.cpp    string类应用举例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//根据value的值输出true或false,title为提示文字</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> title<span class="token punctuation">,</span> <span class="token keyword">bool</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> title <span class="token operator">&lt;&lt;</span> <span class="token string">" returns "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>value <span class="token operator">?</span> <span class="token string">"true"</span> <span class="token operator">:</span> <span class="token string">"false"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>string s1 <span class="token operator">=</span> <span class="token string">"DEF"</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s1 1s "</span> <span class="token operator">&lt;&lt;</span> s1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>string s2<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please enter s2: "</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> s2<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"length of s2: "</span> <span class="token operator">&lt;&lt;</span> s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//比较运算符的测试</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"s1&lt;= \"ABC\""</span><span class="token punctuation">,</span> s1 <span class="token operator">&lt;=</span> <span class="token string">"ABC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"\"DEF\"&lt;=s1"</span><span class="token punctuation">,</span> <span class="token string">"DEF"</span> <span class="token operator">&lt;=</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//连接运算符的测试</span>s2 <span class="token operator">+=</span> s1<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s2=s2+s1: "</span> <span class="token operator">&lt;&lt;</span> s2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"length of s2: "</span> <span class="token operator">&lt;&lt;</span> s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210118191532246.png" alt=""></p><p>如果希望从键盘读入字符串，直到行末为止，不以中间的空格作为输入的分隔符，可以使用头文件string中定义的getline。例如，如果将上面的代码中输人s2的语句改为下列语句，就能达到这一目的。<br><code>getline(cin, s2);</code><br>这时，如果从键盘输入字符串“123 ABC” ，那么整个字符串都会被赋给s2。这实际表示输入字符串时只以换行符作为分隔符。getline还允许在输人字符串时增加其他分隔符，使用方法是把可以作为分隔符的字符作为第3个参数传递给getline。例如，使用下面的语句，可以把逗号作为分隔符。<br><code>getline(cin, s2, ',');</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6.24.cpp  用getline输入字符串</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>string city<span class="token punctuation">,</span> state<span class="token punctuation">;</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> city<span class="token punctuation">,</span> <span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"City:"</span> <span class="token operator">&lt;&lt;</span> city <span class="token operator">&lt;&lt;</span> <span class="token string">" state:"</span> <span class="token operator">&lt;&lt;</span> state <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><span style="color:blue;font-size:15px">2021/1/19</span></center><h3 id="6-7-综合实例——个人银行账户管理系统"><a href="#6-7-综合实例——个人银行账户管理系统" class="headerlink" title="6.7 综合实例——个人银行账户管理系统"></a>6.7 综合实例——个人银行账户管理系统</h3><p>在第4章和第5章中，以一个银行账户管理程序为例，说明了类和成员函数的设计和应用，以及类的静态成员的应用和程序结构的组织问题。在本节中，将在第5章综合实例的基础上对银行账户管理程序进步 加以完善。<br>（1）第4章和第5章中，都是用一个整数来表示银行账号，但这并不是完美的方案，例如，如果银行账以“0”开头，或账号超过整数的表示范围，或账号中包括其他字符，这种表示方式都不能胜任。本章学习了字符串后，可以改<strong>用字符串来表示银行账号</strong>，这样以上问题得到了解决。另外，第4章和第5章的程序中所输出的账目列表，每笔账目都没有说明，<strong>使用字符串可以为各笔账目增加说明文字</strong>。此外，我们SavingsAccount类专门<strong>增加了一个用来报告错误的函数</strong>，当其他丽数需要输出错误信息时，直接把信息以字符串形式传递给该函数即可，简化了错误信息的输出。<br>（2）第4章和第5章中，主程序创建的两个账户为两个独立的变量，只能用名字去引用它们，在主程序末尾分别对两个账户进行结算(settle)和显示(show)时，需要将几乎相同的代码书写两遍，如果账户数量增多将会带来更大麻烦。本章学习了数组后，可以<strong>将多个账户组织在一个数组中</strong>，这样可以把需要对各个账户做的事情放在循环中，避免了代码的冗余。<br>（3）第4章和第5章的程序中，日期都是用一个整数来表示的，这样计算两个日期相距天数时非常方便，但这种表示很不直观，对用户很不友好。事实上，<strong>日期可以用一个类来表示</strong>，内含年、月、日三个数据成员，但这又给计算两个日期相差天数带来了麻烦。为了计算日期间相差的天数，可以先选取一个比较规整的基准日期，在构造日期对象时将该日期到这个基准日期的相对天数计算出来，我们将这个相对天数称为“相对日期”。这样在计算两个日期相差的天数时，只需将二者的相对日期相减即可。假设将公元元年1月1日作为公共的基准日期，将y年m月d日相距这一天的天数记为 f(y/m/d,1/1/1)，可以将其分解为3部分:</p><script type="math/tex; mode=display">f(y / m / d, 1 / 1 / 1)=f(y / 1 / 1,1 / 1 / 1)+f(y / m / 1, y / 1 / 1)+f(y / m / d, y / m / 1)</script><p>f(y/1/1,1/1/1)表示当年的1月1日与公元元年1月1日相距的天数，即公元元年到公元y-1年的总天数。平年每年有365天,闰年多一天，因此该值为365(y-1)加上公元元年到y-1年之间的闰年数。由于4年一闰，100的倍数免闰，400的倍数再闰，故有:</p><script type="math/tex; mode=display">f(y / 1 / 1,1 / 1 / 1)=365(y-1)+\left\lfloor\frac{y-1}{4}\right\rfloor-\left\lfloor\frac{y-1}{100}\right\rfloor+\left\lfloor\frac{y-1}{400}\right\rfloor</script><p>f(y/m/1,y/1/1)表示 y年的m月1日与1月1日相距天数。可以把每月1日到1月1日的天数放在一个数组中，计算时只要查询该数组，便可得到f(y/m/1,y/1/1)的值。而对于闰年，仍可通过数组查询，只需在m&gt;2时将查得的值加1。该值只依赖于T和y，将它记为g(m,y)。此外:</p><script type="math/tex; mode=display">f(y/m/d,y/m/1) =d- 1</script><p>如果把公元元年1月1日的相对日期定为1,那么公元y年m月d日的相对日期就是:</p><script type="math/tex; mode=display">\begin{aligned}f(y / m / d, 1 / 1 / 1)+1=& 365(y-1)+\left\lfloor\frac{y-1}{4}\right\rfloor \\&-\left\lfloor\frac{y-1}{100}\right\rfloor+\left\lfloor\frac{y-1}{400}\right\rfloor+g(m+y)+d\end{aligned}</script><p>相对日期得出后，计算两日期相差天数的难题就迎刃而解了。</p><p><img src="/images/cpp2/image-20210119130403132.png" alt="UML图"></p><p>以后，假定银行对活期储蓄账户的结算日期是每年的1月1日。</p><p>例6-25个 人银行账户管理程序改进。<br>整个程序分为5个文件: <strong>date. h</strong>是日期类头文件，<strong>date. cpp</strong>是日期类实现文件，<strong>account.h</strong>是储蓄账户类定义头文件，<strong>account. cpp</strong>是储蓄账户类实现文件，<strong>6_25. cpp</strong>是主函数文件。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//date.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__DATE_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__DATE_H__</span></span><span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span><span class="token comment">//日期类</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> year<span class="token punctuation">;</span><span class="token comment">//年</span><span class="token keyword">int</span> month<span class="token punctuation">;</span><span class="token comment">//月</span><span class="token keyword">int</span> day<span class="token punctuation">;</span><span class="token comment">//日</span><span class="token keyword">int</span> totalDays<span class="token punctuation">;</span><span class="token comment">//该日期是从公元元年1月1日开始的第儿天</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用年、月、日构造日期</span><span class="token keyword">int</span> <span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> year<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> month<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> day<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getMaxDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//获得当月有多少天</span><span class="token keyword">bool</span> <span class="token function">isLeapYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token comment">//判断当年是否为闰年</span><span class="token keyword">return</span> year <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> year <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> year <span class="token operator">%</span> <span class="token number">400</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//输出当前日期</span><span class="token keyword">int</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token comment">//计算两个日期之间差多少天</span><span class="token comment">//常成员函数保护目的对象，常引用保护所引用的对象</span><span class="token keyword">return</span> totalDays <span class="token operator">-</span> date<span class="token punctuation">.</span>totalDays<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span><span class="token comment">// __DATE_H__</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//date.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"date.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdlib&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">namespace</span> <span class="token punctuation">{</span><span class="token comment">//namespace使下面的定义只在当前文件中有效</span><span class="token comment">//存储平年中的某个月1日之前有多少天，为便于getMaxDay函数的实现，该数组多出一项</span><span class="token keyword">const</span> <span class="token keyword">int</span> DAYS_BEFORE_MONTH<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">,</span><span class="token number">59</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token number">120</span><span class="token punctuation">,</span><span class="token number">151</span><span class="token punctuation">,</span><span class="token number">181</span><span class="token punctuation">,</span><span class="token number">212</span><span class="token punctuation">,</span><span class="token number">243</span><span class="token punctuation">,</span><span class="token number">273</span><span class="token punctuation">,</span><span class="token number">304</span><span class="token punctuation">,</span><span class="token number">334</span><span class="token punctuation">,</span><span class="token number">365</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Date</span><span class="token operator">::</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">year</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">month</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">day</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//只验证天数不验证年月？</span><span class="token keyword">if</span> <span class="token punctuation">(</span>day <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> day <span class="token operator">&gt;</span> <span class="token function">getMaxDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Invalid date: "</span><span class="token punctuation">;</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//exit（1）：非正常运行导致退出程序；</span><span class="token punctuation">}</span><span class="token keyword">int</span> years <span class="token operator">=</span> year <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>totalDays <span class="token operator">=</span> years <span class="token operator">*</span> <span class="token number">365</span> <span class="token operator">+</span> years <span class="token operator">/</span> <span class="token number">4</span> <span class="token operator">-</span> years <span class="token operator">/</span> <span class="token number">100</span> <span class="token operator">+</span> years <span class="token operator">/</span> <span class="token number">400</span> <span class="token operator">+</span> DAYS_BEFORE_MONTH<span class="token punctuation">[</span>month <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> day<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLeapYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> month <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> totalDays<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token class-name">Date</span><span class="token operator">::</span><span class="token function">getMaxDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLeapYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> month <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">29</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> DAYS_BEFORE_MONTH<span class="token punctuation">[</span>month<span class="token punctuation">]</span> <span class="token operator">-</span> DAYS_BEFORE_MONTH<span class="token punctuation">[</span>month <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">Date</span><span class="token operator">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-"</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-"</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//account.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__ACCOUNT_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__ACCOUNT_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"date.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">SavingsAccount</span> <span class="token punctuation">{</span><span class="token comment">//储蓄账户类</span><span class="token keyword">private</span><span class="token operator">:</span>std<span class="token operator">::</span>string id<span class="token punctuation">;</span><span class="token comment">//账号</span><span class="token keyword">double</span> balance<span class="token punctuation">;</span><span class="token comment">//余额</span><span class="token keyword">double</span> rate<span class="token punctuation">;</span><span class="token comment">//存款的年利率</span>Date lastDate<span class="token punctuation">;</span><span class="token comment">//上次变更余额的时期</span><span class="token keyword">double</span> accumulation<span class="token punctuation">;</span><span class="token comment">//余额按日累加之和</span><span class="token keyword">static</span> <span class="token keyword">double</span> total<span class="token punctuation">;</span><span class="token comment">//所有账户的总金额</span><span class="token comment">//记录一笔账,date为日期，amount为金额，desc为说明</span><span class="token keyword">void</span> <span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//报告错误信息</span><span class="token keyword">void</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> msg<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//获得到指定日期为止的存款金额按日累积值</span><span class="token keyword">double</span> <span class="token function">accumulate</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> accumulation <span class="token operator">+</span> balance <span class="token operator">*</span> date<span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span>lastDate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//构造函数</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> rate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> id<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">//返回值是string类型的引用，也就是id本身</span><span class="token keyword">double</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> balance<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">getRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rate<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> total<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//存入现金</span><span class="token keyword">void</span> <span class="token function">deposit</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//取出现金</span><span class="token keyword">void</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结算利息,每年1月1日调用一次该函数</span><span class="token keyword">void</span> <span class="token function">settle</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date <span class="token operator">&amp;</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示账户信息</span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span><span class="token comment">//__ACCOUNT_H__</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//account.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"account.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">double</span> SavingsAccount<span class="token operator">::</span>total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//SacingsAccount类相关函数的实现</span><span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> rate<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">balance</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">rate</span><span class="token punctuation">(</span>rate<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">lastDate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">accumulation</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>date<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\t#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">" create"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date <span class="token operator">&amp;</span>date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> desc<span class="token punctuation">)</span><span class="token punctuation">{</span>accumulation <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>lastDate <span class="token operator">=</span> date<span class="token punctuation">;</span>amount <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>amount <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//保留小数点后两位</span>balance <span class="token operator">+=</span> amount<span class="token punctuation">;</span>total <span class="token operator">+=</span> amount<span class="token punctuation">;</span>date<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\t# "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> amount <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> balance <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> desc <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> msg<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error(# "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"): "</span> <span class="token operator">&lt;&lt;</span> msg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> desc<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> desc<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">&gt;</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"not enough money"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token operator">-</span>amount<span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//计算年息</span><span class="token keyword">double</span> interest <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span> <span class="token operator">*</span> rate <span class="token operator">/</span> date<span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token function">Date</span><span class="token punctuation">(</span>date<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>interest <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> interest<span class="token punctuation">,</span> <span class="token string">"interest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>accumulation <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"\tBalance: "</span> <span class="token operator">&lt;&lt;</span> balance<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//6_25.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"account.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Date <span class="token function">date</span><span class="token punctuation">(</span><span class="token number">2008</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//起始日期</span><span class="token comment">//建立几个账户</span>SavingsAccount accounts<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token string">"03755217"</span><span class="token punctuation">,</span> <span class="token number">0.015</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token string">"02342342"</span><span class="token punctuation">,</span> <span class="token number">0.015</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>accounts<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>SavingsAccount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//11月份的几笔账目</span>accounts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2008</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">,</span> <span class="token string">"salary"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>accounts<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2008</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token string">"sell stock 0323"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//12月份的几笔账目</span>accounts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2008</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5500</span><span class="token punctuation">,</span> <span class="token string">"salary"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>accounts<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2008</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">,</span> <span class="token string">"buy a laptop"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结算所有账户并输出各个账户信息</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>accounts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2009</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>accounts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Total: "</span> <span class="token operator">&lt;&lt;</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp2/image-20210119143650821.png" alt="运行结构"></p><p><strong>细节：</strong>以上程序的Date类的构造函数中使用了exit 函数，该函数的原型声明在cstdlib头文件中。它用来立即终止当前程序的执行，并且将一个整数返回给系统，该整数的作用与由主函数main返回的整数相同，如果是0表示程序正常退出，如果非0表示程序异常退出。</p><p>上面的程序中增加了Date类，把对日期的表示均替换为Date类型。从输出结果明以看出，用“年-月-日”的形式所表示的日期与整数相比要直观得多。此外，本例广泛应用了字符串，这样在银行账号中可以出现字母，而且为每笔账目增加了说明文字，使得程序输出的信息更加丰富。 在主程序中，两个银行账户是用数组表示的，这样最后所执行的账户结算和输出账户信息的操作可以在一个循环中进行，无须把同样的代码书写多遍。</p><h3 id="6-8-深度探索"><a href="#6-8-深度探索" class="headerlink" title="6.8 深度探索"></a>6.8 深度探索</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> C++语言设计指南（第4版） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github使用学习</title>
      <link href="2021/01/04/github/"/>
      <url>2021/01/04/github/</url>
      
        <content type="html"><![CDATA[<center><span style="color:blue;font-size:15px">2021/1/4</span></center><h2 id="什么是-Github"><a href="#什么是-Github" class="headerlink" title="什么是 Github?"></a>什么是 Github?</h2><p> GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。Github 由Chris Wanstrath, PJ Hyett 与Tom Preston-Werner三位开发者在2008年4月创办，除了Git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。 </p><h2 id="1-基本功能"><a href="#1-基本功能" class="headerlink" title="1.基本功能"></a>1.基本功能</h2><p><strong>协同修改</strong><br>多人并行不悖的修改服务器端的同一个文件。<br><strong>数据备份</strong><br>不仅保存目录和文件的当前状态， 还能够保存每一个提交过的历史状态。<br><strong>版本管理</strong><br>在保存每一个版本的文件信息的时候要做到不保存重复数据， 以节约存储空<br>间， 提高运行效率。 这方面 SVN 采用的是增量式管理的方式， 而 Git 采取了文<br>件系统快照的方式。<br><strong>权限控制</strong><br>对团队中参与开发的人员进行权限控制。<br>对团队外开发者贡献的代码进行审核——Git 独有。<br><strong>历史记录</strong><br>查看修改人、 修改时间、 修改内容、 日志信息。<br>将本地文件恢复到某一个历史状态。<br><strong>分支管理</strong><br>允许开发团队在工作过程中多条生产线同时推进任务， 进一步提高效率</p><h2 id="2-git的优势"><a href="#2-git的优势" class="headerlink" title="2.git的优势"></a>2.git的优势</h2><p><strong>版本控制简介</strong>工程设计领域中使用版本控制管理工程蓝图的设计过程。在 IT 开发过程中也可以使用版本控制思想管理代码的版本迭代。<br><strong>版本控制工具</strong><br>集中式版本控制工具：<br>CVS、SVN、VSS……<br>分布式版本控制工具：<br>Git、Mercurial、Bazaar、Darcs……</p><p><strong>Git 的优势</strong><br>大部分操作在本地完成，不需要联网<br>完整性保证<br>尽可能添加数据而不是删除或修改数据<br>分支操作非常快捷流畅<br>与 Linux 命令全面兼容</p><h2 id="3-git简介"><a href="#3-git简介" class="headerlink" title="3.git简介"></a>3.git简介</h2><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104145617035.png" alt="git结构"></p><p><strong>Git 和代码托管中心</strong><br>代码托管中心的任务：维护远程库<br> 局域网环境下： GitLab 服务器<br> 外网环境下 ： GitHub 、 码云</p><h2 id="4-Git-命令行操作"><a href="#4-Git-命令行操作" class="headerlink" title="4.Git 命令行操作"></a>4.Git 命令行操作</h2><h3 id="4-1-本地库初始化"><a href="#4-1-本地库初始化" class="headerlink" title="4.1 本地库初始化"></a>4.1 本地库初始化</h3><p>命令：</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：.git 目录中存放的是本地库相关的子目录和文件，不要删除，也不要胡乱修改</p><h3 id="4-2-设置签名"><a href="#4-2-设置签名" class="headerlink" title="4.2 设置签名"></a>4.2 设置签名</h3><p>用户名：xxxxx<br>Email 地址：zzzz@yyy.com（可以没有）<br>作用：区分不同开发人员的身份<br>辨析：这里设置的签名和登录远程库(代码托管中心)的账号、密码没有任何关系。<br><strong>命令</strong> :<br>项目级别/仓库级别：仅在当前本地库范围内有效 </p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git config user.name xxxxgit config user.email zzzz@yyy.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>信息保存位置：./.git/config 文件</p><p>系统用户级别：登录当前操作系统的用户范围</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git config --global user.name xxxx_glbgit config --global zzzz@yyy.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>信息保存位置：~/.gitconfig 文件</p><p><strong>级别优先级</strong><br>就近原则：项目级别优先于系统用户级别，二者都有时采用项目级别的签名<br>如果只有系统用户级别的签名，就以系统用户级别的签名为准<br>二者都没有不允许<br>实际开发中一般只设置一个系统签名就行了</p><h3 id="4-3-基本操作"><a href="#4-3-基本操作" class="headerlink" title="4.3 基本操作"></a>4.3 基本操作</h3><h4 id="4-3-1状态查看"><a href="#4-3-1状态查看" class="headerlink" title="4.3.1状态查看"></a>4.3.1状态查看</h4><pre class="line-numbers language-git" data-language="git"><code class="language-git">git status <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看工作区、暂存区状态</p><h4 id="4-3-2-添加"><a href="#4-3-2-添加" class="headerlink" title="4.3.2 添加"></a>4.3.2 添加</h4><pre class="line-numbers language-git" data-language="git"><code class="language-git">git add [file name] <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将工作区的“新建/修改”添加到暂存区</p><h4 id="4-3-3-提交"><a href="#4-3-3-提交" class="headerlink" title="4.3.3 提交"></a>4.3.3 提交</h4><pre class="line-numbers language-git" data-language="git"><code class="language-git">git commit -m <span class="token string">"备注你的版本记录"</span> [file name] <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将暂存区的内容提交到本地库</p><h4 id="4-3-4-查看历史记录"><a href="#4-3-4-查看历史记录" class="headerlink" title="4.3.4 查看历史记录"></a>4.3.4 查看历史记录</h4><pre class="line-numbers language-none"><code class="language-none">git log//显示完整记录git log --pretty=oneline//显示简化的记录，但有完整的哈希值git log --oneline//显示简化的哈希值(只显示过去的)git reflog//显示变更任意版本需要移动的指针次数(过去未来全部显示)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>多屏显示控制方式： 空格向下翻页；b 向上翻页；q 退出</p><h4 id="4-3-5-前进后退"><a href="#4-3-5-前进后退" class="headerlink" title="4.3.5 前进后退"></a>4.3.5 前进后退</h4><p>基于索引值操作[推荐]</p><pre class="line-numbers language-none"><code class="language-none">git reset --hard [局部索引值] git reset --hard a6ace91<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用^符号：只能后退<br>注：一个^表示后退一步，n 个表示后退 n 步</p><pre class="line-numbers language-none"><code class="language-none">git reset --hard HEAD^<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用~符号：只能后退<br>注：表示后退 n 步</p><pre class="line-numbers language-none"><code class="language-none">git reset --hard HEAD~n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-3-6-reset-命令的三个参数对比"><a href="#4-3-6-reset-命令的三个参数对比" class="headerlink" title="4.3.6 reset 命令的三个参数对比"></a>4.3.6 reset 命令的三个参数对比</h4><p>—soft 参数：仅在本地库移动 HEAD 指针<br>—mixed 参数：在本地库移动 HEAD 指针；重置暂存区<br>—hard 参数：在本地库移动 HEAD 指针 ； 重置暂存区 ； 重置工作区</p><h4 id="4-3-7-删除文件并找回"><a href="#4-3-7-删除文件并找回" class="headerlink" title="4.3.7 删除文件并找回"></a>4.3.7 删除文件并找回</h4><p>前提：删除前，文件存在时的状态提交到了本地库。<br>操作：git reset —hard [指针位置]<br>删除操作已经提交到本地库：指针位置指向历史记录<br>删除操作尚未提交到本地库：指针位置使用 HEAD</p><h4 id="4-3-8-比较文件差异"><a href="#4-3-8-比较文件差异" class="headerlink" title="4.3.8 比较文件差异"></a>4.3.8 比较文件差异</h4><pre class="line-numbers language-none"><code class="language-none">git diff [文件名] <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将工作区中的文件和暂存区进行比较</p><pre class="line-numbers language-none"><code class="language-none">git diff [本地库中历史版本] [文件名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将工作区中的文件和本地库历史记录比较<br>不带文件名比较多个文件</p><h3 id="4-4-分支管理"><a href="#4-4-分支管理" class="headerlink" title="4.4 分支管理"></a>4.4 分支管理</h3><h4 id="4-4-1-什么是分支？"><a href="#4-4-1-什么是分支？" class="headerlink" title="4.4.1 什么是分支？"></a>4.4.1 什么是分支？</h4><p>在版本控制过程中，使用多条线同时推进多个任务。</p><h4 id="4-4-2-分支的好处？"><a href="#4-4-2-分支的好处？" class="headerlink" title="4.4.2 分支的好处？"></a>4.4.2 分支的好处？</h4><p>同时并行推进多个功能开发，提高开发效率<br>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p><h4 id="4-4-3-分支操作"><a href="#4-4-3-分支操作" class="headerlink" title="4.4.3 分支操作"></a>4.4.3 分支操作</h4><p><strong>创建分支</strong> </p><pre class="line-numbers language-none"><code class="language-none">git branch [分支名] <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看分支</strong> </p><pre class="line-numbers language-none"><code class="language-none">git branch -v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>切换分支</strong></p><pre class="line-numbers language-none"><code class="language-none">git checkout [分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>合并分支</strong><br>第一步：切换到要接受修改的分支上 </p><pre class="line-numbers language-none"><code class="language-none">git checkout [原来的分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二步：执行 merge 命令 </p><pre class="line-numbers language-none"><code class="language-none">git merge [有新内容分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>解决冲突</strong></p><p>第一步：编辑文件，删除特殊符号<br>第二步：把文件修改到满意的程度，保存退出<br>第三步：git add [文件名]<br>第四步：git commit -m “日志信息”（后面不带文件名）</p><h2 id="5-Git-基本原理"><a href="#5-Git-基本原理" class="headerlink" title="5.Git 基本原理"></a>5.Git 基本原理</h2><h3 id="5-1-哈希"><a href="#5-1-哈希" class="headerlink" title="5.1 哈希"></a>5.1 哈希</h3><p>哈希是一个系列的加密算法，各个不同的哈希算法虽然加密强度不同，但是有以下 几个共同点：<br> ①不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定。<br>②哈希算法确定，输入数据确定，输出数据能够保证不变<br>③哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大<br>④哈希算法不可逆 Git 底层采用的是 SHA-1 算法。（MD5也是哈希算法的一种）<br>哈希算法可以被用来验证文件，Git 就是靠这种机制来从根本上保证数据完整性的。</p><h3 id="5-2-Git-保存版本的机制"><a href="#5-2-Git-保存版本的机制" class="headerlink" title="5.2 Git 保存版本的机制"></a>5.2 Git 保存版本的机制</h3><h4 id="5-2-1-集中式版本控制工具的文件管理机制"><a href="#5-2-1-集中式版本控制工具的文件管理机制" class="headerlink" title="5.2.1 集中式版本控制工具的文件管理机制"></a>5.2.1 集中式版本控制工具的文件管理机制</h4><p>以文件变更列表的方式存储信息。这类系统将它们保存的信息看作是一组基本 文件和每个文件随时间逐步累积的差异。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210105000016196.png" alt=""></p><h4 id="5-2-2-Git-的文件管理机制"><a href="#5-2-2-Git-的文件管理机制" class="headerlink" title="5.2.2 Git 的文件管理机制"></a>5.2.2 Git 的文件管理机制</h4><p>Git 把数据看作是小型文件系统的一组快照。每次提交更新时 Git 都会对当前 的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改， Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。所以 Git 的 工作方式可以称之为快照流。</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210105000029275.png" alt=""></p><h4 id="5-2-3-Git-文件管理机制细节"><a href="#5-2-3-Git-文件管理机制细节" class="headerlink" title="5.2.3 Git 文件管理机制细节"></a>5.2.3 Git 文件管理机制细节</h4><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104235138752.png" alt=""></p><p>提交对象及其父对象形成的链条</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104235208324.png" alt=""></p><h3 id="5-3-Git-分支管理机制"><a href="#5-3-Git-分支管理机制" class="headerlink" title="5.3 Git 分支管理机制"></a>5.3 Git 分支管理机制</h3><h4 id="5-3-1-分支的创建"><a href="#5-3-1-分支的创建" class="headerlink" title="5.3.1 分支的创建"></a>5.3.1 分支的创建</h4><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104235624280.png" alt=""></p><h4 id="5-3-2-分支的切换"><a href="#5-3-2-分支的切换" class="headerlink" title="5.3.2 分支的切换"></a>5.3.2 分支的切换</h4><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104235717453.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104235729611.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/github/image-20210104235745003.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com/public/images/github/image-20210104235758253.png" alt=""></p><h2 id="6-GitHub"><a href="#6-GitHub" class="headerlink" title="6.GitHub"></a>6.GitHub</h2><h3 id="6-2-创建远程库"><a href="#6-2-创建远程库" class="headerlink" title="6.2 创建远程库"></a>6.2 创建远程库</h3><h3 id="6-3-创建远程库地址别名"><a href="#6-3-创建远程库地址别名" class="headerlink" title="6.3 创建远程库地址别名"></a>6.3 创建远程库地址别名</h3><pre class="line-numbers language-none"><code class="language-none">git remote -v 查看当前所有远程地址别名git remote add [别名] [远程地址]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-4-推送"><a href="#6-4-推送" class="headerlink" title="6.4 推送"></a>6.4 推送</h3><pre class="line-numbers language-none"><code class="language-none">git push [别名] [分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-5-克隆"><a href="#6-5-克隆" class="headerlink" title="6.5 克隆"></a>6.5 克隆</h3><pre class="line-numbers language-none"><code class="language-none">git clone [远程地址]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果：<br>完整的把远程库下载到本地<br>创建远程地址别名<br>初始化本地库</p><h3 id="6-6-团队成员邀请"><a href="#6-6-团队成员邀请" class="headerlink" title="6.6 团队成员邀请"></a>6.6 团队成员邀请</h3><h3 id="6-7-拉取"><a href="#6-7-拉取" class="headerlink" title="6.7 拉取"></a>6.7 拉取</h3><pre class="line-numbers language-none"><code class="language-none">git pull [远程库地址别名] [远程分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>pull=fetch+merge</p><pre class="line-numbers language-none"><code class="language-none">git fetch [远程库地址别名] [远程分支名]git merge [远程库地址别名/远程分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-8-解决冲突"><a href="#6-8-解决冲突" class="headerlink" title="6.8 解决冲突"></a>6.8 解决冲突</h3><p>要点<br>如果不是基于 GitHub 远程库的最新版所做的修改，不能推送，必须先拉取。<br>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。</p><h3 id="6-9-跨团队协作"><a href="#6-9-跨团队协作" class="headerlink" title="6.9 跨团队协作"></a>6.9 跨团队协作</h3><p>Fork<br>本地修改，然后推送到远程<br>Pull Request</p><p>主人：<br>审核代码<br>合并代码<br>将远程库修改拉取到本地</p><h3 id="6-10-SSH-登录"><a href="#6-10-SSH-登录" class="headerlink" title="6.10 SSH 登录"></a>6.10 SSH 登录</h3><p>进入当前用户的家目录<br>$ cd ~<br>删除.ssh 目录<br>$ rm -rvf .ssh<br>运行命令生成.ssh 密钥目录<br>$ ssh-keygen -t rsa -C xxx@yyy.com<br>进入.ssh 目录查看文件列表<br>$ cd .ssh<br>$ ls -lF<br>查看 id_rsa.pub 文件内容<br>$ cat id_rsa.pub<br>复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys<br>New SSH Key<br>输入复制的密钥信息<br>回到 Git bash 创建远程地址别名<br>git remote add origin_ssh 网页上复制的ssh地址<br>推送文件进行测试</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++语言程序设计（1-5章）</title>
      <link href="2021/01/01/cpp/"/>
      <url>2021/01/01/cpp/</url>
      
        <content type="html"><![CDATA[<p><span style="color: #c31887;">第一次学是在2017上半年，大一的第二个学期，虽然当时学的挺不错，但是已经忘了许多，重新学一下。</span></p><p>使用的教材：C++语言程序设计（第4版）郑莉等</p><center><span style="color:blue;font-size:15px">2021/1/1</span></center><h2 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h2><h3 id="1-2-面向对象的方法"><a href="#1-2-面向对象的方法" class="headerlink" title="1.2 面向对象的方法"></a>1.2 面向对象的方法</h3><p><strong>对象</strong>：用来描述客观事物的一个实体，用来构成系统的一个基本单位，由<strong>一组属性</strong>和<strong>一组行为</strong>构成</p><p><strong>类</strong>：具有相同属性和服务的<strong>一组对象的集合</strong></p><p><strong>封装</strong>：把对象的属性和服务结合成一个独立的系统单位，并尽可能隐藏对象的内部细节</p><p><strong>继承</strong>：继承类的对象拥有其一般类的全部属性和服务，称作特殊类对一般类的继承</p><p><strong>多态性</strong>：在一般类中定义的属性或行为，被特殊可继承之后，可以具有不同的数据类型或表现出不同的行为</p><h3 id="1-4-信息的表示与存储"><a href="#1-4-信息的表示与存储" class="headerlink" title="1.4 信息的表示与存储"></a>1.4 信息的表示与存储</h3><h4 id="1-4-2-进制的转换"><a href="#1-4-2-进制的转换" class="headerlink" title="1.4.2 进制的转换"></a>1.4.2 进制的转换</h4><p>十进制转换2（或x）进制：</p><p>整数部分：除2取余</p><p>小数部分：乘2取整</p><p>然后拼在一起</p><h4 id="1-4-3-信息的存储单位"><a href="#1-4-3-信息的存储单位" class="headerlink" title="1.4.3 信息的存储单位"></a>1.4.3 信息的存储单位</h4><p><strong>位</strong>（bit）：1位二进制信息</p><p><strong>字节</strong>（Byte）：由8位二进制数字组成，是信息存储中最常用的基本单位</p><p><strong>字</strong>（Word）:字是位的组合，并作为一个独立的信息单位处理。常用的固定字长有8位、16位、32位等。</p><p><strong>机器字长</strong>：机器字长一般是指参加运算的寄存器所含有的二进制数的位数，它代表了机器的精度，如32位、64位等。</p><h4 id="1-4-4-二进制数的编码表示"><a href="#1-4-4-二进制数的编码表示" class="headerlink" title="1.4.4 二进制数的编码表示"></a>1.4.4 二进制数的编码表示</h4><p><strong>原码</strong>：符号数字位化为0（正）和1（负）</p><p><strong>反码</strong>：作为补码的中间码，正数不变，负数符号位不变，其余各位取反</p><p><strong>补码</strong>：正数不变，负数由反码的最末位加1</p><p>补码符号位可以作为数值参加运算，补码运算的结果仍为补码</p><h4 id="1-4-5-浮点数的表示"><a href="#1-4-5-浮点数的表示" class="headerlink" title="1.4.5 浮点数的表示"></a>1.4.5 浮点数的表示</h4><p>N：要表示的浮点数，用科学计数法写就是</p><script type="math/tex; mode=display">N=M*R^E</script><p>R：基数，计算机用2做基数</p><p>E：N的阶码</p><p>M：N的全部有效数字，称为N的尾数</p><p><img src="/images/cpp/123.png" alt="浮点数"></p><h4 id="1-4-6-数的表示范围（补码）"><a href="#1-4-6-数的表示范围（补码）" class="headerlink" title="1.4.6 数的表示范围（补码）"></a>1.4.6 数的表示范围（补码）</h4><p>8位整数的无符号数可以表示0 ~ +255</p><p>8位整数的有符号数可以表示-128 ~ +127（因为0占正数一个空间）</p><p>n位小数范围为 -$1$ ~ +$(1-2^{-n})$</p><p>为了同时满足对浮点数的范围和精度的要求，往往采用<strong>双倍字长</strong>甚至<strong>更多个字长</strong>来表示一个浮点数</p><h4 id="1-4-8-汉字英文信息的表示"><a href="#1-4-8-汉字英文信息的表示" class="headerlink" title="1.4.8 汉字英文信息的表示"></a>1.4.8 汉字英文信息的表示</h4><p>西文使用ASCII码来表示，使用一个字节中的7位来表示128个字符，剩下一位作为校验码</p><p>汉字可以使用GB2312（国标码），2字节码，用两个7位二进制数编码表示一个汉字（还有其他的编码方式）</p><h3 id="1-5-程序开发的基本概念"><a href="#1-5-程序开发的基本概念" class="headerlink" title="1.5 程序开发的基本概念"></a>1.5 程序开发的基本概念</h3><h4 id="1-5-1-基本术语"><a href="#1-5-1-基本术语" class="headerlink" title="1.5.1 基本术语"></a>1.5.1 基本术语</h4><p><strong>源程序</strong>：源代码</p><p><strong>目标程序</strong>：是源程序经过翻译加工后生成的程序，目标程序可以用机器语言或者汇编语言来表示</p><p><strong>翻译程序</strong>：把源程序翻译为目标程序的程序<br>                -汇编程序：把汇编语言翻译成机器语言形式的目标程序<br>                -编译程序：把高级语言翻译成目标程序<br>                -解释程序：也是把高级语言翻译成机器指令，但是不生成整个的目标程序，边翻译边执行，需要重复解释循环语句，效率较低</p><h4 id="1-5-2-完整的程序过程"><a href="#1-5-2-完整的程序过程" class="headerlink" title="1.5.2 完整的程序过程"></a>1.5.2 完整的程序过程</h4><div class="table-container"><table><thead><tr><th>编辑</th><th>编译</th><th>连接</th><th>运行</th></tr></thead><tbody><tr><td>.cpp</td><td>.obj</td><td>.exe</td></tr></tbody></table></div><p>连接是将多个目标文件以及库中的某些文件放在一起，生成exe</p><center><span style="color:blue;font-size:15px">2021/1/2</span></center><h2 id="第2章-C-简单程序设计"><a href="#第2章-C-简单程序设计" class="headerlink" title="第2章 C++简单程序设计"></a>第2章 C++简单程序设计</h2><h3 id="2-2-基本数据类型和表达式"><a href="#2-2-基本数据类型和表达式" class="headerlink" title="2.2 基本数据类型和表达式"></a>2.2 基本数据类型和表达式</h3><h4 id="2-2-1-基本数据类型"><a href="#2-2-1-基本数据类型" class="headerlink" title="2.2.1 基本数据类型"></a>2.2.1 基本数据类型</h4><p>变量的大小会根据编译器和所使用的电脑而有所不同</p><p>我电脑上的基本数据类型大小：</p><p><img src="/images/cpp/image-20210102143445587.png" alt="数据大小"></p><h4 id="2-2-2-常量"><a href="#2-2-2-常量" class="headerlink" title="2.2.2 常量"></a>2.2.2 常量</h4><p>八进制以0开头<br>十六进制以0x开头<br>字符常量用ASCII码存储，可以用转义字符’\‘输入<br>字符串常量末尾需要添加’\0’作为结尾标记</p><h4 id="2-2-3-变量"><a href="#2-2-3-变量" class="headerlink" title="2.2.3 变量"></a>2.2.3 变量</h4><p>16进制和指数形式的表示:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0x123</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"hex:"</span><span class="token operator">&lt;&lt;</span> hex <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">0.24E+2</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp/image-20210102145702550.png" alt="16进制"></p><h4 id="2-2-5-运算符与表达式"><a href="#2-2-5-运算符与表达式" class="headerlink" title="2.2.5 运算符与表达式"></a>2.2.5 运算符与表达式</h4><p>“%”的优先级与”/“相同</p><p>赋值表达式运算”=”的结合性为从右往左<br>    例：a=b=c=5</p><p><u><strong>复合的赋值运算符</strong></u>有10种，优先级与”=”相同，结合性也是从右往左<br>    例：a+=a-=a*a </p><p><strong><u>逗号运算符</u></strong>为”,”逗号表达式形式为 “表达式1,表达式2” ，求解顺序是先1后2，最终结果为表达式2的值<br>    例：a=3*5,a*4    最终结果为60</p><p><strong><u>关系运算符</u></strong>的优先级：<br>关系表达式的结果类型为bool，值只能是true或false<img src="/images/cpp/image-20210102151756711.png" alt="关系运算符"></p><p><strong><u>逻辑运算符</u></strong>的优先级：”!”&gt;”&amp;&amp;”&gt;”||”<br>    注意：“&amp;&amp;”和“||”运算具有短路特性<br>    “&amp;&amp;”的第一个值为false就不对第二个求值，“||”的第一个值为true就不对第二个求值</p><p><u><strong>条件运算符</strong></u>“?”是c++中唯一的一个三元运算符</p><p><strong><u>sizeof运算符</u></strong>用来计算<strong>某种类型</strong>的对象在内存中所占的字节数（是计算类型的，不对表达式求值）</p><p><u><strong>位运算</strong></u>：<br>c++提供了6个位运算符<br>（1）按位与（&amp;）：<br><img src="/images/cpp/image-20210102153802519.png" alt=""><br>可以将操作数中的任意位置0，其他位不变（如和11110111与）<br>也可以取出一个数的低字节（如和00001111与）<br>（2）按位或（|）：可以将操作数中的任意位置1，其他位不变（如和00001000或）<br>（3）按位异或（^）：可以将操作数中的若干位置翻转（取反）<br>（4）按位取反（~）：单目运算符，对每一位都取反<br>（5）移位（&lt;&lt;）（&gt;&gt;）：左移低位补0，高位舍弃，右移低位舍弃，高位补符号位（有符号的话）<br>        注意：移位运算的结果是表达式的值，不改变变量本身的值，如a&gt;&gt;2不改变a</p><p><strong><u>混合运算时数据类型的转换</u></strong>：<br>（1）隐含转换：操作数类型不一致时，编译系统会自动对数据进行转换（由低类型到高类型）<img src="/images/cpp/image-20210102160055384.png" alt="隐含转换"><br>（2）显式转换：如a=（int）b</p><h3 id="2-3-数据的输入与输出"><a href="#2-3-数据的输入与输出" class="headerlink" title="2.3 数据的输入与输出"></a>2.3 数据的输入与输出</h3><p>在C++中，<strong>将数据从一个对象到另一个对象的流动抽象为“<u>流</u>”。流在使用前要被建立，使用后要被删除。数据的输入与输出是通过I/O流来实现的</strong>，cin和cout是预定义的流类对象。cin用来处理标准输入，即键盘输入。cout用来处理标准输出，即屏幕输出。</p><h3 id="2-4-算法的基本控制结构"><a href="#2-4-算法的基本控制结构" class="headerlink" title="2.4 算法的基本控制结构"></a>2.4 算法的基本控制结构</h3><p>顺序结构，选择结构和循环结构</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//2_2.cpp 判断闰年</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> year<span class="token punctuation">;</span><span class="token keyword">bool</span> isLeapYear<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter the year:"</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> year<span class="token punctuation">;</span>isLeapYear <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>year <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> year <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>year <span class="token operator">%</span> <span class="token number">400</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isLeapYear<span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> year <span class="token operator">&lt;&lt;</span> <span class="token string">"is a leap year"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span>cout <span class="token operator">&lt;&lt;</span> year <span class="token operator">&lt;&lt;</span> <span class="token string">"is not a leap year"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>goto 语句</strong>允许把控制无条件转移到同一函数内的被标记的语句，goto 语句一个很好的作用是退出深嵌套例程。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">goto</span> label<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>label<span class="token operator">:</span> statement<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-自定义数据结构"><a href="#2-5-自定义数据结构" class="headerlink" title="2.5 自定义数据结构"></a>2.5 自定义数据结构</h3><p><strong>枚举</strong>（enumerate）类型 enum：<br>例：enum Weekday{SUN,MON,TUE,WED,THU,FRI,SAT};<br>对枚举元素按常量处理，不能对它们赋值<br>枚举元素具有默认值，依次为：0,1,2,···<br>也可以在声明时另行定义枚举元素的值，<br>如：enum Weekday{SUN=7,MON=1,TUE,WED,THU,FRI,SAT};<br>定义SUN为7，MON为1，以后顺序加1，SAT为6</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 2_11.cpp 枚举</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">GameResult</span> <span class="token punctuation">{</span> WIN<span class="token punctuation">,</span> LOST<span class="token punctuation">,</span> TIE<span class="token punctuation">,</span> CANAEL <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>GameResult result<span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">GameResult</span> omit <span class="token operator">=</span> CANAEL<span class="token punctuation">;</span><span class="token comment">//也可以在类型名前写enum     </span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> count <span class="token operator">=</span> WIN<span class="token punctuation">;</span> count <span class="token operator">&lt;=</span> CANAEL<span class="token punctuation">;</span> count<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//隐式类型转换</span>result <span class="token operator">=</span> <span class="token function">GameResult</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显式类型转换</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> omit<span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the game was cancelled"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the game was played"</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> WIN<span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"and we won!"</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> LOST<span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"and we lost."</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-深度探索"><a href="#2-6-深度探索" class="headerlink" title="2.6 深度探索"></a>2.6 深度探索</h3><h4 id="2-6-1-变量的实现机制"><a href="#2-6-1-变量的实现机制" class="headerlink" title="2.6.1 变量的实现机制"></a>2.6.1 变量的实现机制</h4><p>编译器需要根据变量的数据类型选择适当的指令，CPU所执行的指令并不对操作数的类型加以区分。<br>（因为两个不同类型的数，值不一样，但是他们的二进制形式可能一样）</p><h4 id="2-6-2-C-表达式的执行原理（汇编assembly）"><a href="#2-6-2-C-表达式的执行原理（汇编assembly）" class="headerlink" title="2.6.2 C++表达式的执行原理（汇编assembly）"></a>2.6.2 C++表达式的执行原理（汇编assembly）</h4><p>CPU的大部分读写操作都是对寄存器进行的，IA-32的通用寄存器有eax,ebx,ecx,edx,esp,ebp,esi,edi八个，都是32位寄存器。<br>例：$d=(a+b)*c$</p><pre class="line-numbers language-wasm" data-language="wasm"><code class="language-wasm">mov <span class="token number">0x80495dc</span>,%eax//将 <span class="token number">0x80495dc</span> 地址内的<span class="token number">32</span>位整数装入eax寄存器（<span class="token number">0x80495dc</span>为内存地址，在cpu处理需放入寄存器）mov <span class="token number">0x80495d8</span>,%ecx//将 <span class="token number">0x80495d8</span> 地址内的<span class="token number">32</span>位整数装入ecx寄存器add %eax,%ecx//将 eax 和 ecx 两寄存器内的数相加，结果放在ecx寄存器中mov <span class="token number">0x80495e4</span>,%eax//将 <span class="token number">0x80495e4</span> 地址内的<span class="token number">32</span>位证书装入eax寄存器imul %ecx,%eax//将 eax 和 ecx 寄存器中的两个<span class="token number">32</span>位有符号整数相乘,得到一个<span class="token number">64</span>//位整数,结果的低<span class="token number">32</span>位放入 eax 寄存器,高<span class="token number">32</span>位放入 edx 寄存器（d也是<span class="token number">32</span>位整数，所以只取低<span class="token number">32</span>位）mov %eax,<span class="token number">0x80495e4</span>//将 eax 寄存器中的<span class="token number">32</span>位证书存入 <span class="token number">0x80495e4</span> 地址中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>2-1 C++语言有哪些主要特点和优点？<br>答：<br>优点：性能优势，触碰底层；<br>缺点：难学，开发时间慢成本高，大型项目或者图形编程更需要，垃圾处理不如java，指针操作会带来不安全；</p><center><span style="color:blue;font-size:15px">2021/1/3</span></center><h2 id="第3章-函数"><a href="#第3章-函数" class="headerlink" title="第3章 函数"></a>第3章 函数</h2><h3 id="3-1-函数的定义与使用"><a href="#3-1-函数的定义与使用" class="headerlink" title="3.1 函数的定义与使用"></a>3.1 函数的定义与使用</h3><h4 id="3-1-2-函数的调用"><a href="#3-1-2-函数的调用" class="headerlink" title="3.1.2 函数的调用"></a>3.1.2 函数的调用</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 3_2.cpp 将八位二进制数转换为十进制</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//计算x的n次方</span><span class="token keyword">double</span> <span class="token function">power</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter an 8 bit binary number:"</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">char</span> ch<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> ch<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span>value <span class="token operator">+=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">power</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Decimal value is "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">power</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">double</span> val <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>val <span class="token operator">*=</span> x<span class="token punctuation">;</span><span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//3_4.cpp 寻找并输出11~999之间的数m，它满足m,m^2,m^3均为回文数。</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">symm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">unsigned</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token keyword">unsigned</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>m <span class="token operator">=</span> m <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> i <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>i <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> m <span class="token operator">==</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> m <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span> m <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> m<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">symm</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">symm</span><span class="token punctuation">(</span>m <span class="token operator">*</span> m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">symm</span><span class="token punctuation">(</span>m <span class="token operator">*</span> m <span class="token operator">*</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"m="</span> <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" m*m="</span> <span class="token operator">&lt;&lt;</span> m <span class="token operator">*</span> m<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" m*m*m="</span> <span class="token operator">&lt;&lt;</span> m <span class="token operator">*</span> m <span class="token operator">*</span> m <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>递归调用：</strong><br>递归算法的实质是将原有的问题分解为新的问题，而解决新问题时又用到了原来问题的解法。按照这一原则分解下去，每次出现的新问题都是原有问题的简化的子集，而最终分解出来的问题，是一个已知解的问题，这便是有限的递归调用。只有有限的递归调用才是有意义的。<br>递归的过程有两个阶段:<br><strong>第一阶段：递推</strong> 将原问题不断分解为新的子问题，逐渐从未知向已知推进，最终到达已知的条件。<br><strong>第二阶段：回归</strong> 从已知的问题出发，按照递推的逆过程，逐一求值回归，最后达到递推的开始处。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//3_9.cpp 计算从n个人里选k个人的组合数</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">comn</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> n<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> k <span class="token operator">||</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">comn</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">comn</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please enter two integers n and k:"</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> n <span class="token operator">&gt;&gt;</span> k<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"C(n,k)="</span> <span class="token operator">&lt;&lt;</span> <span class="token function">comn</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//3_10.cpp 汉诺塔问题</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> movecount<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//把src针的最上面一个盘子移动到dest针上</span><span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">char</span> src<span class="token punctuation">,</span> <span class="token keyword">char</span> dest<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> src <span class="token operator">&lt;&lt;</span> <span class="token string">"--&gt;"</span> <span class="token operator">&lt;&lt;</span> dest <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>movecount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//把n个盘子从src针移动到dest针，以medium针为中介</span><span class="token keyword">void</span> <span class="token function">hanoi</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> src<span class="token punctuation">,</span> <span class="token keyword">char</span> medium<span class="token punctuation">,</span> <span class="token keyword">char</span> dest<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token function">move</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">hanoi</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> src<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> medium<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">move</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">hanoi</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> medium<span class="token punctuation">,</span> src<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> m<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter the number of diskes: "</span><span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> m<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the steps to moving "</span> <span class="token operator">&lt;&lt;</span> m <span class="token operator">&lt;&lt;</span> <span class="token string">" diskes:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">hanoi</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"total move number: "</span> <span class="token operator">&lt;&lt;</span> movecount<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-3-函数的参数传递"><a href="#3-1-3-函数的参数传递" class="headerlink" title="3.1.3 函数的参数传递"></a>3.1.3 函数的参数传递</h4><p>在函数未被调用时，函数的形参并不占有实际的内存空间，也没有实际的值。只有在函数被调用时才为形参分配粗存储单元，并将实参与形参结合。</p><p><strong>1.值传递</strong>：（直接将实参的值传递给形参）<br>这一过程是参数值的单向传递过程，一旦形参获得了值便与实参脱离关系，以后形参的变化不会影响实参。</p><p><strong>2.引用传递：</strong><br>引用是一种特殊类型的变量，可以被认为是另一个变量的别名，声明一个引用时，必须同时对它进行初始化，使他指向一个已存在的对象，一旦一个引用被初始化后，就不能改为指向其他对象。将引用作为形参，在调用表达式时，才为形参分配内存空间，同时用实参来初始化形参。这样引用类型的形参就通过形实结合，成为了实参的一个别名，对形参的任何操作也就会直接作用于实参。</p><h3 id="3-2-内联函数"><a href="#3-2-内联函数" class="headerlink" title="3.2 内联函数"></a>3.2 内联函数</h3><p>对于一些功能简单，规模较小而又使用频繁的函数，可以设计为内联函数。内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌在每一个调用处。这样就节省了参数传递，控制转移等开销。<br>内联函数的定义只需要使用关键字inline</p><p><strong>注意</strong>：内联只是一个请求，编译器并不承诺将inline修饰的函数作为内联，多数编译器会自动判断处理，如递归函数编译器会只内联到一定深度或根本不内联</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//3_14.cpp 内联函数应用举例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> PI <span class="token operator">=</span> <span class="token number">3.14159265358979</span><span class="token punctuation">;</span><span class="token comment">//内联函数，根据圆的半径计算其面积</span><span class="token keyword">inline</span> <span class="token keyword">double</span> <span class="token function">calArea</span><span class="token punctuation">(</span><span class="token keyword">double</span> radius<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> PI <span class="token operator">*</span> radius <span class="token operator">*</span> radius<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">//调用内联函数求圆面积，编译时此处被替换为calArea函数体语句</span><span class="token keyword">double</span> area <span class="token operator">=</span> <span class="token function">calArea</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> area <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-带默认形参值的函数"><a href="#3-3-带默认形参值的函数" class="headerlink" title="3.3 带默认形参值的函数"></a>3.3 带默认形参值的函数</h3><p>函数在定义时可以预先声明默认的形参值。调用时如果给出实参，则用实参初始化形参，如果没有给出实参，则采用预先声明的默认形参值。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有默认值的形参必须在形参列表的最后，也就是说，在有默认值的形参右面，不能出无默认值的形参。</p><p><strong>在相同的作用域内</strong>，不允许在同一个函数的多个声明中对同一个参数的默认值重复定义，即使前后定义的值相同也不行。</p><h3 id="3-4-函数重载"><a href="#3-4-函数重载" class="headerlink" title="3.4 函数重载"></a>3.4 函数重载</h3><p>两个以上的函数，具有相同的函数名，但形参的个数或者类型不同，编译器根据实参和形参的类型及个数的最佳匹配，自动确定调用哪一个函数，这就是函数的重载</p><p><img src="/images/cpp/image-20210104011010905.png" alt="函数重载"></p><h3 id="3-5-系统函数"><a href="#3-5-系统函数" class="headerlink" title="3.5 系统函数"></a>3.5 系统函数</h3><p>可以访问zh.cppreference.com查阅常用的C++函数的原型，头文件和用法</p><h3 id="3-6-深度探索"><a href="#3-6-深度探索" class="headerlink" title="3.6 深度探索"></a>3.6 深度探索</h3><h4 id="3-6-1-运行栈与函数调用的执行"><a href="#3-6-1-运行栈与函数调用的执行" class="headerlink" title="3.6.1 运行栈与函数调用的执行"></a>3.6.1 运行栈与函数调用的执行</h4><p>嵌套调用使用运行栈来存储数据，执行过程见课本p91</p><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//t3_9.cpp 编写函数判别一个数是否是质数（素数），在主程序中实现输入输出</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cmath&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">is_prime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>is_prime<span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">"是素数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span>cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">"不是素数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//t3_10 编写函数求两个整数的最大公约数和最小公倍数</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//辗转相除法</span><span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">%</span> b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">lcm</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">*</span> b <span class="token operator">/</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最大公约数："</span> <span class="token operator">&lt;&lt;</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最小公倍数："</span> <span class="token operator">&lt;&lt;</span> <span class="token function">lcm</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//t3_13.cpp 用递归的方式编写函数求Fibonacci(斐波那契)级数，观察调用的过程</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第4章-类与对象"><a href="#第4章-类与对象" class="headerlink" title="第4章 类与对象"></a>第4章 类与对象</h2><h3 id="4-1-面向对象程序设计的基本特点"><a href="#4-1-面向对象程序设计的基本特点" class="headerlink" title="4.1 面向对象程序设计的基本特点"></a>4.1 面向对象程序设计的基本特点</h3><h4 id="4-1-1-抽象"><a href="#4-1-1-抽象" class="headerlink" title="4.1.1 抽象"></a>4.1.1 抽象</h4><p>抽象是对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程。<br>首先注意的是问题的本质及描述，其次是解决问题的具体过程<br>对一个问题的抽象应该包括两个方面:数据抽象和行为抽象（或称为功能抽象、代码抽象）<br>前者描述某类对象的属性或状态，后者描述某类对象的共同行为或功能特征<br>例：一个时钟<br>数据抽象：int hour,int minute,int second<br>功能抽象：showTime（）,setTime（）</p><h4 id="4-1-2-封装"><a href="#4-1-2-封装" class="headerlink" title="4.1.2 封装"></a>4.1.2 封装</h4><p>封装就是将抽象得到的数据和行为相结合，形成一个有机的整体，也就是将数据与操作数据的函数代码进行有机的结合，形成”类“，其中的数据和函数都是类的成员</p><p><img src="/images/cpp/image-20210104012147193.png" alt="时钟类"></p><h4 id="4-1-3-继承"><a href="#4-1-3-继承" class="headerlink" title="4.1.3 继承"></a>4.1.3 继承</h4><p>C++语言中提供了类的继承机制，允许程序员在保持原有类特性的基础上，进行更具体更详细的说明。<br>——详见第7章</p><h4 id="4-1-4-多态"><a href="#4-1-4-多态" class="headerlink" title="4.1.4 多态"></a>4.1.4 多态</h4><p>从广义上说，多态性是指一段程序能够处理多种类型对象的能力。在C++语言中，这种多态性可以通过强制多态、重载多态、类型参数化多态、包含多态4种形式来实现。<br>包含多态和类型参数化多态属于一般多态性，是真正的多态性。C++中采用虚函数实现包含多态。虚函数是多态性的精华，将在第8章介绍。模板是C++实现参数化多态性的工具，将在第9章介绍。</p><center><span style="color:blue;font-size:15px">2021/1/4</span></center><h3 id="4-2-类和对象"><a href="#4-2-类和对象" class="headerlink" title="4.2 类和对象"></a>4.2 类和对象</h3><h4 id="4-2-2-类成员的访问控制"><a href="#4-2-2-类成员的访问控制" class="headerlink" title="4.2.2 类成员的访问控制"></a>4.2.2 类成员的访问控制</h4><p>对类成员的访问权限的控制，是通关设置成员的访问控制属性而实现的。访问控制性可以有以下3种：公有类型（public）私有类型（private）和保护类型（protected）<br>公有类型成员定义了类的外部接口<br>私有成员只能被本类的成员函数访问，来自类外部的任何访问都是非法的<br>保护类型成员的性质和私有成员的性质相似，其差别在于继承过程中对产生的新类影响不同（详见第7章）<br>在类中，对于未指定任何访问控制属性的成员，其访问控制属性为私有类型<br>习惯：在书写时通畅将公有类型放在最前面，这样便于阅读，因为它们是外部访问时所要了解的</p><center><span style="color:blue;font-size:15px">2021/1/5</span></center><h4 id="4-2-3-对象"><a href="#4-2-3-对象" class="headerlink" title="4.2.3 对象"></a>4.2.3 对象</h4><p>类实际上是一种抽象机制，它描述了一类事物的共同属性和行为。在C++中，类的对象就是该类的某一特定实体（也称实例）</p><p><strong>注意</strong>：对象所占据的内存空间只是用于存放数据成员，函数成员不在每一个对象中存储副本，每个函数的代码在内存中只占据一份空间。</p><p>在类的外部只能访问到类的共有成员；在类的成员函数中，可以访问到类的全部成员</p><h4 id="4-2-4-类的成员函数"><a href="#4-2-4-类的成员函数" class="headerlink" title="4.2.4 类的成员函数"></a>4.2.4 类的成员函数</h4><h5 id="1-成员函数的实现"><a href="#1-成员函数的实现" class="headerlink" title="1.成员函数的实现"></a>1.成员函数的实现</h5><p>函数的原型声明要写在类体中，原型说明了函数的参数表和返回值类型。而函数的具体实现是写在类定义外的。</p><p>类的成员函数需要用类名来限制，例如”Clock::ShowTime”</p><h5 id="2-成员函数中的目的对象"><a href="#2-成员函数中的目的对象" class="headerlink" title="2.成员函数中的目的对象"></a>2.成员函数中的目的对象</h5><p>调用一个成员函数与调用普通函数的差异在于，需要使用“.”操作符指出调用所针对的对象，这一对象在本次调用中称为目的对象。例如使用myClock.showTime（）调用showTime函数时，myClock就是这一调用过程中的目的对象。</p><p><strong>注意</strong>：在类的成员函数中，既可以访问目的对象的私有成员，又可以访问当前类的其他对象的私有成员</p><h5 id="3-带默认形参值的成员函数"><a href="#3-带默认形参值的成员函数" class="headerlink" title="3.带默认形参值的成员函数"></a>3.带默认形参值的成员函数</h5><p>类的成员函数也可以有默认形参值，其调用规则与普通函数相同</p><h5 id="4-内联成员函数"><a href="#4-内联成员函数" class="headerlink" title="4.内联成员函数"></a>4.内联成员函数</h5><p>要在权衡利弊的基础上慎重选择，只有对相对简单的成员函数才可以声明为内联函数。</p><p>内联函数的声明有两种方法：隐式声明和显式声明</p><p>隐式声明：将函数体直接放在类体内</p><p><img src="/images/cpp/image-20210105124151720.png" alt="隐式声明"></p><p>显式声明：在函数体实现时，在函数返回值类型前加上inline</p><p>显式声明和隐式声明的效果是完全相同的</p><h4 id="4-2-5-程序实例"><a href="#4-2-5-程序实例" class="headerlink" title="4.2.5 程序实例"></a>4.2.5 程序实例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//4_1.cpp 时钟类的完整程序</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Clock</span> <span class="token punctuation">{</span><span class="token comment">//时钟类的定义</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//外部接口，公有成员函数</span><span class="token keyword">void</span> <span class="token function">setTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> newH <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> newM <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> newS <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token comment">//私有数据成员</span><span class="token keyword">int</span> hour<span class="token punctuation">,</span> minute<span class="token punctuation">,</span> second<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//时钟类成员函数的具体实现</span><span class="token keyword">void</span> <span class="token class-name">Clock</span><span class="token operator">::</span><span class="token function">setTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> newH<span class="token punctuation">,</span> <span class="token keyword">int</span> newM<span class="token punctuation">,</span> <span class="token keyword">int</span> newS<span class="token punctuation">)</span> <span class="token punctuation">{</span>hour <span class="token operator">=</span> newH<span class="token punctuation">;</span>minute <span class="token operator">=</span> newM<span class="token punctuation">;</span>second <span class="token operator">=</span> newS<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">Clock</span><span class="token operator">::</span><span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> hour <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> minute <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Clock myclock<span class="token punctuation">;</span><span class="token comment">//定义对象myclock</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"First time set and output:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>myclock<span class="token punctuation">.</span><span class="token function">setTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myclock<span class="token punctuation">.</span><span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Second time set and output"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>myclock<span class="token punctuation">.</span><span class="token function">setTime</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myclock<span class="token punctuation">.</span><span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-构造函数和析构函数"><a href="#4-3-构造函数和析构函数" class="headerlink" title="4.3 构造函数和析构函数"></a>4.3 构造函数和析构函数</h3><h4 id="4-3-1-构造函数"><a href="#4-3-1-构造函数" class="headerlink" title="4.3.1 构造函数"></a>4.3.1 构造函数</h4><p>构造函数的作用是在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的状态。<br>只要有了构造函数，编译器就会在建立新对象的地方自动插入对构造函数调用的代码。<br>调用时无需提供参数的构造函数称为<strong>默认构造函数</strong>，如果类中没有写构造函数，编译器会自动生成一个隐含的默认构造函数，该构造函数的参数列表和函数体皆为空。如果在类中声明了构造函数，编译器便不会生成默认构造函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">/*编译系统生成的隐含的默认构造函数*/</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>构造函数</strong>的函数名与类名相同，而且没有返回值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Clock</span><span class="token punctuation">(</span><span class="token keyword">int</span> NewH<span class="token punctuation">,</span> <span class="token keyword">int</span> NewM<span class="token punctuation">,</span> <span class="token keyword">int</span> NewS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造函数</span>    <span class="token keyword">void</span> <span class="token function">SetTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> NewH<span class="token punctuation">,</span> <span class="token keyword">int</span> NewM<span class="token punctuation">,</span> <span class="token keyword">int</span> NewS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">ShowTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> Hour<span class="token punctuation">,</span> Minute<span class="token punctuation">,</span> Second<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//构造函数的实现：</span><span class="token class-name">Clock</span><span class="token operator">::</span><span class="token function">Clock</span><span class="token punctuation">(</span><span class="token keyword">int</span> NewH<span class="token punctuation">,</span> <span class="token keyword">int</span> NewM<span class="token punctuation">,</span> <span class="token keyword">int</span> NewS<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Hour <span class="token operator">=</span> NewH<span class="token punctuation">;</span>    Minute <span class="token operator">=</span> NewM<span class="token punctuation">;</span>    Second <span class="token operator">=</span> NewS<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作为类的成员函数，构造函数可以直接访问类的所有数据成员，可以是内联函数，可以带有参数表，可以带默认的形参值，也可以重载</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Clock</span> <span class="token punctuation">(</span><span class="token keyword">int</span> newH<span class="token punctuation">,</span> <span class="token keyword">int</span> newM<span class="token punctuation">,</span> <span class="token keyword">int</span> newS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造函数</span>    <span class="token function">Clock</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//构造函数</span>         hour<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>         minute<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>         second<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> newH<span class="token punctuation">,</span> <span class="token keyword">int</span> newM<span class="token punctuation">,</span> <span class="token keyword">int</span> newS<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">void</span> <span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> hour<span class="token punctuation">,</span>minute<span class="token punctuation">,</span>second<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//其他函数实现略</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Clock <span class="token function">c1</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用有参数的构造函数</span>    Clock c2<span class="token punctuation">;</span> <span class="token comment">//调用无参数的构造函数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-2-复制构造函数"><a href="#4-3-2-复制构造函数" class="headerlink" title="4.3.2 复制构造函数"></a>4.3.2 复制构造函数</h4><p>复制构造函数是一种特殊的构造函数，其形参为本类的对象的引用。<br>其作用是使用一个已经存在的对象（由复制构造函数的参数指定），去初始化同类的一个新对象。<br>如果没有定义类的复制构造函数，系统就会在必要时自动生成一个隐含的复制构造函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>   <span class="token keyword">public</span><span class="token operator">:</span>       <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> xx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span> yy<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//构造函数</span>          X<span class="token operator">=</span>xx<span class="token punctuation">;</span> Y<span class="token operator">=</span>yy<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token function">Point</span><span class="token punctuation">(</span>Point <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//复制构造函数</span>       <span class="token keyword">int</span> <span class="token function">GetX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> X<span class="token punctuation">;</span><span class="token punctuation">}</span>       <span class="token keyword">int</span> <span class="token function">GetY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> Y<span class="token punctuation">;</span><span class="token punctuation">}</span>   <span class="token keyword">private</span><span class="token operator">:</span>       <span class="token keyword">int</span>  X<span class="token punctuation">,</span>Y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//复制构造函数的实现</span><span class="token class-name">Point</span><span class="token operator">::</span><span class="token function">Point</span><span class="token punctuation">(</span>Point <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>      X<span class="token operator">=</span>p<span class="token punctuation">.</span>X<span class="token punctuation">;</span>      Y<span class="token operator">=</span>p<span class="token punctuation">.</span>Y<span class="token punctuation">;</span>      cout<span class="token operator">&lt;&lt;</span><span class="token string">"Calling the copy constructor"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通构造函数是在对象创建时被调用，而复制构造函数在以下3种情况下都会被调用。</p><p>（1）当用类的一个对象去初始化该类的另一个对象时。例如</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Point <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Point <span class="token function">b</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//用对象a初始化对象b，复制构造函数被调用</span>    Point c<span class="token operator">=</span>a<span class="token punctuation">;</span>   <span class="token comment">//用对象a初始化对象c，复制构造函数被调用</span>    cout<span class="token operator">&lt;&lt;</span>b<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细节:以上对b和c的初始化都能够调用复制构造函数，两种写法只是形式上有所不同，执行的操作完全相同。</p><p>（2）如果函数的形参是类的对象，调用函数时，进行形参和实参结合时。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>Point p<span class="token punctuation">)</span><span class="token punctuation">{</span>   cout<span class="token operator">&lt;&lt;</span>p<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   Point <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//函数的形参为类的对象，当调用函数时，复制构造函数被调用</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提示：只有把对象用值传递时，才会调用复制构造函数，如果传递引用，则不会调用复制构造函数。<br>由于这一原因，传递比较大的对象时，传递引用会比传值的效率高很多。</p><p>（3）如果函数的返回值是类的对象，函数执行完成返回调用者时。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Point <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       Point <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token comment">//函数的返回值是类对象，返回函数值时，调用复制构造函数</span><span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   Point b<span class="token punctuation">;</span>    b<span class="token operator">=</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//       </span><span class="token punctuation">}</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么在这种情况下，返回函数值时，会调用复制构造函数呢？表面上函数g将a返回给了主函数，但是a是g（）的局部对象，离开建立它的函数g以后就消亡了，不可能在返回主函数后继续生存，所以在处理这种情况时编译系统会在主函数中创建一个无名临时对象，该临时对象的生存期只在函数调用所处的表达式中，也就是表达式”b=g（）”中。执行语句”return a，”时，实际上是调用复制构造函数将a的值复制到临时对象中。函数g运行结束时对象a消失，但临时对象会存在于表达式”b=g（）”中。计算完这个表达式后，临时对象的使命也就完成了，该临时对象便自动消失。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//4_2.cpp 复制构造函数的3种情况</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> xx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> yy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> xx<span class="token punctuation">;</span>y <span class="token operator">=</span> yy<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Point</span><span class="token punctuation">(</span>Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">gety</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Point</span><span class="token operator">::</span><span class="token function">Point</span><span class="token punctuation">(</span>Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> p<span class="token punctuation">.</span>x<span class="token punctuation">;</span>y <span class="token operator">=</span> p<span class="token punctuation">.</span>y<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Calling the copy constructor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//形参为Point类对象的函数</span><span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span>Point p<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">getx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//返回值为Point类对象的函数</span>Point <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Point <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Point <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Point b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//情况一，用a初始化b。第一次调用复制构造函数</span>cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span><span class="token function">getx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">fun1</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//情况二，对象b作为fun1的实参。第二次调用复制构造函数</span>cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span><span class="token function">getx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//情况三，函数的返回值是类对象，函数返回时，调用复制构造函数</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-3-析构函数"><a href="#4-3-3-析构函数" class="headerlink" title="4.3.3 析构函数"></a>4.3.3 析构函数</h4><p>简单来说，析构函数与构造函数的作用几乎正好相反，它用来完成对象被删除前的一些清理工作，也就是专门做扫尾工作的。析构函数是在对象的生存期即将结束的时刻被<strong>自动调用</strong>的。它的调用完成之后，对象也就消失了，相应的内存空间也被释放。<br>与构造函数一样，析构函数通常也是类的一个公有函数成员，它的名称是由<strong>类名前面加“~”</strong>构成，没有返回值。和构造函数不同的是析构函数不接收任何参数，但可以是虚函数（将在第8章介绍）。如果不进行显式说明，系统也会生成一个函数体为空的隐含析构函数。<br>如果希望程序在对象被删除之前的时刻自动（不需要人为进行函数调用）完成某些事情，就可以把它们写到析构函数中。</p><h4 id="4-3-4-程序实例"><a href="#4-3-4-程序实例" class="headerlink" title="4.3.4 程序实例"></a>4.3.4 程序实例</h4><p>例题：游泳池改造预算，Circle类<br>一圆型游泳池如图所示，现在需在其周围建一圆型过道，并在其四周围上栅栏。栅栏价格为35元/米，过道造价为20元/平方米。过道宽度为3米，游泳池半径由键盘输入。要求编程计算并输出过道和栅栏的造价。<br><img src="/images/cpp/862591-20200301235232229-39158544.png" alt=""></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//4_3.cpp 游泳池改造预算</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">float</span> PI <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">float</span> FENCE_PRICE <span class="token operator">=</span> <span class="token number">35</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">float</span> CONCRETE_PRICE <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>                              <span class="token comment">//声明类Circle 及其数据和方法</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">float</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//构造函数</span>    <span class="token keyword">float</span> <span class="token function">circumference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">//圆周长</span>    <span class="token keyword">float</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//园面积</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">float</span> radius<span class="token punctuation">;</span>                           <span class="token comment">//圆半径</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 类的实现</span><span class="token comment">// 构造函数初始化数据成员radius</span><span class="token class-name">Circle</span><span class="token operator">::</span><span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">float</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    radius <span class="token operator">=</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 计算圆的周长</span><span class="token keyword">float</span> <span class="token class-name">Circle</span><span class="token operator">::</span><span class="token function">circumference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> PI <span class="token operator">*</span> radius<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 计算圆的面积</span><span class="token keyword">float</span> <span class="token class-name">Circle</span><span class="token operator">::</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> PI <span class="token operator">*</span> radius <span class="token operator">*</span> radius<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">float</span> radius<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter the radius of the pool: "</span><span class="token punctuation">;</span>    cin <span class="token operator">&gt;&gt;</span> radius<span class="token punctuation">;</span>    Circle <span class="token function">Pool</span><span class="token punctuation">(</span>radius<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//游泳池边界对象</span>    Circle <span class="token function">PoolRim</span><span class="token punctuation">(</span>radius <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">//栅栏对象</span>    <span class="token comment">// 计算栅栏造价并输出</span>    <span class="token keyword">float</span> fenceCost <span class="token operator">=</span> PoolRim<span class="token punctuation">.</span><span class="token function">circumference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> FENCE_PRICE<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Fencing Cost is $"</span> <span class="token operator">&lt;&lt;</span> fenceCost <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">//  计算过道造价并输出</span>    <span class="token keyword">float</span> concreteCost <span class="token operator">=</span> <span class="token punctuation">(</span>PoolRim<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> Pool<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span>CONCRETE_PRICE<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Concrete Cost is $"</span> <span class="token operator">&lt;&lt;</span> concreteCost <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-类的组合"><a href="#4-4-类的组合" class="headerlink" title="4.4 类的组合"></a>4.4 类的组合</h3><p>在面向对象程序设计中，可以对复制对象进行分解，抽象，把一个复制对象分解为简单对象的组合</p><h4 id="4-4-1-组合"><a href="#4-4-1-组合" class="headerlink" title="4.4.1 组合"></a>4.4.1 组合</h4><p>当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建。在创建对象时既要对本类的基本类型数据进行初始化，又要对内嵌对象成员进行初始化。<br>构造函数的调用顺序如下：<br>（1）调用内嵌对象的构造函数，调用顺序按照内嵌对象在组合类的定义中出现的次序<br>（2）执行本类构造函数的函数体<br>析构函数的调用执行顺序与构造函数刚好相反</p><center><span style="color:blue;font-size:15px">2021/1/6</span></center><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//4_4.cpp 类的组合，线段（line）类</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cmath&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//Point类定义</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> xx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> yy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> xx<span class="token punctuation">;</span>y <span class="token operator">=</span> yy<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Point</span><span class="token punctuation">(</span>Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Point</span><span class="token operator">::</span><span class="token function">Point</span><span class="token punctuation">(</span>Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> p<span class="token punctuation">.</span>x<span class="token punctuation">;</span>y <span class="token operator">=</span> p<span class="token punctuation">.</span>y<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Calling the copy constructor of Point"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//类的组合</span><span class="token keyword">class</span> <span class="token class-name">Line</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Line</span><span class="token punctuation">(</span>Point xp1<span class="token punctuation">,</span> Point xp2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Line</span><span class="token punctuation">(</span>Line<span class="token operator">&amp;</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>Point p1<span class="token punctuation">,</span> p2<span class="token punctuation">;</span><span class="token keyword">double</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//组合类的构造函数</span><span class="token class-name">Line</span><span class="token operator">::</span><span class="token function">Line</span><span class="token punctuation">(</span>Point xp1<span class="token punctuation">,</span> Point xp2<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p1</span><span class="token punctuation">(</span>xp1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p2</span><span class="token punctuation">(</span>xp2<span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Calling constructor of Line"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> p2<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> p2<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>len <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x <span class="token operator">+</span> y <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//组合类的复杂构造函数</span><span class="token class-name">Line</span><span class="token operator">::</span><span class="token function">Line</span><span class="token punctuation">(</span>Line<span class="token operator">&amp;</span> l<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">p1</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>p1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p2</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Callint the copy constructor of Line"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>len <span class="token operator">=</span> l<span class="token punctuation">.</span>len<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Point <span class="token function">myp1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">myp2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Line <span class="token function">line</span><span class="token punctuation">(</span>myp1<span class="token punctuation">,</span> myp2<span class="token punctuation">)</span><span class="token punctuation">;</span>Line <span class="token function">line2</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The length of the line is: "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> line<span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The length of the line2 is: "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> line2<span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp/image-20210106101543263.png" alt="运行结果"></p><h4 id="4-4-2-向前引用声明"><a href="#4-4-2-向前引用声明" class="headerlink" title="4.4.2 向前引用声明"></a>4.4.2 向前引用声明</h4><p>如果遇到两个类相互引用的情况，应使用前向引用声明</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Fred</span><span class="token punctuation">;</span><span class="token comment">//前向引用声明</span>  <span class="token keyword">class</span> <span class="token class-name">Barney</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     x<span class="token punctuation">.</span><span class="token function">yabbaDabbaDo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//错误：Fred类的对象在定义之前被使用</span>   <span class="token punctuation">}</span> <span class="token keyword">private</span><span class="token operator">:</span>   Fred <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>   <span class="token comment">//正确，经过前向引用声明，可以声明Fred类的对象指针</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">class</span> <span class="token class-name">Fred</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">void</span> <span class="token function">yabbaDabbaDo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">private</span><span class="token operator">:</span>   Barney <span class="token operator">&amp;</span>y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器在编译时会指出错误，因为在类Barney的内联函数中使用了由x所指向的Fred类的对象，而此时Fred类尚未被完整地定义。解决这个问题的方法是，更改这两个类的定义次序，或者将函数method()改为非内联形式，并且在类Fred的完整定义之后，再给出函数的定义。</p><p><strong>注意</strong>：当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。</p><h3 id="4-5-UML图形标识"><a href="#4-5-UML图形标识" class="headerlink" title="4.5 UML图形标识"></a>4.5 UML图形标识</h3><p>UML语言是一个复杂、庞大的系统建模语言，其目标是希望能够解决整个面向对象软件开发过程中的可视化建模。</p><h4 id="4-5-1-UML简介"><a href="#4-5-1-UML简介" class="headerlink" title="4.5.1 UML简介"></a>4.5.1 UML简介</h4><p>统一建模语言UML ( Unified Modeling Language)</p><p>UML语言是一种典型的面向对象建模语言，而不是一种编 程语言，在UMI语言中用符号描述概念，概念间的关系描述为连接符号的线。</p><p>标准建模语言UML的重要内容是各种类型的图形，分别描述软件模型的静态结构、动态行为及模块组织和管理。本书主要使用UML中的图形来描述软件中类和对象以及它们的静态关系，使用了最基本的类图(classdiagram)，它属于静态结构图(staticstructure diagrams)的一种。</p><h4 id="4-5-2-UML类图"><a href="#4-5-2-UML类图" class="headerlink" title="4.5.2 UML类图"></a>4.5.2 UML类图</h4><p>1.类和对象</p><p><img src="/images/cpp/image-20210106124232727.png" alt="UML类图例"></p><p>2.几种关系的图形标识</p><p>（1）依赖关系</p><p><img src="/images/cpp/image-20210106124626064.png" alt="依赖关系"></p><p>（2）作用关系——关联</p><p><img src="/images/cpp/image-20210106124647931.png" alt="关联关系"></p><p>（3）包含关系——聚集和组合</p><p><img src="/images/cpp/image-20210106125143796.png" alt="包含关系"></p><p>（4）继承关系——泛化</p><p><img src="/images/cpp/image-20210106125427699.png" alt="继承关系"></p><h3 id="4-6-结构和结构体"><a href="#4-6-结构和结构体" class="headerlink" title="4.6 结构和结构体"></a>4.6 结构和结构体</h3><h4 id="4-6-1-结构体"><a href="#4-6-1-结构体" class="headerlink" title="4.6.1 结构体"></a>4.6.1 结构体</h4><p>结构体是一种特殊的类。结构体和类的唯一区别在于：在类中，对于未指定任何访问控制属性的成员，其访问控制属性为私有类型；在结构体中，对于未指定任何访问控制属性的成员，其访问控制属性为公有类型；</p><p>类和结构体的并存，是由历史原因（保持和c程序的兼容性）造成的，如果完全不使用结构体，也丝毫不会影响程序的表达能力。</p><h4 id="4-6-2-联合体"><a href="#4-6-2-联合体" class="headerlink" title="4.6.2 联合体"></a>4.6.2 联合体</h4><p>联合体是一种特殊形态的类，它的默认控制属性也是公共类型的，联合体的全部数据成员共享同一组内存单元。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">union</span> Mark <span class="token punctuation">{</span>    <span class="token keyword">char</span> grade<span class="token punctuation">;</span>    <span class="token keyword">bool</span> pass<span class="token punctuation">;</span>    <span class="token keyword">int</span> percent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp/image-20210106190029141.png" alt="联合体"></p><p>正是由于联合体的成员共用同样的内存单元，联合体变量中的成员同时至多只有一个是有意义的</p><p>联合体也可以补声明名称，称为无名联合体，可以由成员项的名字直接访问。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//4_8.cpp 使用联合体保存成绩信息，并且输出</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ExamInfo</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">ExamInfo</span><span class="token punctuation">(</span>string name<span class="token punctuation">,</span> <span class="token keyword">char</span> grade<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mode</span><span class="token punctuation">(</span>GRADE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">grade</span><span class="token punctuation">(</span>grade<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">ExamInfo</span><span class="token punctuation">(</span>string name<span class="token punctuation">,</span> <span class="token keyword">bool</span> psss<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mode</span><span class="token punctuation">(</span>PASS<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pass</span><span class="token punctuation">(</span>pass<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">ExamInfo</span><span class="token punctuation">(</span>string name<span class="token punctuation">,</span> <span class="token keyword">int</span> percent<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mode</span><span class="token punctuation">(</span>PERCENTAGE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">percent</span><span class="token punctuation">(</span>percent<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>string name<span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token punctuation">{</span>GRADE<span class="token punctuation">,</span>PASS<span class="token punctuation">,</span>PERCENTAGE<span class="token punctuation">}</span>mode<span class="token punctuation">;</span><span class="token keyword">union</span> <span class="token punctuation">{</span><span class="token keyword">char</span> grade<span class="token punctuation">;</span><span class="token keyword">bool</span> pass<span class="token punctuation">;</span><span class="token keyword">int</span> percent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token class-name">ExamInfo</span><span class="token operator">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>mode<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> GRADE<span class="token operator">:</span> cout <span class="token operator">&lt;&lt;</span> grade<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> PASS<span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>pass <span class="token operator">?</span> <span class="token string">"PASS"</span> <span class="token operator">:</span> <span class="token string">"FAIL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> PERCENTAGE<span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> percent<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ExamInfo <span class="token function">course1</span><span class="token punctuation">(</span><span class="token string">"English"</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ExamInfo <span class="token function">course2</span><span class="token punctuation">(</span><span class="token string">"Calculus"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ExamInfo <span class="token function">course3</span><span class="token punctuation">(</span><span class="token string">"C++ Programming"</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">)</span><span class="token punctuation">;</span>course1<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> course2<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>course3<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp/image-20210106192518724.png" alt="运行结果"></p><h3 id="4-7-综合实例——个人银行账户管理系统"><a href="#4-7-综合实例——个人银行账户管理系统" class="headerlink" title="4.7 综合实例——个人银行账户管理系统"></a>4.7 综合实例——个人银行账户管理系统</h3><p><img src="/images/cpp/image-20210119130143620.png" alt="UML图"></p><h4 id="4-7-2-源程序及说明"><a href="#4-7-2-源程序及说明" class="headerlink" title="4.7.2 源程序及说明"></a>4.7.2 源程序及说明</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//4_9.cpp 个人银行账户管理系统</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cmath&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SavingsAccount</span> <span class="token punctuation">{</span><span class="token comment">//储蓄账户类</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token comment">//账户</span><span class="token keyword">double</span> balance<span class="token punctuation">;</span><span class="token comment">//余额</span><span class="token keyword">double</span> rate<span class="token punctuation">;</span><span class="token comment">//存款的年利率</span><span class="token keyword">int</span> lastDate<span class="token punctuation">;</span><span class="token comment">//上次变更余额的时间</span><span class="token keyword">double</span> accumulation<span class="token punctuation">;</span><span class="token comment">//余额按日累加之和</span><span class="token comment">//记录一笔账，date为日期，amount为金额，desc为说明</span><span class="token keyword">void</span> <span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获得到指定日期为止的存款金额按日累积值</span><span class="token keyword">double</span> <span class="token function">accumulate</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> accumulation <span class="token operator">+</span> balance <span class="token operator">*</span> <span class="token punctuation">(</span>date <span class="token operator">-</span> lastDate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> rate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> id<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> balance<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">getRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rate<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">deposit</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//存入现金</span><span class="token keyword">void</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//取出现金</span><span class="token comment">//结算利息，每年1月1日调用一次该函数</span><span class="token keyword">void</span> <span class="token function">settle</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示账户信息</span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> rate<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">balance</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rate</span><span class="token punctuation">(</span>rate<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lastDate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">accumulation</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> date <span class="token operator">&lt;&lt;</span> <span class="token string">"\t#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"is created"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>accumulation <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>lastDate <span class="token operator">=</span> date<span class="token punctuation">;</span>amount <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>amount <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//保留小数点后两位</span>balance <span class="token operator">+=</span> amount<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> date <span class="token operator">&lt;&lt;</span> <span class="token string">"\t#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> amount <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> balance <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">&gt;</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error:not enough money"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token operator">-</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">double</span> interest <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span> <span class="token operator">*</span> rate <span class="token operator">/</span> <span class="token number">365</span><span class="token punctuation">;</span><span class="token comment">//计算年息</span><span class="token keyword">if</span> <span class="token punctuation">(</span>interest <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> interest<span class="token punctuation">)</span><span class="token punctuation">;</span>accumulation <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"\tBalance:"</span> <span class="token operator">&lt;&lt;</span> balance<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>SavingsAccount <span class="token function">sa0</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">21325302</span><span class="token punctuation">,</span> <span class="token number">0.015</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SavingsAccount <span class="token function">sa1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">58320212</span><span class="token punctuation">,</span> <span class="token number">0.015</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa0<span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa0<span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">5500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开户后第90天到了银行的计息日，结算所有账户的年息</span>sa0<span class="token punctuation">.</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出各个账户信息</span>sa0<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp/image-20210106201828486.png" alt="输出结果"></p><center><span style="color:blue;font-size:15px">2021/1/7</span></center><h3 id="4-8-深度探索"><a href="#4-8-深度探索" class="headerlink" title="4.8 深度探索"></a>4.8 深度探索</h3><h4 id="4-8-1-位域"><a href="#4-8-1-位域" class="headerlink" title="4.8.1 位域"></a>4.8.1 位域</h4><p>位域是一种允许将类的多个数据成员打包，从而使不同的成员可以共享相同的字节的机制<br>只有bool、char、int、enum的成员才能被定义为位域<br>位域虽然节省了内存空间，但由于打包和解包的过程中需要耗费额外的操作，所以运行时间可能会增加</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Level</span><span class="token punctuation">{</span>FRTSHMEN<span class="token punctuation">,</span>SOPHOMORE<span class="token punctuation">,</span>JUNIOR<span class="token punctuation">,</span>SENIOR<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">Grade</span><span class="token punctuation">{</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>C<span class="token punctuation">,</span>D<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">unsigned</span> number <span class="token operator">:</span> <span class="token number">27</span><span class="token punctuation">;</span>Level level <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>Grade grade <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果用整型存储学号（占用4字节）用枚举型存储年级和等级（各至少占用1字节）<br>而用位域，则需要27+2+2=31个二进制位看，只需要4个字节就能放下</p><h4 id="4-8-2-用构造函数定义类型转换"><a href="#4-8-2-用构造函数定义类型转换" class="headerlink" title="4.8.2 用构造函数定义类型转换"></a>4.8.2 用构造函数定义类型转换</h4><h5 id="1-用构造函数定义的类型转换"><a href="#1-用构造函数定义的类型转换" class="headerlink" title="1.用构造函数定义的类型转换"></a>1.用构造函数定义的类型转换</h5><p>2.2.5小节已经介绍了基本数据类型的类型转换。事实上，用户也可以为类类型定义类型转换。</p><p>4.3.2小节曾经介绍，当一个函数的返回类型为类类型时，函数调用返回后，一个无名的临时对象会被创建,这种创建不是由用户显式指定的，而是隐含发生的，事实上，临时对象也可以显式创建,方法是直接使用类名调用这个类的构造函数。例如，如果希望使用例4-4中定义的Point 和Line两个类计算一个线段的长度，可以不创建有名的点对象和线段对象，而使用这种方式:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout<span class="token operator">&lt;&lt;</span><span class="token function">Line</span><span class="token punctuation">(</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>其实这正是类型转换——将整型数据类型转换为Point型对象的显式类型转换</strong><br>C++中可以通过构造函数，来自定义类型之间的转换。一个构造函数，只要可以用一个参数调用，那么它就设定了一种从参数类型到这个类类型的类型转换。由于是类型转换，所以上面一行代码，还可以写成下面两种等效形式:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout<span class="token operator">&lt;&lt;</span><span class="token function">Line</span><span class="token punctuation">(</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>Point<span class="token punctuation">)</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout<span class="token operator">&lt;&lt;</span><span class="token function">Line</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Point<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Point<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的类型转换操作符可以省去，因为默认情况下，类的构造函数所规定的类型转换，允许通过隐含类型转换进行。也就是说，可以写成这种形式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout<span class="token operator">&lt;&lt;</span><span class="token function">Line</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-只允许显式执行的类型转换"><a href="#2-只允许显式执行的类型转换" class="headerlink" title="2.只允许显式执行的类型转换"></a>2.只允许显式执行的类型转换</h5><p>只要在构造函数前加上explicit关键字，以这个构造函数定义的类型转换，只能通过显式转换的方式完成。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">explicit</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> xx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span> yy<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-8-3-对象作为函数参数和返回值的传递方法"><a href="#4-8-3-对象作为函数参数和返回值的传递方法" class="headerlink" title="4.8.3 对象作为函数参数和返回值的传递方法"></a>4.8.3 对象作为函数参数和返回值的传递方法</h4><p>函数调用时传递基本类型的数据是通过运行栈，传递对象也一样是通过运行栈。运行栈中，在主调函数和被调函数之间，有一块二者都要访问的公共区域，主调函数把实参值写入其中，函数调用发生后，被调函数通过读取这段区域就可得到形参值。需要传递的对象，只要建立在运行栈的这段区域上即可。传递基本类型数据与传递对象的不同之处在于，将实参值复制到这段区域上时，对于基本数据类型的参数，做一般的内存写操作即可，但对于对象参数，则需要调用复制构造函数。例如，例4-2之中，在main函数中调用下面这个函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">fun1</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用它时，就需要调用Point的复制构造函数，使用对象b在运行栈的传参区域上构造一个临时对象。</p><p><img src="/images/cpp/image-20210107131230507.png" alt="传递方法"></p><h2 id="第5章-数据的共享与保护"><a href="#第5章-数据的共享与保护" class="headerlink" title="第5章 数据的共享与保护"></a>第5章 数据的共享与保护</h2><h3 id="5-1-标识符的作用域与可见性"><a href="#5-1-标识符的作用域与可见性" class="headerlink" title="5.1 标识符的作用域与可见性"></a>5.1 标识符的作用域与可见性</h3><h4 id="5-1-1-作用域"><a href="#5-1-1-作用域" class="headerlink" title="5.1.1 作用域"></a>5.1.1 作用域</h4><p>作用域是一个标识符在程序正文中有效的区域</p><p><strong>1.函数原型作用域</strong><br>C++程序中最小的作用域，在函数原型声明时形式参数的作用范围就是函数原型作用域。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token keyword">double</span> radius<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>标识符radius的作用范围就这函数area形参列表的左右括号之间</p><p><strong>2.局部作用域</strong><br>具有局部作用域的变量也称为局部变量</p><p><strong>3.类作用域</strong></p><p>类可以被看成是一组有名成员的集合，类X的成员m具有类作用域，对m的访向式有如下3种。<br>（1）如果在x的成员函数中没有声明同名的局部作用域标识符,那么在该函数内可以直接访问成员m。也就是说m在这样的函数中都起作用。<br>（2）通过表达式义X.m或者X::m。这正是程序中访间对象成员的最基本方法。X::m的方式用于访问类的静态成员，相关内容将在5.3节介绍。<br>（3）通过ptr-&gt;m这样的表达式，其中ptr为指向X类的一个对象的指针。关于指针将在第6章详细介绍。</p><p><strong>4.命名空间作用域</strong><br>不同模块的类和函数之间可能发生重名，这样就会引发错误，命名空间用来消除歧义。<br>在命名空间内可以直接引用当前命名空间中声明的标识符，如果需要引用其他命名空间的标识符，需要使用下面的语法：</p><pre class="line-numbers language-none"><code class="language-none">命名空间名::标识符名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有时这样使用会过于冗长，为了解决这一问题，C++又提供了using语句：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> 命名空间名<span class="token operator">::</span>标识符名<span class="token keyword">using</span> <span class="token keyword">namespace</span> 命名空间名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>前一种形式将指定的标识符暴露在当前的作用域内；<br>后一种形式将指定命名空间内的所有标识符暴露在当前的作用域内。<br>C++标准程序库的所有标识符都被声明在std命名空间内，如果去掉了using namespace std这条语句，则引用相应的标识符需要使用std::cin、std::cout、std::endl这样的语法。<br>命名空间也允许嵌套。<br>此外，还有两类特殊的命名空间——全局命名空间和匿名命名空间。全局命名空间空间是默认的命名空间，在显式命名空间之外的标识符都在一个全局命名空间中，匿名命名空间是一个需要显式声明的没有名字的命名空间，声明方法如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span><span class="token punctuation">{</span>匿名命名空间内的各种声明（函数声明、类声明）<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在包含多个源文件的工程中，匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符，这是因为每个源文件的匿名命名空间是彼此不同的，在一个源文件中没有办法访问其他源文件的匿名命名空间。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//5_1.cpp 作用域实例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//在全局命名空间内的全局变量</span><span class="token keyword">namespace</span> Ns <span class="token punctuation">{</span><span class="token keyword">int</span> j<span class="token punctuation">;</span><span class="token comment">//在Ns命名空间中的全局变量</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>Ns<span class="token operator">::</span>j <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token punctuation">{</span><span class="token comment">//子块1</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> Ns<span class="token punctuation">;</span><span class="token comment">//使得在当然块中可以直接引用Ns命名空间的标识符</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//局部变量，局部作用域</span>i <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i="</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出7</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"j="</span> <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出6</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i="</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出5</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量j也具有命名空间作用域，他被声明在命名空间Ns中；<br><strong>具有命名空间作用域的变量也称为全局变量</strong></p><h4 id="5-1-2-可见性"><a href="#5-1-2-可见性" class="headerlink" title="5.1.2 可见性"></a>5.1.2 可见性</h4><p> 程序运行到某一点，能够引用到的标识符，就是该处可见的标识符。</p><h3 id="5-2-对象的生存期"><a href="#5-2-对象的生存期" class="headerlink" title="5.2 对象的生存期"></a>5.2 对象的生存期</h3><p>对象从诞生到结束的这段时间就是它的生存期</p><h4 id="5-2-1-静态生存期"><a href="#5-2-1-静态生存期" class="headerlink" title="5.2.1 静态生存期"></a>5.2.1 静态生存期</h4><p>如果对象的生存期与程序的运行期相同，则称它具有静态生存期。在命名空间作用域中声明的对象都是具有静态生存期的。如果在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字<strong>static</strong><br>在定义静态变量的同时也可以为它赋初值，例如</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这表示i会被赋值5初始化，而非每次执行函数时都将i赋值为5</p><h4 id="5-2-2-动态生存期"><a href="#5-2-2-动态生存期" class="headerlink" title="5.2.2 动态生存期"></a>5.2.2 动态生存期</h4><p>除了上述两种情况，其余的对象都具有动态生存期</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//5_2.cpp 变量的生存期与可见性</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//i为全局变量,具有静态生存期</span><span class="token keyword">void</span> <span class="token function">other</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//a, b为静态局部变量,具有全局寿命,局都可见,只第一次进入函数时被初始化</span><span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token comment">//c为局部变量,具有动态生存期，每次进入函数时都初始化</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>a <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>i <span class="token operator">+=</span> <span class="token number">32</span><span class="token punctuation">;</span>c <span class="token operator">+=</span> <span class="token number">5</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"--- OTHER---"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" i: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" b: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" c: "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//a为静态局都变量,具有全局寿命,局都可见</span><span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token comment">//b, c为局都变量，具有动态生存期</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"---MAIN---"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" i: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" b: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" c: "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>c <span class="token operator">+=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token function">other</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"---MAIN---"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" i: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" b: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" c: "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>i <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">other</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-类的静态成员"><a href="#5-3-类的静态成员" class="headerlink" title="5.3 类的静态成员"></a>5.3 类的静态成员</h3><h4 id="5-3-1-静态数据成员"><a href="#5-3-1-静态数据成员" class="headerlink" title="5.3.1 静态数据成员"></a>5.3.1 静态数据成员</h4><p>面向对象方法中还有“类属性”的概念。如果某个属性为整个类所共有，不属于任何个具体对象，则采用static 关键字来声明为静态成员。<br>静态数据成员具有静态生存期，由于静态数据成员不属于任何一个对象，因此可以通过类名对它进行访问，一般的用法息”类名::标识特”。在类的定义中仅仅对静态数据成员进行引用性声明，必须在命名空同作用域的某个地方使用类名限定性声明，这时也可以进行初始化。<br><strong>提示：</strong>之所以类的静态数据成员需要在类定义之外再加以定义，是因为需要以这种方式专门为它们分配空间。非静态数据成员无须以此方式定义，因为它们的空间是与它们所属对象的空间同时分配的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>count<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x，y<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Point<span class="token operator">::</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//静态数据成员定义和初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-2-静态函数成员"><a href="#5-3-2-静态函数成员" class="headerlink" title="5.3.2 静态函数成员"></a>5.3.2 静态函数成员</h4><p>所谓静态成员函数就是使用static关键字声明的函数成员。同静态数据成员一样，静态成员函数也属于整个类，由同一个类的所有对象共同拥有，为这些对象所共享。<br>静态成员函数可以通过类名或对象名调用，而非静态成员函数只能通过对象名来调用。<br>静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名。</p><h3 id="5-4-类的友元"><a href="#5-4-类的友元" class="headerlink" title="5.4 类的友元"></a>5.4 类的友元</h3><p>友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。<br>在一个类中,可以利用关键字friend 将其他函数或类声明为友元。如果友元是一般函数或类的成员函数，称为友元函数；如果友元是一个类 ，则称为友元类，友元类的所有成员函数都自动成为友元函数。</p><h4 id="5-4-1-友元函数"><a href="#5-4-1-友元函数" class="headerlink" title="5.4.1 友元函数"></a>5.4.1 友元函数</h4><p>友元函数是在类中用关键字friend修饰的非成员函数。友元函数可以是一个普通的函数，也可以是其他类的成员函数。虽然它不是本类的成员函数，但是在它的函数体中可以通过对象名访问类的私有和保护成员。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//5_6.cpp 使用友元函数计算两点间的距离</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token comment">//Point类定义</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">friend</span> <span class="token keyword">float</span> <span class="token function">dist</span><span class="token punctuation">(</span>Point<span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> Point<span class="token operator">&amp;</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//友元函数声明</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">float</span> <span class="token function">dist</span><span class="token punctuation">(</span>Point<span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> Point<span class="token operator">&amp;</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//友元函数实现</span><span class="token keyword">double</span> x <span class="token operator">=</span> p1<span class="token punctuation">.</span>x <span class="token operator">-</span> p2<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token comment">//通过对象访问私有数据成员</span><span class="token keyword">double</span> y <span class="token operator">=</span> p1<span class="token punctuation">.</span>y <span class="token operator">-</span> p2<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x <span class="token operator">+</span> y <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>Point <span class="token function">myp1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">myp2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The distance is: "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">dist</span><span class="token punctuation">(</span>myp1<span class="token punctuation">,</span> myp2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-2-友元类"><a href="#5-4-2-友元类" class="headerlink" title="5.4.2 友元类"></a>5.4.2 友元类</h4><p>同友元函数一样，一个类可以将另一个类声明为友元类。若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员。声明友元类的语法形式为:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">;</span>       <span class="token comment">//声明A为B的友元类  </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关于友元，还有几点需要往意：<br><strong>第一</strong>，友元关系是不能传递的，B类是 A类的友元，C类是B类的友元，C类和A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享。<br><strong>第二</strong>，友元关系是单向的。<br><strong>第三</strong>，友元关系是不被继承的，如果类B是类A的友元，类B的派生类并不会自动成为类A的友元。</p><h3 id="5-5-共享数据的保护"><a href="#5-5-共享数据的保护" class="headerlink" title="5.5 共享数据的保护"></a>5.5 共享数据的保护</h3><h4 id="5-5-1-常对象"><a href="#5-5-1-常对象" class="headerlink" title="5.5.1 常对象"></a>5.5.1 常对象</h4><p>常对象的数据成员值在对象的整个生存期间内不能被改变。也就是说，常对象必须进行初始化，而且不能被更新。</p><h4 id="5-5-2-用const修饰的类成员"><a href="#5-5-2-用const修饰的类成员" class="headerlink" title="5.5.2 用const修饰的类成员"></a>5.5.2 用const修饰的类成员</h4><p><strong>1.常成员函数</strong><br>使用const关键字修饰的函数为常成员函数，常成员函数声明的格式如下:<br>类型说明符 函数名(参数表) const;<br><strong>注意</strong>：<br>(1)const是函数类型的一个组成部分，因此在函数的定义部分也要带const关键字，<br>(2)如果将一个对象说明为常对象，则通过该常对象只能调用它的常成员函数，而不能调用其他成员函数(这就是C++从语法机制上对常对象的保护，也是常对象唯一的对外接口方式)。<br>(3)无论是否通过常对象调用常成员函数，在常成员函数调用期间，<span style="color:green;font-size:15px"><strong>目的对象</strong></span><strong>都被视同为常对象</strong>，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有用const 修饰的成员函数(这就保证了在常成员函数中不会更改目的对象的数据成员的值)。<br>(4)const关键字可以用于对重载函数的区分。<br><strong>提示</strong>：<br>如果仅以const关键字为区分对成员函数重载，那么通过非const 的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的重载函数——不带const关键字的函数。<br><strong>习惯</strong>：<br>在适当的地方使用const关键字，是能够提高程序质量的一个好习惯。对于无须改变对象状态的成员函数，都应当使用const。</p><p><strong>2.常数据成员</strong></p><p>就像一般数据一样，类的成员数据也可以是常量，使用const说明的数据成员为常数据成员。如果在一个类中说明了常数据成员，那么任何函数中都不能对该成员赋值。构造函数对该数据成员进行初始化，就只能通过初始化列表。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//5_8.cpp 常数据成员举例</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token comment">//静态常数据成员</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> A<span class="token operator">::</span>b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//静态常数据成员在类外说明和初始化</span><span class="token comment">//常数据成员只能通过初始化列表来获得初值</span><span class="token class-name">A</span><span class="token operator">::</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">A</span><span class="token operator">::</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>A <span class="token function">a1</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">a2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/cpp/image-20210107224500388.png" alt="运行结果"></p><h4 id="5-5-3-常引用"><a href="#5-5-3-常引用" class="headerlink" title="5.5.3 常引用"></a>5.5.3 常引用</h4><p>如果在声明中引用const修饰，被声明的引用就是常引用。常引用所引用的对象不能被更新。<br>非const的引用只能绑定到普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象。一个常引用，无论是绑定到一个普通的对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象。这意味着，对于基本数据类型的引用，则不能为数据赋值，对于类类型的引用，则不能修改它的数据成员，也不能调用它的非const的成员函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//5_9.cpp  在例5-6的基础上修改，使其中的dist函数的形参以常引用方式传递</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cmath&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">friend</span> <span class="token keyword">float</span> <span class="token function">dist</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point <span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">float</span> <span class="token function">dist</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point <span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">double</span> x <span class="token operator">=</span> p1<span class="token punctuation">.</span>x <span class="token operator">-</span> p2<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token keyword">double</span> y <span class="token operator">=</span> p1<span class="token punctuation">.</span>y <span class="token operator">-</span> p2<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x <span class="token operator">+</span> y <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> Point <span class="token function">myp1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">myp2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The distance is: "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">dist</span><span class="token punctuation">(</span>myp1<span class="token punctuation">,</span> myp2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>习惯：</strong>对于在函数中无须改变其值的参数，不宜使用普通引用方式传递，因为那会使得常对象无法被传入，因此传递常引用为宜。复制构造函数的参数一般也宜采用常引用传递。</p><h3 id="5-6-多文件结构和编译预处理指令"><a href="#5-6-多文件结构和编译预处理指令" class="headerlink" title="5.6 多文件结构和编译预处理指令"></a>5.6 多文件结构和编译预处理指令</h3><h4 id="5-6-1-C-程序的一般组织结构"><a href="#5-6-1-C-程序的一般组织结构" class="headerlink" title="5.6.1 C++程序的一般组织结构"></a>5.6.1 C++程序的一般组织结构</h4><p>到现在为止，已经学习了很多完整的C++源程序实例,分析它们的结构，基本上都是由3个部分来构成，类的定义、类的成员的实现和主函数，因为所举的例子都比较小，所有这3个部分都写在同一个文件中。在规模较大的项目中，往往需要多个源程序文件，每个源程序文件称为一个编译单元。这时C++语法要求一个类的定义必须出现在所有使用该类的编译单元中。比较好的，也是惯用的做法是将类的定义写在头文件中，使用该类的编译单元则包含这个头文件。通常一个项目至少划分为3个文件; 类定义文件(*.h文件)、类实现文件(*.cpp文件)和类的使用文件(*. cpp，主函数文件)。对于更为复杂的程序，每一个类都有单独的定义和实现文件。采用这样的组织结构，可以对不同的文件进行单独编写、编译，最后再连接，同时可以充分利用类的封装特性，在程序的调试、修改时只对其中某一个类的定义和实现进行修改，而其余部分不用改动。</p><p>分析整个源程序的结构，由3个单独的源文件构成，它们的相互关系和编译、连接过程可以用图5-8表示(这里是Windows操作系统的情形，UNIX操作系统中生成文件的后缀会有所不同)。</p><p><img src="/images/cpp/image-20210107234218610.png" alt="多文件组织结构图"></p><p>从图5-8可以看到，两个. cpp的文件被分别编译生成各自的目标文件. obj，然后再与系统的运行库共同连接生成可执行文件. exe。如果只修改了类的成员函数的实现部分，则只重新编译point. cpp并连接即可，其余的文件几乎可以连看都不用看。 如果是一个语句很多、规模特大的程序，效率就会得到显著的提高。</p><p>决定一个声明放在源文件中还是头文件中的一般原则是 ，将需要分配空间的定义放在源文件中，例如函数的定义(需要为函数代码分配空间)、命名空间作用域中变量的定义(需要为变量分配空间)等；而将不需要分配空间的声明放在头文件中，例如类声明、外部函数的原型声明、外都变量的声明(外部函数和外部变量将在5.6.2节中详细讨论、基本数据类型常量的声明等。内联函数比较特殊，由于它的内容需要嵌入到每个调用它的函数之中，所以对于那些需要被多个编译单元调用的内联函数，它们的代码应该被各个编译单元可见，这些内联函数的定义应当出现在头文件中。</p><h4 id="5-6-2-外部变量与外部函数"><a href="#5-6-2-外部变量与外部函数" class="headerlink" title="5.6.2 外部变量与外部函数"></a>5.6.2 外部变量与外部函数</h4><p><strong>1.外部变量</strong><br>如果一个变量除了在定义它的源文件中可以使用外。还能被其他文件使用，那么就称这个变成是外部变量。命名空间作用域中定义的变量，默认情况下都是外部变量，但在其他文件中如果需要使用这一变量，需要用extern关键字加以声明。</p><p>在命名空间作用域中，不用extern关键字声明的变量，都是定义性声明；用extern关键字声明的变量，如果同时指定了初值，则是定义性声明，否则是引用性声明。外部变量可以有多处声明，但是定义性声明只能是唯一的。</p><p><strong>2.外部函数</strong><br>在所有类之外声明的函数(也就是非成员函数)，都是具有命名空间作用域的，如果没有特殊说明，这样的函数都可以在不同的编译单元中被调用，只要在调用之前进行引用性声明(即声明函数原型)即可。当然，也可以在声明函数原型或定义函数时用extern修饰，其效果与不加修饰的默认状态是一样的。</p><p><strong>习惯：</strong>通常情况下 ,变量和函数的定义都放在源文件中，而对外部变量和外部函数的引用性声明则放在头文件中。</p><p><strong>3.将变量和函数限制在编译单元内</strong><br>命名空间作用域中声明的变量和函数，在默认情况下都可以被其他编译单元访问,但有时不希望一个源文件中定义的命名空间作用域的变量和函数被其他源文件引用。这种需求主要是出于两个原因，一是出于安全性考虑，不希望将—个只会在文件内使用的内部变量或函数暴露给其他编译单元，就像不希望暴露一个类的私有成员一样；二是,对于大工程来说，不同文件之中的、只在文件内使用的变量名很容易重名，如果将它们都暴露出来，在连接时很容易发生名字冲突。<br>对这问题，曾经的解决办法是，在定义这些变量和函数时使用static关键字。static关键字用来修饰命名空间作用域的变量或函数时， 和extern关键字起相反的作用，它会使得被static修饰的变此和函数无法被其他编译单元引用。</p><p><strong>提示：</strong>目前已经介绍了static 关键字的3种用法，当它用在局部作用域、类作用域和命名空间作用域时，具有不尽相同的作用。一个共同点是，凡是被static修饰的变量，都具有静态生存期(不管未使用static关键字时它们的生存期如何)。</p><p>现在取而代之的方式是使用匿名的命名空间。在匿名命名空间中定义的变量和函数都不会暴露给其他编译单元。</p><p><strong>习惯：</strong>应当将不希望被其他编译单元引用的函数和变量放在匿名的命名空间中。</p><center><span style="color:blue;font-size:15px">2021/1/8</span></center><h4 id="5-6-3-标准C-库"><a href="#5-6-3-标准C-库" class="headerlink" title="5.6.3 标准C++库"></a>5.6.3 标准C++库</h4><p>在C语言中，系统函数、系统的外部变量和一些宏定义都放置在运行库(run-timelibrary)中。C++的库中除继续保留了大部分c语言系统函数外，还加入了预定义的模板和类。标准C++ 类库是一个极为灵活并可扩展的可亚用软件模块的集合。标准C++类与组件在逻辑上分为如下6种类型。<br>。输入输出类;<br>。容器类与ADT(抽象数据类型);<br>。存储管理类;<br>。算法;<br>。错误处理;<br>。运行环境支持。</p><p>使用标准C++库时，还需要加入下面这一条语句来将指定命名空间中的名称引入到当前作用域中:<br>using namespace std;<br>如果不使用上述方法.就需要在使用srd命名空间中的标识符时冠以命名空间名’std::”。</p><p><strong>习惯：</strong>通常情况下，using namespace 语句不宜放在头文件中，因为这会使一个命名空间不被察觉地对一个源文件开放。</p><h4 id="5-6-4-编译预处理"><a href="#5-6-4-编译预处理" class="headerlink" title="5.6.4 编译预处理"></a>5.6.4 编译预处理</h4><p>在编译器对源程序进行编译之前。首先要由预处理器对程序文本进行预处理。所有的预处理指令在程序中都是以“#”来引导，每一条预处理指令单独占用一行，不要用分号结束。预处理指令可以根据需要出现在程序中的任何位置。</p><p><strong>1.#include 指令</strong></p><p><strong>2.#define 和 #undef指令</strong><br>在C++中虽然仍可以用#define定义符号常量，但是更好的方法是在类型说明语句中用const进行修饰。<br>在C语言中，还可以用#define来定义带参数宏，以实现简单的函数计算，但是在C++中这一功能已被内联函数取代。<br>用#define还可以定义空符号，目的是配合条件编译指令一起使用。<br>#undef的作用是删除由#undef定义的宏，使之不再起作用。</p><p><strong>3.条件编译指令</strong><br>使用条件编译指令，可以限定程序中的某些内容要在满足一定条件的情况下才参与编译。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression"><span class="token operator">/</span> #ifndef</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>4.defined操作符</strong><br>defined是一个预处理操作符，而不是指令，因此不要以#开头。<br>#ifndef MYHEAD_H 与 #if!defined(MYHEAD_H) 完全等价</p><p>由于文件包含指令可以嵌套使用，在设计程序时要避免多次重复包含同一个文件，否则会引起变量及类的重复定义。可以在可能被重复包含的头文件中使用条件编译指令。用一个唯一的标识符来标记文件是否已参加过编译。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//head.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HEAD_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">HEAD_H</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><span style="color:blue;font-size:15px">2021/1/9</span></center><h3 id="5-7-综合实例——个人银行账户管理系统"><a href="#5-7-综合实例——个人银行账户管理系统" class="headerlink" title="5.7 综合实例——个人银行账户管理系统"></a>5.7 综合实例——个人银行账户管理系统</h3><p>对第四章的改进：<br>（1）在SavingsAccount类中增加了一个静态数据成员total，用来记录各个账户的总金额，并为其增加相应的静态成员函数getTotal用来对其进行访问。<br>（2）诸如getBalance，accumulate这些不需要改变对象状态的成员函数声明为常成员函数。<br>（3）将SavingAccount类从主函数所在的源文件中分开，建立两个新的文件account.h和account.cpp分别存放SavingAccount类的定义和实现。</p><p><img src="/images/cpp/image-20210119130237279.png" alt="UML图"></p><p>例5-11 个人银行账户管理。<br>整个程序分为3个文件：account.h是类定义头文件，account.cpp是类实现文件，5_11.cpp是主函数文件</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//account.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__ACCOUNT_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__ACCOUNT_H__</span></span><span class="token keyword">class</span> <span class="token class-name">SavingsAccount</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token keyword">double</span> balance<span class="token punctuation">;</span><span class="token keyword">double</span> rate<span class="token punctuation">;</span><span class="token keyword">int</span> lastDate<span class="token punctuation">;</span><span class="token keyword">double</span> accumulation<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">double</span> total<span class="token punctuation">;</span><span class="token comment">//static所有账户的总金额</span><span class="token keyword">void</span> <span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token function">accumulate</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token comment">//const</span><span class="token keyword">return</span> accumulation <span class="token operator">+</span> balance <span class="token operator">*</span> <span class="token punctuation">(</span>date <span class="token operator">-</span> lastDate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> rate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> id<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//const</span><span class="token keyword">double</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> total<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//const</span><span class="token keyword">double</span> <span class="token function">getRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rate<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//const</span><span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> total<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//静态函数</span><span class="token keyword">void</span> <span class="token function">deposit</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">settle</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//const</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">//__ACCOUNT_H__</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//account.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"account.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">double</span> SavingsAccount<span class="token operator">::</span>total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//给total赋初值</span><span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">SavingsAccount</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> rate<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">balance</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rate</span><span class="token punctuation">(</span>rate<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lastDate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">accumulation</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> date <span class="token operator">&lt;&lt;</span> <span class="token string">"\t#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"is created"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>accumulation <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>lastDate <span class="token operator">=</span> date<span class="token punctuation">;</span>amount <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>amount <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//保留小数点后两位</span>balance <span class="token operator">+=</span> amount<span class="token punctuation">;</span>total <span class="token operator">+=</span> amount<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> date <span class="token operator">&lt;&lt;</span> <span class="token string">"\t#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> amount <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> balance <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">&gt;</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error:not enough money"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token operator">-</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">double</span> interest <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span> <span class="token operator">*</span> rate <span class="token operator">/</span> <span class="token number">365</span><span class="token punctuation">;</span><span class="token comment">//计算年息</span><span class="token keyword">if</span> <span class="token punctuation">(</span>interest <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">record</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> interest<span class="token punctuation">)</span><span class="token punctuation">;</span>accumulation <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"#"</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">"\tBalance:"</span> <span class="token operator">&lt;&lt;</span> balance<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"account.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>SavingsAccount <span class="token function">sa0</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">21325302</span><span class="token punctuation">,</span> <span class="token number">0.015</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SavingsAccount <span class="token function">sa1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">58320212</span><span class="token punctuation">,</span> <span class="token number">0.015</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa0<span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa0<span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">5500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开户后第90天到了银行的计息日，结算所有账户的年息</span>sa0<span class="token punctuation">.</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">settle</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出各个账户信息</span>sa0<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>sa1<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Total: "</span> <span class="token operator">&lt;&lt;</span> <span class="token class-name">SavingsAccount</span><span class="token operator">::</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-8-深度探索"><a href="#5-8-深度探索" class="headerlink" title="5.8 深度探索"></a>5.8 深度探索</h3><h4 id="5-8-1-常成员函数的声明原则"><a href="#5-8-1-常成员函数的声明原则" class="headerlink" title="5.8.1 常成员函数的声明原则"></a>5.8.1 常成员函数的声明原则</h4><p>“对于那些不会改变<strong>对象状态</strong>的函数，都应定义为常函数”<br>这并不意味着不会改变非静态成员对象的成员函数，都不会改变对象状态。<br>如果有一个函数会改变某个成员的值，但它也未必会改变对象状态。<br>详情见课本p181<br>被mutable修饰的成员对象在任何时候都不会被视为常对象</p><h4 id="5-8-2-代码的编译连接与执行过程"><a href="#5-8-2-代码的编译连接与执行过程" class="headerlink" title="5.8.2 代码的编译连接与执行过程"></a>5.8.2 代码的编译连接与执行过程</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//a.cpp</span><span class="token keyword">extern</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> z<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    y<span class="token operator">=</span><span class="token function">func</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//b.cpp</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> v<span class="token operator">+</span>x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.编译</strong><br>编译是对一个个源文件分别处理的，每个源文件构成了独立的编译单元，编译过程中不同的编译单元互不影响。目标文件主要描述程序在运行过程中需要放在内存中的内容，包括两大类——代码和数据。</p><p>代码段（.text）a.o中应当包含main函数的目标代码；b.o中应当包含func函数的代码；<br>数据段中包含对源文件中定义的各个<strong>静态生存期</strong>对象的描述，数据段又分为初始化的数据段（.data）和未初始化的数据段（.bss）</p><p>几个段的内容，都是该源文件中有定义的内容，那些只声明而未经定义的全局变量或函数并不在这几个段中。例如a.cpp中的y没有出现在a.o的数据段中，而func也没有出现在a.o的代码段中。<br>a.cpp的main函数改写了变量y的值，但y是在b.cpp中定义的，这种联系要通过变量或函数的名字来建立，他们存放在目标代码的符号表中。</p><p><img src="/images/cpp/image-20210109233258524.png" alt=""></p><p><strong>2.连接</strong></p><p>在连接期间，需要将各个编译单元的目标文件和运行库当中被调用的单元加以合并。结果合并后，不同编译单元的代码段和数据段就分别合并到一起了，程序在运行时代码和静态数据需要占据的内存空间就全部已知了，因此所有代码和数据都可以背分配确定的地址了。</p><p><strong>3.执行</strong></p><p>程序的执行，是以进程为单位的。程序只有在执行时才会生成进程，执行结束后进程会消失。<br>程序是存储在磁盘上的，在执行前，操作系统需要首先将它载入到内存中，并为它分配足够大的内存空间来容纳代码段和数据段，然后把文件中存放的代码段和初始化的数据段的内容载入其中。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> C++语言设计指南（第4版） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好2021</title>
      <link href="2021/01/01/hi2021/"/>
      <url>2021/01/01/hi2021/</url>
      
        <content type="html"><![CDATA[<h3 id="triangular-flag-on-post-2021到了，去年留下了诸多遗憾，今年有更多的任务在等待，希望在新的一年可以得到提升，祝所有人新年快乐！！！"><a href="#triangular-flag-on-post-2021到了，去年留下了诸多遗憾，今年有更多的任务在等待，希望在新的一年可以得到提升，祝所有人新年快乐！！！" class="headerlink" title=":triangular_flag_on_post: 2021到了，去年留下了诸多遗憾，今年有更多的任务在等待，希望在新的一年可以得到提升，祝所有人新年快乐！！！"></a><span class="github-emoji"><span>🚩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f6a9.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 2021到了，去年留下了诸多遗憾，今年有更多的任务在等待，希望在新的一年可以得到提升，祝所有人新年快乐！！！</h3>]]></content>
      
      
      <categories>
          
          <category> 随心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora &amp; Mathjax使用文档</title>
      <link href="2020/12/31/typora-mathjax/"/>
      <url>2020/12/31/typora-mathjax/</url>
      
        <content type="html"><![CDATA[<p>Typora里面直接编写html代码，对hexo生效，但是如果直接改动Typora本身的css和html，则对hexo不生效</p><p>Mathjax语法总结 <a href="https://blog.csdn.net/ajacker/article/details/80301378">https://blog.csdn.net/ajacker/article/details/80301378</a></p><h2 id="1-字体编辑"><a href="#1-字体编辑" class="headerlink" title="1. 字体编辑"></a>1. 字体编辑</h2><h3 id="1-1-标题"><a href="#1-1-标题" class="headerlink" title="1.1 标题"></a>1.1 标题</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 一级标题        快捷键Ctrl+1</span><span class="token comment">## 二级标题       快捷键Ctrl+2</span><span class="token comment">### 三级标题      快捷键Ctrl+3</span><span class="token comment">#### 四级标题     快捷键Ctrl+4</span><span class="token comment">##### 五级标题    快捷键Ctrl+5</span><span class="token comment">###### 六级标题   快捷键Ctrl+6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-字体大小"><a href="#1-2-字体大小" class="headerlink" title="1.2 字体大小"></a>1.2 字体大小</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：Ctrl+数字  或 Ctrl+加减号  或  ### （几个#表示几级标题，同上）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-字体加粗"><a href="#1-3-字体加粗" class="headerlink" title="1.3 字体加粗"></a>1.3 字体加粗</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：Ctrl+b示 例：**加粗内容**<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>加粗内容</strong></p><h3 id="1-4-斜体"><a href="#1-4-斜体" class="headerlink" title="1.4 斜体"></a>1.4 斜体</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：ctrl+i示 例：*斜体*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示 例：<em>斜体</em></p><h3 id="1-5-删除线"><a href="#1-5-删除线" class="headerlink" title="1.5 删除线"></a>1.5 删除线</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：alt+shift+5示 例：~~删除的内容~~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示 例：<del>删除的内容</del></p><h3 id="1-6-下划线"><a href="#1-6-下划线" class="headerlink" title="1.6 下划线"></a>1.6 下划线</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：Ctrl+u示 例：&lt;u&gt;下划线内容&lt;/u&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示 例：<u>下划线内容</u></p><h3 id="1-7-文本居中"><a href="#1-7-文本居中" class="headerlink" title="1.7 文本居中"></a>1.7 文本居中</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：&lt;center&gt;居中内容&lt;/center&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>操作：</p><center>居中内容</center><p></p><h3 id="1-8-脚注"><a href="#1-8-脚注" class="headerlink" title="1.8 脚注"></a>1.8 脚注</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：这块有个脚注[^脚注]     [^脚注]:填写脚注的内容示例：有一个github网址[^1]     [^1]:https://github.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例：有一个github网址<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h2><h3 id="2-1-有序列表"><a href="#2-1-有序列表" class="headerlink" title="2.1 有序列表"></a>2.1 有序列表</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：数字+英文小数点(.)+空格示例：1. list1     2. list2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>list1<ol><li>list2</li></ol></li></ol><h3 id="2-2-无序列表"><a href="#2-2-无序列表" class="headerlink" title="2.2 无序列表"></a>2.2 无序列表</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：- +空格 或 * + 空格示例： - list1      - list2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>list1<pre><code>- list2</code></pre></li></ul><h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h2><h3 id="3-1-插入代码块"><a href="#3-1-插入代码块" class="headerlink" title="3.1 插入代码块"></a>3.1 插入代码块</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：shift+~~~（或直接```)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">,</span>num<span class="token punctuation">;</span>  <span class="token keyword">int</span> loopcnts <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"input:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>begin <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loopcnts<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>res <span class="token operator">=</span> <span class="token function">SqrtByBisection</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  end <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"mySqrt_binarysearch(%d) = %f, spent time is %f\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>end<span class="token operator">-</span>begin<span class="token punctuation">)</span><span class="token operator">/</span>CLOCKS_PER_SEC<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-插入数学公式"><a href="#3-2-插入数学公式" class="headerlink" title="3.2 插入数学公式"></a>3.2 插入数学公式</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：$$ + enter示例：$$ + enter后输入11+12，结果如下所示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><script type="math/tex; mode=display">11+12</script><h3 id="3-3-插入引用"><a href="#3-3-插入引用" class="headerlink" title="3.3 插入引用"></a>3.3 插入引用</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：&gt; + 空格示例：&gt; + 空格后，输入 引用的内容，结果如下所示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>引用的内容</p></blockquote><h3 id="3-4-插入链接"><a href="#3-4-插入链接" class="headerlink" title="3.4 插入链接"></a>3.4 插入链接</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操 作:Ctrl+k弹出后，输入 [输入标题名](输入链接地址) 即可示 例1：[百度一下，你就知道](https://www.baidu.com/)示 例2：这是 [百度一下，你就知道](https://www.baidu.com/ "百度") 的链接.  示 例3：这是 [github][1] 的链接.         [1]: https://github.com/ "github"ps：按住ctrl点击链接可直接打开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.zhihu.com/?target=https%3A//www.baidu.com/">百度一下，你就知道</a></p><p>这是 <a href="https://link.zhihu.com/?target=https%3A//www.baidu.com/">百度一下，你就知道</a> 的链接.</p><p>这是 <a href="https://link.zhihu.com/?target=https%3A//github.com/">github</a> 的链接.</p><h3 id="3-5-插入注释"><a href="#3-5-插入注释" class="headerlink" title="3.5 插入注释"></a>3.5 插入注释</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：[^文字]：文字示例：[^1]：文献1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>：文献1</p><h3 id="3-6-插入表格"><a href="#3-6-插入表格" class="headerlink" title="3.6 插入表格"></a>3.6 插入表格</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">快捷键：ctrl+t示 例：按完快捷键后，弹出下图，选择对应的行和列，点击确定即可。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>2</td><td></td><td></td></tr><tr><td>3</td><td></td><td></td></tr><tr><td>4</td><td></td></tr></tbody></table></div><h3 id="3-7-插入图片"><a href="#3-7-插入图片" class="headerlink" title="3.7 插入图片"></a>3.7 插入图片</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：直接拖动  或 ctrl+shift+i(相对路径地址)示例：![](C:\1.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Typora &amp; Mathjax/v2-96d8a3b13676b08768ef4003478c0ade_720w.jpg" alt="img"></p><h3 id="3-8-插入分隔符"><a href="#3-8-插入分隔符" class="headerlink" title="3.8 插入分隔符"></a>3.8 插入分隔符</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作：--- + enter  或者 *** + enter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="3-9-插入表情"><a href="#3-9-插入表情" class="headerlink" title="3.9 插入表情"></a>3.9 插入表情</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">操作： ：+ 单词 +:示例： :smile:      :cry:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="3-10-插入目录"><a href="#3-10-插入目录" class="headerlink" title="3.10 插入目录"></a>3.10 插入目录</h3><pre class="line-numbers language-none"><code class="language-none">操作：[toc]+enter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>[toc]</p><h3 id="3-11-公式内换行"><a href="#3-11-公式内换行" class="headerlink" title="3.11 公式内换行"></a>3.11 公式内换行</h3><pre class="line-numbers language-none"><code class="language-none">操作：\\<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-12-公式内左对齐"><a href="#3-12-公式内左对齐" class="headerlink" title="3.12 公式内左对齐"></a>3.12 公式内左对齐</h3><pre class="line-numbers language-none"><code class="language-none">操作：在公式最开始加\begin{aligned}，然后每个等号前加&amp;，即&amp;=，每一行用\\换行，然后最后一句输完后\end{aligned}实例：$\begin{aligned}d(x,y)&amp;=\sqrt{(x_1-y_1)^2+(x_2-y_2)^2+\dots+(x_n-y_n)^2}\\&amp;=\sqrt{\sum_{i=1}^{n}{(x_i-y_i)^2}} \end{aligned}$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><script type="math/tex; mode=display">\begin{aligned}d(x,y)&=\sqrt{(x_1-y_1)^2+(x_2-y_2)^2+\dots+(x_n-y_n)^2}\\&=\sqrt{\sum_{i=1}^{n}{(x_i-y_i)^2}} \end{aligned}</script><h3 id="3-13-矩阵表示"><a href="#3-13-矩阵表示" class="headerlink" title="3.13 矩阵表示"></a>3.13 矩阵表示</h3><pre class="line-numbers language-none"><code class="language-none">操作：`\begin{matrix}`和`\end{matrix}`说明在它们之间的是矩阵`1 &amp; 2 &amp; 3\\`表示第一行的元素，其中用`&amp;`来分割每一个元素，用`\\`来换行实例: \left[\begin{matrix} 1 &amp; 2 &amp; 3\\ 4 &amp; 5 &amp; 6 \end{matrix}\right]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>$\left[\begin{matrix} 1 &amp; 2 &amp; 3\\ 4 &amp; 5 &amp; 6 \end{matrix}\right]$</p><h3 id="3-14-希腊字母表示"><a href="#3-14-希腊字母表示" class="headerlink" title="3.14 希腊字母表示"></a>3.14 希腊字母表示</h3><p>$\partial$ \partial</p><p>$\infty$ \infty</p><p>$\forall$ \forall</p><p>$\exists$ \exists</p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Typora &amp; Mathjax/v2-68922903c83e504e3e3e4efd5b7327fa_720w.jpg" alt=""></p><h3 id="3-15-箭头表示"><a href="#3-15-箭头表示" class="headerlink" title="3.15 箭头表示"></a>3.15 箭头表示</h3><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Typora &amp; Mathjax/v2-42ff8eb3a827056b16b2133f58009abe_720w.jpg" alt="img"></p><h3 id="3-16-公式大全"><a href="#3-16-公式大全" class="headerlink" title="3.16 公式大全"></a>3.16 公式大全</h3><p><a href="https://blog.csdn.net/fly0202/article/details/82534854">Mathjax 常用语法</a></p><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Typora &amp; Mathjax/v2-2f57dd9499cba748a39be06d2104fe21_720w.jpg" alt="img"></p><h3 id="3-17-二进制运算-相关符号"><a href="#3-17-二进制运算-相关符号" class="headerlink" title="3.17 二进制运算/相关符号"></a>3.17 二进制运算/相关符号</h3><p><img src="https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/Typora &amp; Mathjax/v2-fd7827f7c554e1f2c6d9a356f868a0fe_720w.jpg" alt="img"></p><h3 id="3-18-空格表示"><a href="#3-18-空格表示" class="headerlink" title="3.18 空格表示"></a>3.18 空格表示</h3><p>在公式中如果需要有空格，可以用+空格的方式来实现</p><pre class="line-numbers language-none"><code class="language-none">实例：max \ a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>$max \ a$</p><hr><h2 id="4-杂项"><a href="#4-杂项" class="headerlink" title="4. 杂项"></a>4. 杂项</h2><h3 id="4-1-设置字体颜色大小等"><a href="#4-1-设置字体颜色大小等" class="headerlink" title="4.1 设置字体颜色大小等"></a>4.1 设置字体颜色大小等</h3><pre class="line-numbers language-none"><code class="language-none">由于Typora或者说markdown中没有直接的语法支持文字的颜色，大小，字体等属性的设置，就需要“曲线救国”，因为Typora支持内嵌html的语法，那么只要插入一条html代码即可:&lt;span style='color:文字颜色;background:背景颜色;font-size:文字大小;font-family:字体;'&gt;文字&lt;/span&gt;实例：&lt;span style='color:red;background:blue;font-size:30px;font-family:微软雅黑;'&gt;文字&lt;/span&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span style="color:red;background:blue;font-size:30px;font-family:微软雅黑;">文字</span></p><h3 id="4-2-某些数学图的插入"><a href="#4-2-某些数学图的插入" class="headerlink" title="4.2 某些数学图的插入"></a>4.2 某些数学图的插入</h3><p><a href="https://www.intmath.com/cg3/embed-desmos.php">https://www.intmath.com/cg3/embed-desmos.php</a></p><p>desmos：</p><iframe src="https://www.desmos.com/calculator/yx1lco5nog" width="100%" height="600"></iframe><p>ggb：</p><iframe src="https://ggb123.cn/classic/nfvqbwqt?embed" width="100%" height="600" allowfullscreen="" style="border: 1px solid #e4e4e4;border-radius: 4px;" frameborder="0"></iframe><iframe src="https://ggb123.cn/classic/n4aa6vgh?embed" width="100%" height="600" allowfullscreen="" style="border: 1px solid #e4e4e4;border-radius: 4px;" frameborder="0"></iframe>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathjax </tag>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/12/29/hello-world/"/>
      <url>2020/12/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
