---
title: 汇编
date: 2021-01-20 22:26:10
img: https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/assembly.jpg
mathjax: true
summary: 持续更新中
categories: 学习笔记
tags:
  - assembly
typora-root-url: ..
---

<span style="color: #c31887;">把基本的都忘了，重新简单学一下，不深入，以后有时间再说</span>

使用的教材：汇编语言（第3版）王爽

<center><span style='color:blue;font-size:15px'>2021/1/20</span></center>

## 第1章 基础知识

汇编语言是直接在硬件之上工作的编程语言，需要有一定知识，但是在汇编课程中我们部队硬件系统进行全面和深入的研究，汇编课程的研究重点放在如何利用硬件系统的编程结构和指令集有效灵活地控制系统进行工作。

### 1.1 机器语言

机器语言是机器指令的集合，电子计算机的机器指令是一列二进制数字，每一种微处理器都有自己的机器指令集，也就是机器语言。

### 1.2 汇编语言的产生

汇编语言的主体是汇编指令，汇编指令是机器指令便于记忆的书写格式。

### 1.3 汇编语言的组成

（1）汇编指令：机器码的助记符，有相应的机器码。

（2）伪指令：没有对应的机器码，由编译器执行，计算机并不执行。

（3）其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。

汇编语言的核心是汇编指令，它决定了汇编语言的特性。

### 1.4 存储器

指令和数据在存储器中存放，也就是我们平时所说的内存。

### 1.5 指令和数据

指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二讲制信息。CPU在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。

### 1.6 存储单元

微型机存储器的存储单元可以存储一个Byte，即8个二进制位。

### 1.7 CPU对存储器的读写

CPU要想进行数据的读写，必须和外部器件(标准的说法是芯片)进行下面3类信息的交互。

- 存储单元的地址(地址信息)；
- 器件的选择，读或写的命令(控制信息)；
- 读或写的数据(数据信息)。

在计算机中专门有连接CPU和其他芯片的导线，通常称为总线。总线从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为3类，**地址总线**、**控制总线**和**数据总线**。

CPU从3号单元中读取数据的过程如下：

![](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210120230352328.png)

（1）CPU 通过地址线将地址信息3发出。
（2）CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。
（3）存储器将3号单元中的数据8通过数据线送入CPU。

### 1.8 地址总线

一个CPU有N跟地址总线，则可以说这个CPU的地址总线的宽度为N。这样的CPU最多可以寻找2的N次方个内存单元。

### 1.9 数据总线

数据总线的宽度决定了CPU和外界的数据传送速度。8 根数据总线一次可传送一个8位二进制数据(即一个字节)。16 根数据总线一次可传送两个字节。

### 1.10 控制总线

CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。
前面所讲的内存读或写命令是由几根控制线综合发出的，其中有一根称为 “读信号输出”的控制线负贵由CPU向外传送读信号，CPU向该控制线上输出低电平表示将要读取数据；有一根称为“写信号输出”的控制线则负责传送写信号。

### 1.11 内存地址空间（概述）

举例来讲，一个CPU的地址总线宽度为10，那么可以寻址1024个内存单元，这1024 个可寻到的内存单元就构成这个CPU的内存地址空间。下面进行深入讨论。首先需要介绍两部分基本知识，主板和接口卡。

### 1.12 主板

在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件，这些器件通过总线(地址总线、数据总线、控制总线)相连。这些器件有**CPU**、**存储器**、**外围芯片组**（北桥负责高速信号，比如CPU与内存、显卡等设备的通信。南桥负责低速信号，比如PCI/PCIe、SATA、USB等外围设备通信。再后来北桥芯片逐渐被集成到了CPU里面。**芯片组的主要差别就是CPU对外围设备和拓展支持情况的差别**）、扩展插槽等。扩展插槽上一般插有RAM内存条和各类接口卡。

### 1.13 接口卡

CPU对外部设备都不能直接控制，直接控制这些设备进行工作的是插在扩展插槽上的接口卡。
简单地讲，就是CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作。

### 1.14 各类存储器芯片

一台PC机中，装有多个存储器芯片，这些存储器芯片从物理连接上看是独立的、不同的器件。从读写属性上看分为两类：**随机存储器**(RAM)和**只读存储器**(ROM)。 随机存储器可读可写，但必须带电存储，关机后存储的内容丢失；只读存储器只能读取不能写入，关机后其中的内容不丢失。这些存储器从功能和连接上又可分为以下几类。

- 随机存储器
  用于存放供CPU使用的绝大部分程序和数据。

- 装有BIOS(Basic Input/Output System,基本输入/输出系统)的ROM
  BIOS是由主板和各类接口卡(如显卡、网卡等)厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM。例如，主板上的ROM中存储着主板的BIOS(通常称为系统BIOS)；显卡上的ROM中存储着显卡的BIOS；如果网卡上装有ROM，那其中就可以存储网卡的BIOS。
- 接口卡上的RAM
  某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有RAM。最典型的是显示卡上的RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。

![](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210120235427070.png)

### 1.15 内存地址空间

上述的那些存储器，在物理上是独立的器件，但是在以下两点上相同。

- 都和CPU的总线相连。
- CPU对它们进行读或写的时候都通过控制线发出内存读写命令。

这也就是说，CPU 在操控它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。在汇编这门课中，我们所面对的是内存地址空间。

![](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210120235904993.png)

在图1.8中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。

假设，图1.8中的内存地址空间的地址段分配如下。
地址0~7FFFH的32KB空间为主随机存储器的地址空间:
地址8000H~9FFFH的8KB空间为显存地址空间:
地址A000H~FFFFH的24KB空间为各个ROM的地址空间。

这样，CPU向内存地址为1000H的内存单元中写入数据，这个数据就被写入主随机存储器中；CPU向内存地址为8000H的内存单元中写入数据，这个数据就被写入显存中，然后会被显卡输出到显示器上；CPU向内存地址为C000H的内存单元中写入数据的操作是没有结果的，C000H 单元中的内容不会被改变，C000H 单元实际上就是ROM存储器中的一个单元。

内存地址空间的大小受CPU地址总线宽度的限制。80386CPU 的地址总线宽度为32，其内存地址空间最大为4GB。

我们在基于一个计算机硬件系统编程的时候，必须知道这个系统中的内存地址空间分配情况。不同的计算机系统的内存地址的分配情况是不同的。

![8086PC机内存地址空间](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/20200430191506580.png)

<center><span style='color:blue;font-size:15px'>2021/1/23</span></center>

## 第2章 寄存器

一个典型的CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。
对一个汇编程序员来说，CPU中的主要部件是寄存器。

### 2.1 通用寄存器

8086CPU的所以寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为**通用寄存器**。
为了向上一代的8位CPU寄存器兼容，这4个通用寄存器都可分为两个独立使用的8位寄存器来用。
例如：AX可分为AH（高8位）和AL（低8位）

### 2.2 字在寄存器中的存储

出于对兼容性的考虑，8086CPU可以一次性处理以下两种尺寸的数据

- 字节：记为byte，由8个bit组成
- 字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节

出于对数据直观分析的需要，我们多用十六进制来表示一个数据

### 2.3 几条汇编指令

| 程序段中的指令 | 指令执行后AX中的数据 | 指令执行后BX中的数据 |
| :------------: | :------------------: | :------------------: |
|  mov ax,4E20H  |        4E20H         |        0000H         |
|  add ax,106H   |        6226H         |        0000H         |
|  mov bx,2000H  |        6226H         |        2000H         |
|   add ax,bx    |        8226H         |        2000H         |
|   mov bx,ax    |        8226H         |        8226H         |
|   add ax,bx    |      **044CH**       |        8226H         |

最后一条指令所得的值应该为1044CH，但是ax寄存器放不下，最高位的1不能保存

| 程序段中的指令 | 指令执行后AX中的数据 | 指令执行后BX中的数据 |
| :------------: | :------------------: | :------------------: |
|  mov ax,001AH  |        001AH         |        0000H         |
|  mov bx,0026H  |        001AH         |        0026H         |
|   add al,bl    |        0040H         |        0026H         |
|   add ah,bl    |        2640H         |        0026H         |
|   add bh,al    |        2640H         |        4026H         |
|    mov ah,0    |        0040H         |        4026H         |
|   add al,85H   |        00C5H         |        4026H         |
|   add al,93H   |      **0058H**       |        4026H         |


最后的ax应该为158H，但此时的al是作为一个独立的8位寄存器来使用的，和ah没有关系，所以最高位丢失

在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。

### 2.4 物理地址

每个内存单元在存储空间内都有唯一的地址，称为物理地址。
在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU可以有不同的形成物理地址的方式。

### 2.5 16位结构的CPU

什么是16位结构的CPU呢？

- 运算器一次最多可以处理16位的数据
- 寄存器的最大宽度为16位
- 寄存器和运算器之间的通路为16位

内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，对于16位CPU，能一次性处理，传输、暂时存储16位的地址。

<center><span style='color:blue;font-size:15px'>2021/2/23</span></center>

### 2.6 8086CPU给出物理地址的方法

**8086CPU有20位地址总线，可以传送20位地址**，达到IMB寻址能力。**8086CPU是16位结构**，在内部一次性处理、 传输、暂时存储的地址为16 位。从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，**表现出的寻址能力只有64KB。**
8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址，

当8086CPU要读写内存时:
(1) CPU中的相关部件提供两个16位的地址，一个称为段地址，另个称为偏移地址:
(2) 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件;
(3) 地址加法器将两个16位地址合成为一个20位的物理地址;
(4) 地址加法器通过内部总线将20位物理地址送入输入输出控制电路:
(5) 输入输出控制电路将20位物理地址送上地址总线:
(6) 20位物理地址被地址总线传送到存储器。
**地址加法器采用物理地址=段地址x16+偏移地址的方法用段地址和偏移地址合成物理（段地址左移四位）**
地址。例如，8086CPU 要访问地址为123C8H的内存单元，此时，地址加法器的工作过程如图2.7所示(图中数据皆为十六进制表示)。

![](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210223143146227.png)

### 2.7 “段地址*16+偏移地址=物理地址”的本质含义

“段地址x16+偏移地址=物理地址”的本质含义是: CPU在访问内存时，用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。

更一般地说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。8086CPU 中，段地址x16可看作是基础地址。

### 2.8 段的概念（内存地址小结）

（1）观察下面的地址

| 物理地址 | 段地址 | 偏移地址 |
| :------: | :----: | :------: |
|  21F60H  | 2000H  |  1F60H   |
|          | 2100H  |  0F60H   |
|          | 21F0H  |  0060H   |
|          | 21F6H  |  0000H   |
|          | 1F00H  |  2F60H   |
|          |  ...   |   ...    |

**结论：**CPU可以用不同的段地址和偏移地址形成同一个物理地址

（2）如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可定位多少个内存单元？

**结论：**偏移地址16位，变化范围为0~FFFFH,仅用偏移地址来寻址最多可寻64KB个内存单元

在8086PC机中，存储单元的地址用两个元素来描述，即段地址和偏移地址。
“数据在 21F60H内存单元中。”这句话对于 8086PC机一般不这样讲， 取而代之的是两种类似的说法
①数据存在内存2000:1F60单元中；
②数据存在内存的2000H段中的1F60H单元中。
这两种描述都表示“数据在内存21F60H单元中”。

可以根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段。

### 2.9 段寄存器（Segment Register）

段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器：CS（Code Segment）、DS（Data Segment）、SS（Stack Segment）、ES（Extra Segment）、当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。

本章中只看一下CS

<center><span style='color:blue;font-size:15px'>2021/3/2</span></center>

### 2.10 CS和IP（指令的执行过程）

CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。**CS为代码段寄存器**（Code Segment），**IP 为指令指针寄存器**（Instruction Pointer），从名称上我们可以看出它们和指令的关系。

在8086PC机中，任意时刻，设CS中的内容为M，IP中的内容为N, 8086CPU 将从内存Mx16+N单元开始，读取一条指令并执行。
也可以这样表述: 8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。

![](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/RV8OC4_%7DN08H4BD4QD%604K%5DH.png)

读取一条指令后，IP中的值自动增加，以使CPU可以读取下一条指令，当前读入的指令B82301长度为3个字节，所以IP中的值增加3，后面的指令也依次如上运行

**8086CPU的工作过程可以简要描述如下。**
(1) 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器:
(2) IP=IP+所读取指令的长度， 从而指向下一条指令:
(3) 执行指令。转到步骤(1)， 重复这个过程。

在8086CPU加电启动或复位后，CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。

**在内存中，指令和信息没有任何区别，CPU根据什么将内存中的信息看作指令？**
CPU将CS:IP指向的内存单元中的内容看作指令。如果说，内存中的一段信息曾被CPU执行过的话，那么，它所在的内存单元必然被CS:IP指向过。

### 2.11 修改CS、IP的指令（jmp）

使用mov（传送指令）可以修改大部分寄存器的值，如AX，BX等，但不能设置CS，IP的值。
能够改变CS，IP的内容的指令被统称为转移指令，现在介绍一个最简单的：**jmp指令**
若想同时修改CS、IP的内容，可用形似”**jmp 段地址:偏移地址**“的指令完成
若想仅修改IP的内容，可直接用”**jmp 某一合法寄存器**“的指令完成

### 2.12 代码段

对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段，如果用于存代码，就可以认为是一个代码段。

将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认可被CS:IP指向的内存单元中的内容为指令。

<center><span style='color:blue;font-size:15px'>2021/3/3</span></center>

### 实验1 查看CPU和内存，用机器指令和汇编指令编程

#### 1.预备知识：Debug的使用

(1)什么是Debug?
Debug是DOS、Windows 都提供的实模式(8086方式)程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。

**实模式：**16位模式，不同的程序可使用不同的分段策略，两个程序的不同逻辑地址，可能对应相同的物理地址，程序A可能修改程序B已经保存在内存里的值（游戏修改器）。

**保护模式：**32位模式，程序不能更改其他程序的内存。

(2)常用到的Debug功能。

- 用Debug的R命令查看、改变CPU寄存器的内容； 
- 用Debug的D命令查看内存中的内容；
- 用Debug的E命令改写内存中的内容；
- 用Debug的U命令将内存中的机器指令翻译成汇编指令；
- 用Debug的T命令执行一条机器指令；
- 用Debug的A命令以汇编指令的格式在内存中写入一条机器指令。

![用R命令查看、改变CPU寄存器的内容](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303182904129.png)

也可以用R命令来改变寄存器中的内容，如"r ax" "r ip"等

![用D命令查看内存中的内容](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303184200633.png)

使用D命令，Debug将输出3部分内容

（1）中间是从指定地址开始的128（16*8）个内存单元的内容，用十六进制的格式输出。

（2）左边是每行的起始地址 

（3）右边是每个内存单元中的数据对应的可显示的ASCII码字符

![用E命令改写内存中的内容](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303185328227.png)

也可直接写e 1000:0后逐个修改

![用E命令向内存中写入字符和字符串](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303185916604.png)

如何向内存中写入机器码呢？我们知道，机器码也是数据，也可以用E命令将机器码写入内存。

| 机器码 | 对应的汇编指令 |
| :----: | :------------: |
| b80100 |  mov ax,0001   |
| b90200 |  mov cx,0002   |
|  01c8  |   add ax,cx    |

![写入机器码并用U命令查看](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303190646149.png)

U命令可以将内存单元中的内容翻译为汇编指令，并显示出来。

由此，我们可以再一次看到内存中的数据和代码没有任何区别，关键在于如何解释。

如何执行我们写入的机器指令呢？使用Debug的T命令可以执行一条或多条指令。

![使用T命令执行CS:IP指向的指令](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303191609348.png)

用E命令写入机器指令很不方便，为此，Debug提供了A命令。

![用A命令写入指令](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303215741998.png)

#### 2.实验任务

（1）使用Debug，将下面的程序段写入内存，逐条执行，观察每条指令执行后CPU中相关寄存器中内容的变化。（ez）

（2）将下面3条指令写入从2000:0开始的内存单元中，利用这3条指令计算2的8次方。（ez）

>mov ax,1
>
>add ax,ax
>
>jmp 2000:0003

(3)主板上的ROM中写有一个生产日期，在内存FFF00H~FFFFFH的某几个单元中，请找到这个生产日期并试图改变它

![](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303221907140.png)

rom修改无效 这个日期是由于win10不自带debug，所以使用DosBox来虚拟Dos环境，这个日期也是虚拟出来的，由于不是直接操作实模式，避免了一些误操作。

(4)向内存从B8100H开始的单元中填写数据

![](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303223129794.png)

![执行后在屏幕右上方出现这些字符](https://cdn.jsdelivr.net/gh/neverland7/Ep4l.com@master/public/images/assembly/image-20210303223121403.png)

但是用d查看，内存中存储的数据会变化，因为显存中的内容和屏幕是一一对应的。在

输入的过程中屏幕上的内容变化了，显存中的内容也会跟着变。



## 第3章 寄存器（内存访问）

上一章中，我们主要从CPU如何执行指令的角度讲解了8086CPU的逻辑结构，形成物理地址的方法，相关的寄存器以及一些指令。
这一章中，我们从访问内存的角度继续学习几个寄存器。

### 3.1 内存中字的存储

CPU中，用16位寄存器来存储一个字。高8位高字节，低8位低字节。在内存中存储时，由于内存是字节单元，则一个字要用两个地址连续的内存单元来存放。
比如用0,1两个内存单元来存放数据20000（4E20H)，则0号单元存储20H，1号单元存储4EH。

我们提出**字单元**的概念：字单元，即存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。

### 3.2  DS和[address]

CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。

> mov bx,1000H
>
> mov ds,bx
>
> mov al,[0]

上面的3条指令将10000H(1000:0)中的数据读到al中。
mov除了前面用过的将数据送入寄存器，讲寄存器的内容送入另一个寄存器，还可以**将一个内存单元的内容送入一个寄存器**中。
[···]表示一个内存单元。[···]中的0表示内存单元的偏移地址，执行指令时，8086CPU自动取ds中的数据为内存单元的段地址。

由于8086CPU不支持将数据直接送入段寄存器的操作，所以只好用一个寄存器进行中转。

### 3.3 字的传送

因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是说可以一次性传送一个字。只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了。

### 3.4 mov、add、sub指令

mov指令允许的形式：

- mov 寄存器,数据
- mov 寄存器,寄存器
- mov 寄存器,内存单元
- mov 内存单元,寄存器
- mov 段寄存器,寄存器
- mov 寄存器,段寄存器
- mov 内存单元,段寄存器
- mov 段寄存器,内存单元

数据其实也可以mov给内存单元，但是要加位宽修饰符

add和sub一样，都有两个操作对象，也可以有几种形式

- add 寄存器,数据
- add 寄存器,寄存器
- add 寄存器,内存单元
- add 内存单元,寄存器

<center><span style='color:blue;font-size:15px'>2021/4/10</span></center>

### 3.5 数据段

前面讲过，对于8086pc机，在编程时，可以根据需要，将一组内存单元定义为一个段。所以我们也可以将一组长度小于64kb，地址连续，起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。

将一段内存当作数据段，是我们在编程时的一种安排，可以在具体操作时，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。

>数据和程序没有区别，段地址若是ds段，可看做是数据，段地址若是cs段，可看做是程序指令

### 3.6 栈

LIFO(Last In First Out)

### 3.7 CPU提供的栈机制

现今的CPU中都有栈的设计，8086CPU提供相关的指令来以栈的方式访问内存空间。这意味着，可以将一段内存当作栈来使用

下面举例说明，我们可以将10000H~1000FH这段内存当作栈来使用。

![8086CPU的栈操作](/images/assembly/image-20210410145339891.png)

~~~assembly
mov ax,0123H
push ax
mov bx,2266H
push bx
mov cx,1122H
push cx
pop ax
pop bx
pop cx
~~~

**注意**：字型数据用两个单元存放，高地址单元存放高8位，低地址单元存放低8位。

在8086CPU中，有两个寄存器，**段寄存器**SS (Stack Segment) 和**寄存器**SP (stack pointer) ，栈顶的段地址存放在SS中，偏移地址存放在SP中。任意时刻，SS:SP指向栈顶元素，push和pop指令执行时，CPU从SS和SP中得到栈顶的地址。

>如上图，初试状态栈为空时，SS=1000H，SP=0010H

push ax 的执行，由以下两步完成。

1. SP=SP-2，SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶
2. 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶

pop ax 的执行过程和 push ax 刚好相反，由以下两步完成。

1. 将SS:SP 指向的内存单元处的数据送入ax中
2. SP=SP+2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新栈顶

### 3.8 栈顶超界的问题

栈顶超界是危险的，我们希望CPU可以帮我们解决这个问题，但实际的情况是，8086CPU中并没有这样的寄存器，我们在编程的时候要自己操心栈顶超界的问题。

### 3.9 push、pop指令

push和pop指令的格式可以是如下形式：

- push 寄存器
- push 段寄存器
- push 内存单元

push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov不同的是，push和pop指令访问的内存单元的地址是由SS:SP 指出的。同时，push 和 pop 指令还要改变sp中的内容。

### 3.10 栈段

我们也可以将长度小于64kb的一组地址连续，起始地址为16的倍数的内存单元当作栈空间来用，从而定义了一个栈段。（段地址放在ss中）

> 一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于CPU中寄存器的设置，即CS , IP , SS , SP , DS的指向。



### 实验2 用机器指令和汇编指令编程

#### 1.预备知识：Debug的使用

(1)关于D命令

D命令是查看内存单元的命令，CPU在访问内存单元的时候从段寄存器中得到内存单元的段地址，所以，Debug在其处理D命令的程序段中，必须有将段地址送入寄存器的代码。

D命令也提供了一种符合CPU机理的格式：“d 段寄存器:偏移地址"，以下是几个例子。

~~~assembly
①	-r ds
	:1000
	-d ds:0							;查看从1000:0开始的内存
②	-r ds
	:1000
	-d ds:10 18						;查看1000:10~1000:18中的内容
③	-d cs:0							;查看当前代码段中的指令代码
④	-d ss:0							;查看当前栈段中的内容
~~~

(2)在E、A、U命令中使用寄存器

~~~assembly
①	-r ds
	:1000
	-e ds:0 11 22 33 44 55 66		;查看从1000:0开始的内存
②	-u cs:0							;以汇编指令的形式，显示当然代码段中的代码
③ 	-r cs:0
	:1000
	-a ds:0							;以汇编指令的形式，向从1000:0开始的内存单元中写入指令
~~~

(3)下一条指令执行了吗？

~~~assembly
mov ax,2000
mov ss,ax
mov sp,10
mov ax,3123
...
~~~

在用T执行单步操作 mov ss,ax 后，下一条指令直接变成了mov ax,3123。
在用T命令执行 mov ss,ax的时候，它的下一条指令mov sp,10也紧接着执行了。
不单是mov ss,ax，对于如 mov ss,bx，mov ss,[0]，pop ss等指令都会发生上面的情况，这些指令有哪些共性呢，它们都是**修改栈段寄存器SS的指令**。

为什么会这样呢，这涉及我们在以后的课程中要深入研究的内容：**中断机制**。

#### 2.实验任务

(1) 使用Debug，将下面的程序段写入内存，逐条执行，根据指令执行后的实际运行情况填空。（ez)

(2) 仔细观察图3.19中的实验内容，然后分析：为什么2000:0~2000:f中的内容会发生改变。（书上）



<center><span style='color:blue;font-size:15px'>2021/4/11</span></center>

## 第4章 第一个程序

现在我们将开始编写完整的汇编语言程序，用编译和连接程序将它们编译连接成为可执行文件

### 4.1 一个源程序从写出到执行的过程

- 编写源程序
- 对源程序进行编译连接（编译生成目标文件，连接生成可执行文件）
- 执行可执行文件中的程序

### 4.2 源程序

~~~assembly
assume cs:codesg
codesg segment
		mov ax,0123H
		mov bx,0456H
		add ax,bx
		add ax,ax
		
		mov ax,4c00H
		int 21H
codesg ends
end
~~~

#### 1. 伪指令

在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令有对应的机器码，可以被编译为机器指令，最终为CPU所执行。而伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。

上面的程序出现了3种伪指令

(1)	XXX segment
					...
		XXX ends
segment 和 ends 是一对成对使用的伪指令，是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。功能是定义一个段，分别说明段的开始和结束。
一个汇编程序是由多个段组成的，这些段被用来存放代码，数据或当作栈空间来使用。
一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。

(2)	end
end是一个汇编程序的结束标记，汇编器在编译汇编程序的过程中，如果碰到了指令end，就结束对源程序的编译。
**注意**：不要把end和ends搞混

(3)	assume
这条伪指令可以把某一段寄存器和程序中的某一个用segment...ends定义的段相关联。

#### 2. 源程序中的"程序"

程序最先以汇编指令的形式存放在源程序中，经编译，连接后转变为机器码，存储在可执行文件中。（伪指令是由编译器来处理的）

#### 3. 标号

如“codesg”。一个标号指代了一个地址，作为一个段的名称，这个段的名称最终将被编译，连接程序处理为一个段的段地址。

#### 4. 程序的结构

如上程序

#### 5. 程序返回

若想要一个程序p2运行，则必须有一个正在运行的程序p1，将p2从可执行文件中加载入内存后，将CPU的控制权交给p2，p2才能运行。p2开始运行后，p1暂停运行。
当p2运行完毕后，将CPU的控制权交还给使它得以运行的程序p1，此后，p1继续运行。
我们把交还CPU的控制权的过程称为**程序返回**

​	mov ax,4c00H
​	int 21H

这两条指令所实现的功能就是程序返回。

#### 6. 语法错误和逻辑错误

语法错误可以在程序编译时被编译器发现。

### 4.3 编译源程序

可以用任意的文本编辑器来编辑源程序，只要最终将其存储为纯文本文件即可。(扩展名一般写.asm)

### 4.4 编译

![](/images/assembly/image-20210411105338039.png)

### 4.5 连接

![](/images/assembly/image-20210411105620229.png)

连接的作用有以下几个

- 当源程序很大时，可以将它分为多个源程序文件来编译，成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件。
- 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件。
- 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。

### 4.6 以简化的方式进行编译和连接

### 4.7 1.exe的运行

### 4.8 谁将可执行文件中的程序装载进入内存并使它运行？

#### 操作系统的外壳（shell）

任何通用的操作系统，都要提供一个称为shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统进行工作。

DOS中有一个程序**command.com**，这个程序在DOS中称为命令解释器，也就是**DOS系统的shell**。

DOS启动时，先完成其他重要的初始化工作，然后运行command.com，command.com运行后，执行完其他的相关任务后，在屏幕上显示出由当前盘符和当前路径组成的提示符，等待用户的输入。

用户可以输入所要执行的命令，如cd、dir等，这些命令由command执行，完成这些命令后，再次等待用户的输入。

**如果用户要执行一个程序**，则输入可执行文件的名称，command会找到文件，将这个可执行文件中的程序加载入内存，设置CS：IP指向程序的入口，此后，command暂停运行，CPU运行程序。程序运行结束后，返回到command中，再次等待用户输入。

刚才的汇编程序从写出到执行的过程：

| 编程     | 1.asm | 编译     | 1.obj | 连接     | 1.exe | 加载        | 内存中的程序 | 运行    |
| -------- | ----- | -------- | ----- | -------- | ----- | ----------- | ------------ | ------- |
| （Edit） |       | （masm） |       | （link） |       | （command） |              | （CPU） |

### 4.9 程序执行过程的跟踪

使用command不能逐条指令地看到程序的执行过程，因为command的程序加载，设置CS：IP指向程序的入口的操作是连续完成的，当CS：IP一指向程序的入口，command就放弃了CPU的控制权。

为了观察程序的运行过程，可以使用Debug，Debug可以将程序加载入内存，设置CS：IP指向程序的入口，但Debug并不放弃对CPU的控制，这样，我们就可以使用Debug的相关命令来单步执行程序，查看每一条指令的执行结果。

![](/images/assembly/image-20210411113906738.png)

这里，需要讲解一下DOS系统中.EXE文件中的程序的加载过程。

![](/images/assembly/image-20210411165545638.png)

（1）程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为ds：0；

（2）这个内存区的前256个字节中存放的是PSP，DOS用来和程序进行通信。从256字节处向后的空间存放的是程序。

### 实验3 编程、编译、连接、跟踪

书上

<center><span style='color:blue;font-size:15px'>2021/4/12</span></center>

## 第5章 [BX]和loop指令

**1.[bx]和内存单元的描述**

[bx]同样也表示一个内存单元，它的偏移地址在bx中，比如下面的指令:
mov ax,[bx]
将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址在bx中，段地址在ds中

**2.loop**

我们在这一章，讲解[bx]和loop指令的应用、意义和相关的内容。

**3.我们定义的描述性的符号:“()”**

为了描述上的简洁，使用一个描述性的符号 “()”来表示一个寄存器或一个丙存单元中的内容。比如:
(ax)表示ax中的内容、(al)表示al中的内容:

**4.约定符号idata表示常量**

### 5.1 [BX]

mov ax, [bx]
功能: bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。即: (ax)=((ds)* 16+(bx))。

**注意：**inc bx的含义是bx中的内容加1。

### 5.2 Loop指令

loop指令的格式是: loop 标号，CPU执行loop指令的时候，要进行两步操作，
①(cx)=(cx)-1;
②判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。

从上面的描述中，可以看到，cx中的值影响着loop指令的执行结果。通常我们用loop指令来实现循环功能，cx 中存放循环次数。

任务：编程计算$2^{12}$

分析：计算$2^{12}$需要11条重复的指令 add ax,ax。

~~~assembly
assume cs:code
code segment
	mov ax,2
	mov cx,11
s:	add ax,ax
	loop s
	mov ax,4c00h
	int 21h
code ends;
end
~~~

用cx和loop指令相配合实现循环功能的程序框架如下

~~~assembly
	mov cx，循环次数
s:	
	循环执行的程序段
	loop s
~~~

### 5.3 在Debug中跟踪用loop指令实现的循环程序

![image-20210412144427605](/images/assembly/image-20210412144427605.png)

循环程序段从CS:0012开始，CS:0012前面的指令，我们不想一步步跟踪，可以使用g命令"g 0012"，它表示执行程序到当前代码段的0012h处。

当遇到loop指令时，可以使用p命令来执行，Debug就会自动重复执行循环中的指令，直到(cx)=0为止。

当然，也可以使用g命令来达到目的。

### 5.4 Debug和汇编编译器masm对指令的不同处理

在Debug中，mov ax,[0]表示将ds:0处的数据送入ax中。
但是在汇编源程序中，指令“mov ax,[0]”被编译器当作指令"mov ax,0处理"。

那么我们如何在源程序中实现将内存2000:0之类的数据送入al，bl，cl，dl呢？
可将偏移地址送入bx寄存器中，用[bx]的方式来访问内存单元。
也可以在[]的前面显式地给出段地址所在的段寄存器，如"mov al,ds:[0]"。

### 5.5 loop和[bx]的联合应用

计算ffff:0~ffff:b单元中的数据的和，结果存储在dx中。

~~~assembly
assume cs:code
code segment
	mov ax,0ffffh
	mov ds,ax
	mov bx,0					;bx充当代表内存单元地址的变量
	mov dx,0
	mov cx,12
s:	mov al,[bx]
	mov ah,[0]
	add,dx,ax
	inc bx
	loop s

	mov ax,4c00h
	int 21h
code ends
end
~~~

### 5.6 段前缀

我们可以在访问内存单元的指令中显示地给出内存单元的段地址所在的寄存器，比如"ds:" "cs:"等，这些在汇编语言中称为段前缀。

### 5.7 一段安全的空间

在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或代码。

在一般的pc机中，DOS方法下，0:200~0:2ff的256个字节的空间一般不会被使用。

### 5.8 段前缀的使用

将内存ffff:0\~ffff:b单元中的数据复制到0:200\~0:20b单元中。

~~~assembly
assume cs:code
code segment
	mov ax,0ffffh
	mov ds,ax
	mov ax,0020h
	mov es,ax
	mov bx,0
	mov cx,12
s:	mov dl,[bx]
	mov es:[bx],dl
	inc bx
	loop s
	
	mov ax,4c00h
	int 21h
code ends
end
~~~

### 实验4 [bx]和loop的使用

(1)、(2)编程，向内存0:200\~0:23F依次传送数据0\~63(3FH)。

~~~assembly
assume cs:code
code segment
	mov ax,20h
	mov ds,ax
	mov bx,0
	mov cx,64
s:	mov [bx],bx
	inc bx
	loop s
	
	mov ax,4c00h
	int 21h
code ends
end
~~~

![](/images/assembly/image-20210412161520503.png)

<center><span style='color:blue;font-size:15px'>2021/4/13</span></center>

## 第6章 包含多个段的程序

在前面的程序中，只有一个代码段，现在的问题是，如果程序需要用其他空间来存放数据，使用哪里呢？
合法地通过操作系统取得的空间都是安全的，程序取得空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在执行的过程中向系统申请。在我们的课程中，不讨论第二种方法。

### 6.1 在代码段中使用数据

从规范的角度来讲，我们是不能自已随便决定哪段空间可以使用的，应该让系统来为我们分配。
我们可以在程序中，定义我们希望处理的数据，这现数据就会被编译、连接程序作为程序的一部分载入内存。 与此同时，我们要处理的数据也就自然而然地获得了存储空间。

编程计算8个数据的和，结果存在ax寄存器中：

~~~assembly
assume cs:code
code segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	mov cx,0
	...
code ends
end
~~~

dw(define word)的含义是定义字型数据，由于它们在代码段中，所以可以从cs中得到它们的段地址。用dw定义的数据处于代码段的最开始，所以偏移地址为0。

可是这样一来，我们就必须用Debug来执行程序，因为程序的入口处不是我们所希望执行的指令（指令在ip=10h处）。我们可以在源程序中指明程序的入口所在。

~~~assembly
assume cs:code
code segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	strat:	mov bx,0
			mov ax,0
			mov cx,8
		s:	add ax,cs:[bx]
			add bx,2
			loop s
			
			mov ax,4c00h
			int 21h
code ends
end start
~~~

end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。在程序6.2中我们**用end指令指明了程序的入口**在标号start处。

在前面的课程中，我们已经知道在单任务系统中，**可执行文件中的程序执行过程如下**。
(1)由其他的程序(Debug、command 或其他程序)将可执行文件中的程序加载入内存:
(2)设置CS:IP指向程序的第一条要执行的指令(即程序的入口)，从而使程序得以运行;
(3)程序运行结束后，返回到加载者。

现在的问题是，**根据什么设置CPU的CS:IP 指向程序的第一条要执行的指令？**
这一点，是由可执行文件中的描述信息指明的。我们知道可执行文件由描述信息和程序组成，程序来自于源程序中的汇编指令和定义的数据；**描述信息**则主要是编译、连接程序对源程序中**相关伪指令进行处理**所得到的信息。我们在程序6.2中，用伪指令end描述了程序的结束和程序的入口。在编译、连接后，由“end start” 指明的程序入口，被转化为一个入口地址，存储在可执行文件的描述信息中。在被加载到内存后，加载者从程序的可执行文件的描述信息中读到程序的入口地址，设置CS:IP。

### 6.2 在代码段中使用栈

完成下面的程序，利用栈，将程序中定义的数据逆序存放

~~~assembly
assume cs:codesg
codesg segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	?
codesg ends
end
~~~

可以在程序中通过定义数据来取得一段空间，然后将这段空间当作栈空间来用。



~~~assembly
assume cs:codesg
codesg segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			;用dw定义16个字型数据，当栈来使用。
	start:	mov ax,cs
			mov ss,ax
			mov sp,30h
			
			mov bx,0
			mov cx,8
		s:	push cs:[bx]
			add bx,2
			loop s
			
			mov bx,0
			mov cx,8
		s0:	pop cs:[bx]
			add bx,2
			loop s0
			
			mov ax,4c00h
			int 21h
codesg ends
end start
~~~

ss:sp要指向栈底，使用设置ss:sp指向cs:30

### 6.3 将数据、代码、栈放入不同的栈

我们用和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间。

~~~assembly
assume cs:code,ds:data,ss:stack
data segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends
stack segment
	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
stack ends
code segment
	start:	mov ax,stack
			mov ss,ax
			mov sp,20h
			
			mov ax,data
			mov ds,ax
			
			mov bx,0
			mov cx,8
		s:	push [bx]
			add bx,2
			loop s
			
			mov bx,0
			mov cx,8
		s0:	pop [bx]
			add bx,2
			loop s0
			
			mov ax,4c00h
			int 21h
code ends
end start
~~~

我们可以明显看出，定义一个段的方法和前面讲的定义代码段的方法没有区别。在程序中，段名就相当于一个标号，它代表了段地址。但是我们用伪指令"assume cs:code,ds:data,ss:stack"，CPU并没有真正将cs，ds，ss指向这3个地址，而是我们后来写的指令将其送入，因为assume是伪指令，是由编译器执行的，CPU并不知道它们，我们不必深究assume的作用。

### 实验5 编写、调试具有多个段的程序

书上。

每个段的大小最低为16字节的倍数，向上取整。

## 第7章 更灵活的定位内存地址的方法

本章我们主要通过具体的问题来讲解一些更灵活的定位内存地址的方法和相关的编程方法

### 7.1 and 和 or 指令

(1) and指令：逻辑与指令，按位进行与运算。
mov 		 al, 01100011B
and	 	  al, 00111011B
执行后: 	al=00100011B
通过该指令可将操作对象的相应位设为0，其他位不变。

(2) or指令：逻辑或指令，按位进行或运算。
mov 		 al, 01100011B
or    		  al, 00111011B
执行后: 	al=01111011B
通过该指令可将操作对象的相应位设为1,其他位不变。

<center><span style='color:blue;font-size:15px'>2021/4/14</span></center>

### 7.2 关于ASCII码